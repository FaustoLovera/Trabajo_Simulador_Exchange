==================================================
=== REPORTE DE CÃ“DIGO CONSOLIDADO ===
Proyecto: Trabajo_Simulador_Exchange
Ruta: /Users/andreiveis/UADE/2do cuatrimestre/05_Algoritmos y Estructura de datos I/Trabajo_Simulador_Exchange
Generado el: Sat Jun 21 11:50:09 -03 2025
==================================================

--- INFORMACIÃ“N DEL REPOSITORIO GIT ---
Rama actual: dev
Ãšltimo commit: fc300ba - FIX - Visualizador de disponible (andreiveisuade, 11 hours ago)
---

--- ESTRUCTURA DEL DIRECTORIO ---
.
â”œâ”€â”€ .gitignore
â”œâ”€â”€ backend
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ acceso_datos
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ datos_billetera.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ datos_cotizaciones.py
â”‚Â Â  â”‚Â Â  â””â”€â”€ datos_historial.py
â”‚Â Â  â”œâ”€â”€ app.py
â”‚Â Â  â”œâ”€â”€ rutas
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ api_externa.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ billetera_vista.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ home.py
â”‚Â Â  â”‚Â Â  â””â”€â”€ trading_vista.py
â”‚Â Â  â”œâ”€â”€ servicios
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ api_cotizaciones.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ cotizaciones.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ estado_billetera.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ trading_logica.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ trading_models.py
â”‚Â Â  â”‚Â Â  â””â”€â”€ velas_logica.py
â”‚Â Â  â”œâ”€â”€ swagger.yaml
â”‚Â Â  â””â”€â”€ utils
â”‚Â Â      â””â”€â”€ formateo_decimales.py
â”œâ”€â”€ config.py
â”œâ”€â”€ documentacion.md
â”œâ”€â”€ frontend
â”‚Â Â  â”œâ”€â”€ static
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ css
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ img
â”‚Â Â  â”‚Â Â  â””â”€â”€ js
â”‚Â Â  â””â”€â”€ templates
â”‚Â Â      â”œâ”€â”€ billetera.html
â”‚Â Â      â”œâ”€â”€ fragmento_billetera.html
â”‚Â Â      â”œâ”€â”€ fragmento_historial.html
â”‚Â Â      â”œâ”€â”€ fragmento_tabla.html
â”‚Â Â      â”œâ”€â”€ index.html
â”‚Â Â      â””â”€â”€ trading.html
â”œâ”€â”€ README.md
â””â”€â”€ requirements.txt

12 directories, 30 files
---

==================================================
=== ARCHIVO: ./.gitignore ===
==================================================

# ARCHIVOS PROPIOS NUESTROS
/datos/datos_cotizaciones.json
/datos/datos_velas.json
/datos/billetera.json
/datos/historial_operaciones.json


# Python
__pycache__/
backend/__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.env
.venv
env/
venv/
ENV/
.pytest_cache/
.coverage
coverage.xml
*.cover
.hypothesis/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
__MACOSX/

# IDEs and editors
.idea/
.vscode/
*.swp
*.swo
.project
.classpath
*.sublime-workspace
*.sublime-project

# Frontend
node_modules/
/dist
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env.local
.env.*.local
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
*.sqlite
*.sqlite3
*.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Backup files
*.bak
*.backup
*~

# Environment variables
.env
.env.*
!.env.example

# System Files
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
datos/billetera.json
datos/datos_cotizaciones.json
datos/datos_velas.json
*.pyc
# D2 files
*.d2
diagrama.png


==================================================
=== ARCHIVO: ./backend/__init__.py ===
==================================================

from flask import Flask
from config import FLASK_SECRET_KEY
from backend.utils.formateo_decimales import registrar_filtros
from backend.rutas import registrar_rutas


def crear_app():
    app = Flask(
        __name__,
        static_folder="../frontend/static",
        template_folder="../frontend/templates",
    )

    app.secret_key = FLASK_SECRET_KEY

    registrar_filtros(app)
    registrar_rutas(app)

    return app


==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_billetera.py ===
==================================================

import json
import os
from decimal import Decimal, InvalidOperation
from config import BILLETERA_PATH, BALANCE_INICIAL_USDT


def cargar_billetera():
    """
    Carga la billetera desde el archivo JSON de forma segura.
    Si el archivo no existe, estÃ¡ vacÃ­o o corrupto, crea una billetera inicial.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    if not os.path.exists(BILLETERA_PATH) or os.path.getsize(BILLETERA_PATH) == 0:
        billetera_inicial = {"USDT": Decimal(BALANCE_INICIAL_USDT)}
        guardar_billetera(billetera_inicial)
        return billetera_inicial

    try:
        with open(BILLETERA_PATH, "r", encoding="utf-8") as f:
            datos_cargados = json.load(f)
            # Convierte todos los valores a Decimal, manejando posibles errores
            billetera = {}
            for ticker, cantidad_str in datos_cargados.items():
                try:
                    billetera[ticker] = Decimal(str(cantidad_str))
                except InvalidOperation:
                    print(
                        f"Advertencia: Valor invÃ¡lido para {ticker} en billetera.json. Se usarÃ¡ 0."
                    )
                    billetera[ticker] = Decimal("0")
            return billetera
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: Archivo '{BILLETERA_PATH}' corrupto. Se reiniciarÃ¡ la billetera."
        )
        billetera_inicial = {"USDT": Decimal(BALANCE_INICIAL_USDT)}
        guardar_billetera(billetera_inicial)
        return billetera_inicial


def guardar_billetera(billetera):
    """
    Guarda el estado de la billetera en el archivo JSON.
    Convierte los valores Decimal a string para preservar la precisiÃ³n.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    # Prepara la billetera para ser guardada, convirtiendo Decimal a string
    billetera_serializable = {
        ticker: str(cantidad) for ticker, cantidad in billetera.items()
    }

    with open(BILLETERA_PATH, "w", encoding="utf-8") as f:
        json.dump(billetera_serializable, f, indent=4)


==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_cotizaciones.py ===
==================================================

import json
import os
from decimal import Decimal, InvalidOperation
from config import COTIZACIONES_PATH


def obtener_precio(ticker):
    """
    Obtiene el precio de un ticker especÃ­fico desde el archivo de cotizaciones.
    Devuelve el precio como un objeto Decimal, o None si no se encuentra.
    """
    cotizaciones = cargar_datos_cotizaciones()
    ticker_lower = ticker.lower()

    for cripto in cotizaciones:
        if cripto.get("ticker", "").lower() == ticker_lower:
            # Aseguramos que devolvemos un Decimal vÃ¡lido
            try:
                return Decimal(str(cripto.get("precio_usd")))
            except (InvalidOperation, TypeError):
                return Decimal("0")  # Devuelve 0 si el precio es invÃ¡lido

    return None  # Retorna None si el ticker no se encuentra en la lista


def cargar_datos_cotizaciones():
    """
    FunciÃ³n interna y segura para cargar todas las cotizaciones.
    Maneja archivos inexistentes o corruptos.
    """
    if not os.path.exists(COTIZACIONES_PATH) or os.path.getsize(COTIZACIONES_PATH) == 0:
        return []

    try:
        with open(COTIZACIONES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return []


==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_historial.py ===
==================================================

import json
import os
from datetime import datetime
from decimal import Decimal
from config import HISTORIAL_PATH


def cargar_historial():
    """
    Carga el historial de transacciones desde el archivo JSON.
    Si el archivo no existe, estÃ¡ vacÃ­o o corrupto, devuelve una lista vacÃ­a.
    """
    if not os.path.exists(HISTORIAL_PATH) or os.path.getsize(HISTORIAL_PATH) == 0:
        return []

    try:
        with open(HISTORIAL_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: No se pudo leer o el archivo '{HISTORIAL_PATH}' estÃ¡ corrupto."
        )
        return []


def guardar_en_historial(
    tipo_operacion,
    moneda_origen,
    cantidad_origen,
    moneda_destino,
    cantidad_destino,
    valor_usd,
):
    """
    Guarda una nueva operaciÃ³n en el historial de transacciones.
    """
    # Asegurarse de que el directorio de datos exista
    os.makedirs(os.path.dirname(HISTORIAL_PATH), exist_ok=True)

    historial = cargar_historial()

    # Crear el diccionario para la nueva operaciÃ³n
    operacion = {
        "id": len(historial) + 1,
        "timestamp": datetime.now().isoformat(),
        "tipo": tipo_operacion,
        "origen": {"ticker": moneda_origen, "cantidad": str(cantidad_origen)},
        "destino": {"ticker": moneda_destino, "cantidad": str(cantidad_destino)},
        "valor_usd": str(valor_usd.quantize(Decimal("0.01"))),
    }

    # AÃ±adir la nueva operaciÃ³n al principio de la lista
    historial.insert(0, operacion)

    # Escribir la lista completa de nuevo en el archivo
    with open(HISTORIAL_PATH, "w", encoding="utf-8") as f:
        json.dump(historial, f, indent=4)


==================================================
=== ARCHIVO: ./backend/app.py ===
==================================================

from flask import render_template
from . import crear_app
from flasgger import Swagger

app = crear_app()
swagger = Swagger(app)

# http://localhost:5000/apidocs
# Para ver la documentacion interactiva

if __name__ == "__main__":
    app.run(debug=True)


==================================================
=== ARCHIVO: ./backend/rutas/__init__.py ===
==================================================

from .home import bp as home_bp
from .trading_vista import bp as trading_bp
from .billetera_vista import bp as billetera_bp
from .api_externa import bp as api_ruta_bp


def registrar_rutas(app):
    app.register_blueprint(home_bp)
    app.register_blueprint(trading_bp)
    app.register_blueprint(billetera_bp)
    app.register_blueprint(api_ruta_bp)


==================================================
=== ARCHIVO: ./backend/rutas/api_externa.py ===
==================================================

from flask import Blueprint, jsonify, render_template
from backend.servicios.api_cotizaciones import obtener_datos_criptos_coingecko
from backend.servicios.cotizaciones import renderizar_fragmento_tabla
from config import VELAS_PATH, COTIZACIONES_PATH
import json

bp = Blueprint("api_externa", __name__, url_prefix="/api")


@bp.route("/actualizar")
def actualizar():
    """
    Actualiza los datos de criptomonedas desde CoinGecko.
    ---
    responses:
      200:
        description: Devuelve estado ok y la cantidad de criptomonedas obtenidas.
        examples:
          application/json: { "estado": "ok", "cantidad": 50 }
    """
    datos = obtener_datos_criptos_coingecko()
    return jsonify({"estado": "ok", "cantidad": len(datos)})


@bp.route("/datos_tabla")
def datos_tabla():
    """
    Retorna el fragmento HTML de la tabla de cotizaciones.
    ---
    responses:
      200:
        description: Fragmento HTML de la tabla renderizado.
        content:
          text/html:
            example: "<tr><td>BTC</td><td>63500</td></tr>"
    """
    return renderizar_fragmento_tabla()


@bp.route("/velas")
def obtener_datos_velas():
    """
    Retorna los datos de velas desde un archivo JSON.
    ---
    responses:
      200:
        description: Datos de velas en formato JSON.
        content:
          application/json:
            example:
              [
                {"timestamp": 1714939200, "open": 65000, "close": 65500, "high": 66000, "low": 64500, "volume": 1200}
              ]
      500:
        description: Error al leer el archivo.
    """
    try:
        with open(VELAS_PATH, "r") as archivo:
            datos = json.load(archivo)
        return jsonify(datos)
    except Exception as e:
        print("âŒ Error leyendo datos_velas.json:", e)
        return jsonify({"error": "No se pudo leer el archivo"}), 500


==================================================
=== ARCHIVO: ./backend/rutas/billetera_vista.py ===
==================================================

from flask import Blueprint, render_template, jsonify
from decimal import Decimal, ROUND_DOWN
from backend.servicios.estado_billetera import estado_actual_completo
from backend.acceso_datos.datos_historial import cargar_historial
from backend.acceso_datos.datos_billetera import cargar_billetera

bp = Blueprint("billetera", __name__)


@bp.route("/billetera")
def mostrar_billetera():
    """
    Muestra el estado completo de la billetera en una tabla HTML.
    ---
    responses:
      200:
        description: Renderiza la vista de billetera.
        content:
          text/html:
            example: "<table><tr><td>BTC</td><td>0.5</td></tr></table>"
    """
    datos_billetera = estado_actual_completo()
    return render_template("billetera.html", datos=datos_billetera)


@bp.route("/estado")
def estado():
    """
    Devuelve el contenido actual de la billetera en formato JSON.
    ---
    responses:
      200:
        description: JSON con los saldos actuales.
        content:
          application/json:
            example: { "BTC": 0.5, "ETH": 2.0 }
    """
    return jsonify(cargar_billetera())


@bp.route("/api/billetera")
def render_fragmento_billetera():
    """
    Devuelve un fragmento HTML con los datos detallados de la billetera.
    ---
    responses:
      200:
        description: Fragmento HTML renderizado con estilo de ganancia/pÃ©rdida.
        content:
          text/html:
            example: "<tr><td>BTC</td><td style='color:green'>+5%</td></tr>"
    """
    datos = estado_actual_completo()
    for d in datos:
        d["color_ganancia"] = "green" if d["ganancia_perdida"] >= 0 else "red"
        d["color_porcentaje"] = "green" if d["porcentaje_ganancia"] >= 0 else "red"
    return render_template("fragmento_billetera.html", datos=datos)


@bp.route("/api/historial")
def render_fragmento_historial():
    """
    Devuelve un fragmento HTML con el historial de transacciones.
    ---
    responses:
      200:
        description: Fragmento HTML con historial de compras y ventas.
        content:
          text/html:
            example: "<tr><td>compra</td><td>BTC</td><td>0.1</td></tr>"
    """
    historial = cargar_historial()
    for h in historial:
        h["color"] = "green" if h["tipo"] == "compra" else "red"
        h["cantidad"] = str(
            Decimal(h["cantidad"]).quantize(Decimal("0.00000001"), rounding=ROUND_DOWN)
        )
    return render_template("fragmento_historial.html", historial=historial)


==================================================
=== ARCHIVO: ./backend/rutas/home.py ===
==================================================

from flask import Blueprint, render_template
from backend.servicios.api_cotizaciones import obtener_datos_criptos_coingecko

bp = Blueprint("home", __name__)


@bp.route("/")
def index():
    """
    PÃ¡gina principal del simulador de exchange.

    ---
    responses:
      200:
        description: Renderiza la pÃ¡gina principal.
        content:
          text/html:
            example: "<html><body>Simulador de exchange</body></html>"
      500:
        description: Error al obtener datos de cotizaciones.
    """
    try:
        obtener_datos_criptos_coingecko()
        print("ğŸ‘‰ Datos de cotizaciones actualizados.")
    except Exception as e:
        print(f"âš ï¸ Error al actualizar cotizaciones: {e}")
    
    return render_template("index.html")


==================================================
=== ARCHIVO: ./backend/rutas/trading_vista.py ===
==================================================

# backend/rutas/trading_vista.py (VERSIÃ“N CON RUTAS SEPARADAS)

from flask import Blueprint, request, redirect, url_for, render_template, flash

from backend.servicios.trading_logica import procesar_operacion_trading
from backend.servicios.trading_models import preparar_vista_trading

bp = Blueprint("trading", __name__)


# RUTA GET para MOSTRAR la pÃ¡gina de trading
@bp.route("/trading", methods=["GET"])
def mostrar_trading_page():
    """Muestra la interfaz principal de trading."""
    contexto = preparar_vista_trading()
    return render_template("trading.html", **contexto)


# RUTA POST para PROCESAR la operaciÃ³n de trading
@bp.route("/trading/operar", methods=["POST"])
def procesar_trading_form():
    """Procesa los datos del formulario de trading."""
    
    print(">>> DATOS RECIBIDOS DEL FORMULARIO:", request.form)
    
    exito, mensaje = procesar_operacion_trading(request.form)
    flash(mensaje, "success" if exito else "danger")

    # Siempre redirige de vuelta a la pÃ¡gina principal de trading
    return redirect(url_for("trading.mostrar_trading_page"))


==================================================
=== ARCHIVO: ./backend/servicios/__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./backend/servicios/api_cotizaciones.py ===
==================================================

from decimal import Decimal
import requests
from backend.servicios.velas_logica import (
    guardar_datos_cotizaciones,
    guardar_datos_velas,
)
from config import COINGECKO_URL, BINANCE_URL, CANTIDAD_CRIPTOMONEDAS, CANTIDAD_VELAS


def obtener_datos_criptos_coingecko():
    """
    Obtiene informaciÃ³n del mercado de criptomonedas desde la API pÃºblica de CoinGecko.

    Esta funciÃ³n consulta la API de CoinGecko para recuperar los 100 activos principales
    ordenados por capitalizaciÃ³n de mercado, incluyendo su precio actual, variaciones
    porcentuales, volumen de trading y suministro circulante. Los datos obtenidos se procesan
    y almacenan localmente mediante la funciÃ³n `guardar_datos_cotizaciones`.

    Returns:
        List[Dict]: Una lista de diccionarios, donde cada uno representa una criptomoneda con:
            - id (int): Ãndice incremental
            - nombre (str): Nombre de la criptomoneda
            - ticker (str): Ticker en mayÃºsculas
            - logo (str): URL del logo del activo
            - precio_usd (float): Precio actual en USD
            - 1h_% (float): VariaciÃ³n porcentual en 1 hora
            - 24h_% (float): VariaciÃ³n porcentual en 24 horas
            - 7d_% (float): VariaciÃ³n porcentual en 7 dÃ­as
            - market_cap (float): CapitalizaciÃ³n de mercado
            - volumen_24h (float): Volumen de trading en 24h
            - circulating_supply (float): Suministro circulante

    Notas:
        Si ocurre un error de conexiÃ³n o una respuesta invÃ¡lida, la funciÃ³n retorna
        un diccionario con una clave "error" describiendo el problema.
    """
    params = {
        "vs_currency": "usd",
        "order": "market_cap_desc",
        "per_page": CANTIDAD_CRIPTOMONEDAS,
        "page": 1,
        "sparkline": "false",
        "price_change_percentage": "1h,24h,7d",
    }

    try:
        respuesta = requests.get(COINGECKO_URL, params)
    except requests.exceptions.RequestException as e:
        print(f"âŒ Error al obtener datos de CoinGecko: {str(e)}")
        return {"error": "Error al obtener datos de CoinGecko"}
    if respuesta.status_code != 200:
        print(
            f"âŒ Error en la respuesta de CoinGecko: Status code {respuesta.status_code}"
        )
        return {"error": "Respuesta invÃ¡lida de la API"}

    print(f"âœ… Estado de la respuesta: {respuesta.status_code}")

    datos = respuesta.json()
    resultado = list(
        map(
            lambda par: {
                "id": par[0],
                "nombre": par[1].get("name"),
                "ticker": par[1].get("symbol", "").upper(),
                "logo": par[1].get("image"),
                "precio_usd": Decimal(str(par[1].get("current_price"))),
                "1h_%": Decimal(
                    str(par[1].get("price_change_percentage_1h_in_currency"))
                ),
                "24h_%": Decimal(
                    str(par[1].get("price_change_percentage_24h_in_currency"))
                ),
                "7d_%": Decimal(
                    str(par[1].get("price_change_percentage_7d_in_currency"))
                ),
                "market_cap": Decimal(str(par[1].get("market_cap"))),
                "volumen_24h": Decimal(str(par[1].get("total_volume"))),
                "circulating_supply": Decimal(str(par[1].get("circulating_supply"))),
            },
            enumerate(datos, start=1),
        )
    )

    print(f"ğŸ’¡ Total de criptos procesadas: {len(resultado)}")
    guardar_datos_cotizaciones(resultado)
    return resultado


def obtener_velas_binance():
    """
    Obtiene datos histÃ³ricos de velas (Klines) diarias del par BTC/USDT desde la API pÃºblica de Binance.

    Esta funciÃ³n consulta la API de Binance para recuperar las Ãºltimas velas diarias,
    equivalente aproximadamente a un aÃ±o de datos histÃ³ricos. Cada vela contiene precios
    de apertura, mÃ¡ximo, mÃ­nimo, cierre y volumen negociado. Los datos se procesan y almacenan
    localmente mediante la funciÃ³n `guardar_datos_velas`.

    Returns:
        List[Dict]: Una lista de diccionarios, donde cada uno representa una vela diaria con:
            - time (int): Timestamp de apertura en segundos
            - open (float): Precio de apertura
            - high (float): Precio mÃ¡ximo
            - low (float): Precio mÃ­nimo
            - close (float): Precio de cierre
            - volume (float): Volumen negociado

    Notas:
        Si ocurre un error de conexiÃ³n o una respuesta invÃ¡lida, la funciÃ³n retorna
        un diccionario con una clave "error" describiendo el problema.
    """
    params = {
        "symbol": "BTCUSDT",
        "interval": "1d",
        "limit": CANTIDAD_VELAS,
    }
    try:
        respuesta = requests.get(BINANCE_URL, params)
    except requests.exceptions.RequestException as e:
        print(f"âŒ Error al obtener datos de Binance: {str(e)}")
        return {"error": "Error al obtener datos de Binance"}

    if respuesta.status_code != 200:
        print(
            f"âŒ Error en la respuesta de Binance: Status code {respuesta.status_code}"
        )
        return {"error": "Respuesta invÃ¡lida de la API Binance"}

    print(f"âœ… Estado de la respuesta Binance: {respuesta.status_code}")

    datos = respuesta.json()
    resultado = []

    for vela in datos:
        resultado.append(
            {
                "time": int(vela[0] / 1000),  # Timestamp en segundos
                "open": Decimal(str(vela[1])),
                "high": Decimal(str(vela[2])),
                "low": Decimal(str(vela[3])),
                "close": Decimal(str(vela[4])),
                "volume": Decimal(str(vela[5])),
            }
        )

    print(f"ğŸ’¡ Total de velas procesadas: {len(resultado)}")
    guardar_datos_velas(resultado)
    return resultado


==================================================
=== ARCHIVO: ./backend/servicios/cotizaciones.py ===
==================================================

from decimal import Decimal
import json
from config import COTIZACIONES_PATH
from flask import render_template


def obtener_todas_las_cotizaciones():
    try:
        with open(COTIZACIONES_PATH) as f:
            return json.load(f)
    except FileNotFoundError:
        return []


def envolver_variacion_coloreada(valor, con_signo_dolar=False):
    clase = "positivo" if valor > 0 else "negativo"
    sufijo = (
        (lambda v: "$ " if v > 0 else "-$ ")(valor)
        if con_signo_dolar
        else (lambda v: " %" if v > 0 else "% ")(valor)
    )
    flecha = (
        (
            "<span class='flecha-verde'>â–²</span>"
            if valor > 0
            else "<span class='flecha-roja'>â–¼</span>"
        )
        if not con_signo_dolar
        else ""
    )

    valor_redondeado = f"{valor:,.2f}"

    if con_signo_dolar:
        contenido = f"{sufijo}{valor_redondeado}"
    else:
        contenido = f"{valor_redondeado}{sufijo}"

    return f"<span class='{clase}'>{flecha} {contenido}</span>"


def formatear_numero(n, escala_manual=None):
    if n is None:
        return "-"

    if escala_manual:
        escalas = {"T": 1e12, "B": 1e9, "M": 1e6}
        return f"{n / Decimal(str(escalas[escala_manual])):,.2f} {escala_manual}"

    for valor, simbolo in [(1e12, "T"), (1e9, "B"), (1e6, "M")]:
        if n >= valor:
            return f"{n / Decimal(str(valor)):,.2f} {simbolo}"
    return f"{n:.2f}"


def obtener_tabla_criptos():
    from config import COTIZACIONES_PATH

    with open(COTIZACIONES_PATH) as f:
        datos = json.load(f)

    tabla = [
        [
            cripto["id"],
            f"<img src='{cripto['logo']}' width='20' class='logo-cripto'> <span class='nombre-cripto'>{cripto['nombre']}</span> <span class='ticker-cripto'>({cripto['ticker']})</span>",
            envolver_variacion_coloreada(
                Decimal(str(cripto["precio_usd"])), con_signo_dolar=True
            ),
            envolver_variacion_coloreada(Decimal(str(cripto["1h_%"]))),
            envolver_variacion_coloreada(Decimal(str(cripto["24h_%"]))),
            envolver_variacion_coloreada(Decimal(str(cripto["7d_%"]))),
            *map(
                formatear_numero,
                [
                    Decimal(str(cripto["market_cap"])),
                    Decimal(str(cripto["volumen_24h"])),
                    Decimal(str(cripto["circulating_supply"])),
                ],
            ),
        ]
        for cripto in datos
    ]

    return tabla


def renderizar_fragmento_tabla():
    """
    Renderiza el fragmento HTML de la tabla de cotizaciones.
    Returns:
        str: HTML renderizado de la tabla de cotizaciones
    """
    tabla = obtener_tabla_criptos()
    clases_por_columna = [
        "text-start px-3",  # para #
        "text-start px-3",  # para Nombre
        "text-start px-3",  # para Precio
        "text-end px-3",  # para 1h
        "text-end px-3",  # para 24h
        "text-end px-3",  # para 7d
        "text-end px-3",  # para Cap. Mercado
        "text-end px-3",  # para Volumen
        "text-end px-3",  # para Suministro
    ]
    return render_template(
        "fragmento_tabla.html", tabla=tabla, clases_por_columna=clases_por_columna
    )


==================================================
=== ARCHIVO: ./backend/servicios/estado_billetera.py ===
==================================================

from flask import render_template
from decimal import Decimal
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_historial import cargar_historial
from backend.acceso_datos.datos_cotizaciones import obtener_precio


# En backend/servicios/estado_billetera.py


def calcular_detalle_cripto(ticker, cantidad_actual, precios, historial):
    """
    Calcula el estado financiero de una criptomoneda en base a su cantidad actual, el precio de mercado
    y el historial de compras.
    """
    cantidad_actual = Decimal(str(cantidad_actual))
    precio_actual = precios.get(ticker, Decimal("0")).quantize(Decimal("0.000001"))
    valor_usdt = (cantidad_actual * precio_actual).quantize(Decimal("0.01"))

    # Filtra las operaciones de compra donde el 'ticker' que estamos analizando fue el DESTINO.
    compras = [
        op
        for op in historial
        if op.get("tipo") == "compra" and op.get("destino", {}).get("ticker") == ticker
    ]

    # Usamos .get() para evitar errores si alguna operaciÃ³n antigua no tiene el formato nuevo.
    cantidad_comprada = sum(
        Decimal(str(op.get("destino", {}).get("cantidad", "0"))) for op in compras
    )
    total_invertido = sum(Decimal(str(op.get("valor_usd", "0"))) for op in compras)

    # El resto de la funciÃ³n no necesita cambios...
    division_por_0_segura = lambda num, den: num / den if den != 0 else Decimal("0")

    precio_promedio = (
        division_por_0_segura(total_invertido, cantidad_comprada).quantize(
            Decimal("0.000001")
        )
        if cantidad_comprada
        else Decimal("0")
    )
    invertido_actual = (cantidad_actual * precio_promedio).quantize(Decimal("0.01"))

    ganancia = (valor_usdt - invertido_actual).quantize(Decimal("0.01"))
    porcentaje_ganancia = (
        division_por_0_segura(ganancia, invertido_actual) * Decimal("100")
        if invertido_actual != 0
        else Decimal("0")
    )

    return {
        "ticker": ticker,
        "cantidad": cantidad_actual,
        "valor_usdt": valor_usdt,
        "precio_actual": precio_actual,
        "precio_promedio": precio_promedio,
        "invertido": invertido_actual,
        "ganancia_perdida": ganancia,
        "porcentaje_ganancia": porcentaje_ganancia,
    }


def estado_actual_completo():
    """
    Calcula un resumen financiero completo del portafolio de criptomonedas actual.

    Este resumen incluye, para cada activo con saldo significativo (> 0.000001):
    - Cantidad disponible
    - Valor de mercado en USDT
    - Precio promedio de compra
    - Monto invertido
    - Ganancia/pÃ©rdida neta y en porcentaje
    - Porcentaje de participaciÃ³n en el portafolio total

    Returns:
        List[Dict]: Lista de diccionarios, cada uno representando una criptomoneda con su detalle financiero.
    """

    # Cargar los datos actuales desde archivos locales
    billetera = {k: Decimal(str(v)) for k, v in cargar_billetera().items()}
    if "USDT" in billetera:
        billetera["USDT"] = billetera["USDT"].quantize(Decimal("0.01"))

    # Obtener precios para cada cripto en la billetera
    precios = {
        ticker: obtener_precio(ticker) or Decimal("0") for ticker in billetera.keys()
    }
    historial = cargar_historial()

    billetera_filtrada = billetera

    # Calcular el detalle financiero de cada criptomoneda
    detalles = list(
        map(
            lambda par: calcular_detalle_cripto(par[0], par[1], precios, historial),
            billetera_filtrada.items(),
        )
    )

    # Calcular el valor total en USDT del portafolio
    total_usdt = sum(Decimal(str(d["valor_usdt"])) for d in detalles)

    # FunciÃ³n para calcular el porcentaje que representa cada cripto sobre el total
    calcular_porcentaje = lambda valor_usdt: (
        ((Decimal(str(valor_usdt)) / total_usdt) * Decimal("100")).quantize(
            Decimal("0.01")
        )
        if total_usdt > 0
        else Decimal("0")
    )

    # Asignar el porcentaje correspondiente a cada criptomoneda y los colores
    for detalle_cripto in detalles:
        detalle_cripto["porcentaje"] = calcular_porcentaje(detalle_cripto["valor_usdt"])
        detalle_cripto["color_ganancia"] = (
            "green" if detalle_cripto["ganancia_perdida"] >= 0 else "red"
        )
        detalle_cripto["color_porcentaje"] = (
            "green" if detalle_cripto["porcentaje_ganancia"] >= 0 else "red"
        )
        detalle_cripto["es_polvo"] = detalle_cripto["valor_usdt"] < Decimal("0.001")
        # Truncamiento a 8 decimales eliminado, se mantiene la cantidad tal cual
        detalle_cripto["cantidad"] = detalle_cripto["cantidad"]

    return detalles


==================================================
=== ARCHIVO: ./backend/servicios/trading_logica.py ===
==================================================

from decimal import Decimal, InvalidOperation
from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_historial import guardar_en_historial

# --- FUNCIÃ“N DE PROCESAMIENTO DEL FORMULARIO ---

def procesar_operacion_trading(formulario):
    """
    TRADUCTOR: Recibe el formulario, lo valida y lo convierte en una llamada
    a la lÃ³gica de negocio principal (`realizar_swap`).
    """
    try:
        ticker_principal = formulario["ticker"].upper()
        accion = formulario["accion"]
        monto_form = Decimal(formulario["monto"])
        modo_ingreso = formulario["modo-ingreso"]
    except (KeyError, InvalidOperation, TypeError):
        return False, "âŒ Error en los datos del formulario."

    if monto_form <= 0:
        return False, "âŒ El monto debe ser un nÃºmero positivo."

    # Determina las monedas de la operaciÃ³n basÃ¡ndose en la acciÃ³n
    if accion == "comprar":
        moneda_origen = formulario.get("moneda-pago", "USDT").upper()
        moneda_destino = ticker_principal
    elif accion == "vender":
        moneda_origen = ticker_principal
        moneda_destino = formulario.get("moneda-recibir", "USDT").upper()
    else:
        return False, "âŒ AcciÃ³n no vÃ¡lida."

    if moneda_origen == moneda_destino:
        return False, "âŒ La moneda de origen y destino no pueden ser la misma."

    # Llama a la lÃ³gica principal con los datos ya limpios y preparados
    return realizar_swap(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion)


# --- FUNCIONES AUXILIARES INTERNAS (LÃ“GICA DE NEGOCIO) ---

def _calcular_detalles_swap(accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt):
    """
    Calcula las cantidades de origen, destino y el valor total en USD del swap.
    Esta es una funciÃ³n interna y pura que solo realiza cÃ¡lculos.

    Returns:
        tuple: (True, {'origen': cant, 'destino': cant, 'valor_usd': val}) o (False, "error").
    """
    # ValidaciÃ³n de entrada especÃ­fica para esta lÃ³gica
    if accion == 'vender' and modo_ingreso == 'total':
        return False, "âŒ Al vender, debe ingresar la cantidad en modo 'Monto' (Cripto)."

    if accion not in ['comprar', 'vender']:
        return False, "âŒ AcciÃ³n de trading desconocida."

    # LÃ³gica de cÃ¡lculo
    if accion == 'comprar':
        if modo_ingreso == 'monto':  # Usuario ingresa la cantidad de CRIPTO a recibir
            cantidad_destino = monto_form
            valor_total_usd = cantidad_destino * precio_destino_usdt
            cantidad_origen = valor_total_usd / precio_origen_usdt
        else:  # 'total', usuario ingresa la cantidad de FIAT a gastar
            cantidad_origen = monto_form
            valor_total_usd = cantidad_origen * precio_origen_usdt
            cantidad_destino = valor_total_usd / precio_destino_usdt
    else:  # accion == 'vender'
        cantidad_origen = monto_form
        valor_total_usd = cantidad_origen * precio_origen_usdt
        cantidad_destino = valor_total_usd / precio_destino_usdt

    detalles = {
        "origen": cantidad_origen,
        "destino": cantidad_destino,
        "valor_usd": valor_total_usd
    }
    return True, detalles


def _validar_saldo_suficiente(billetera, moneda_origen, cantidad_requerida):
    """Verifica si hay suficiente saldo en la billetera para la operaciÃ³n."""
    saldo_disponible = billetera.get(moneda_origen, Decimal("0"))
    if cantidad_requerida > saldo_disponible:
        mensaje_error = f"âŒ Saldo insuficiente. Tienes {saldo_disponible:.8f} {moneda_origen}."
        return False, mensaje_error
    return True, None


def _actualizar_billetera_y_guardar(billetera, moneda_origen, cantidad_origen, moneda_destino, cantidad_destino):
    """Resta la moneda de origen, suma la de destino y guarda el estado final."""
    billetera[moneda_origen] -= cantidad_origen
    
    # Si el saldo es muy pequeÃ±o ("polvo"), se elimina la moneda de la billetera
    if billetera[moneda_origen] <= Decimal("1e-8"):
        billetera.pop(moneda_origen, None)

    billetera[moneda_destino] = billetera.get(moneda_destino, Decimal("0")) + cantidad_destino
    
    guardar_billetera(billetera)


def _registrar_operacion_historial(moneda_origen, cantidad_origen, moneda_destino, cantidad_destino, valor_usd):
    """Determina el tipo de operaciÃ³n y la guarda en el historial."""
    if moneda_origen == "USDT":
        tipo_operacion = "compra"
    elif moneda_destino == "USDT":
        tipo_operacion = "venta"
    else:
        tipo_operacion = "intercambio"
        
    guardar_en_historial(
        tipo_operacion,
        moneda_origen,
        cantidad_origen.quantize(Decimal("0.00000001")),
        moneda_destino,
        cantidad_destino.quantize(Decimal("0.00000001")),
        valor_usd,
    )


# --- FUNCIÃ“N ORQUESTADORA PRINCIPAL ---

def realizar_swap(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion):
    """
    Orquesta la operaciÃ³n de swap completa: obtiene precios, calcula, valida y ejecuta.
    """
    # 1. Obtener precios
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)

    if precio_origen_usdt is None or precio_destino_usdt is None or precio_destino_usdt.is_zero():
        return False, "âŒ No se pudo obtener la cotizaciÃ³n para realizar el swap."

    # 2. Calcular los detalles del swap
    exito_calculo, resultado = _calcular_detalles_swap(
        accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt
    )
    if not exito_calculo:
        return False, resultado  # resultado aquÃ­ es el mensaje de error

    cantidad_origen = resultado["origen"]
    cantidad_destino = resultado["destino"]
    valor_total_usd = resultado["valor_usd"]

    # 3. Cargar billetera y validar saldo
    billetera = cargar_billetera()
    exito_validacion, mensaje_error = _validar_saldo_suficiente(billetera, moneda_origen, cantidad_origen)
    if not exito_validacion:
        return False, mensaje_error

    # 4. Ejecutar la operaciÃ³n (si todo es vÃ¡lido hasta ahora)
    _actualizar_billetera_y_guardar(billetera, moneda_origen, cantidad_origen, moneda_destino, cantidad_destino)
    
    # 5. Registrar en el historial
    _registrar_operacion_historial(moneda_origen, cantidad_origen, moneda_destino, cantidad_destino, valor_total_usd)

    # 6. Devolver mensaje de Ã©xito
    mensaje_exito = f"âœ… Swap exitoso: {cantidad_origen:.8f} {moneda_origen} â†’ {cantidad_destino:.8f} {moneda_destino}."
    return True, mensaje_exito

==================================================
=== ARCHIVO: ./backend/servicios/trading_models.py ===
==================================================

# backend/servicios/trading_models.py
from flask import json
from .velas_logica import cargar_datos_cotizaciones
from ..acceso_datos.datos_billetera import cargar_billetera
from ..acceso_datos.datos_historial import cargar_historial
from .api_cotizaciones import obtener_velas_binance


def preparar_vista_trading():
    """
    Orquesta la carga y preparaciÃ³n de todos los datos necesarios para la vista de trading.
    """
    # 1. Carga de datos crudos
    obtener_velas_binance()
    criptos_disponibles = cargar_datos_cotizaciones()
    billetera = cargar_billetera()
    historial_crudo = cargar_historial()

    # 2. Pre-procesamos el historial en Python para aÃ±adir fecha y hora formateadas
    historial_formateado = []
    for item in historial_crudo:
        timestamp_str = item.get("timestamp")
        if timestamp_str and "T" in timestamp_str:
            # Separamos la cadena en fecha y hora
            partes = timestamp_str.split("T")
            fecha = partes[0]
            hora = partes[1].split(".")[0]  # Quitamos los microsegundos

            # AÃ±adimos las nuevas claves al diccionario de la transacciÃ³n
            item["fecha_formateada"] = fecha
            item["hora_formateada"] = hora
        else:
            # Si el timestamp no existe o tiene un formato inesperado
            item["fecha_formateada"] = "Fecha N/A"
            item["hora_formateada"] = ""

        historial_formateado.append(item)

    # 3. TransformaciÃ³n de datos para la vista
    monedas_propias = {
        ticker: saldo for ticker, saldo in billetera.items() if saldo > 0
    }

    lista_todas_criptos_js = [
        {"ticker": c.get("ticker", "").upper(), "nombre": c.get("nombre", "N/A")}
        for c in criptos_disponibles
    ]
    lista_monedas_propias_js = [
        {"ticker": ticker, "nombre": ticker} for ticker in monedas_propias.keys()
    ]

    # 4. Devolvemos el contexto completo, usando el historial ya procesado
    return {
        "criptos": criptos_disponibles,
        "monedas_propias": monedas_propias,
        "historial": historial_formateado,
        "lista_todas_las_criptos_json": json.dumps(lista_todas_criptos_js),
        "lista_monedas_propias_json": json.dumps(lista_monedas_propias_js),
        "billetera_json": json.dumps(billetera)
    }


==================================================
=== ARCHIVO: ./backend/servicios/velas_logica.py ===
==================================================

import json
import os
from decimal import Decimal
from config import COTIZACIONES_PATH, VELAS_PATH


def guardar_datos_cotizaciones(data):
    os.makedirs(os.path.dirname(COTIZACIONES_PATH), exist_ok=True)
    print("ğŸ’¾ Guardando datos en datos_cotizaciones.json...")
    print(f"Cantidad de criptos a guardar: {len(data)}")
    print("ğŸ“ Guardando en:", os.path.abspath(COTIZACIONES_PATH))

    try:
        with open(COTIZACIONES_PATH, "w") as archivo:
            json.dump(
                data,
                archivo,
                indent=4,
                default=lambda o: float(o) if isinstance(o, Decimal) else o,
            )
        print("âœ… Datos guardados correctamente")
    except Exception as e:
        print("âŒ Error al guardar el archivo:", e)


def cargar_datos_cotizaciones():
    if not os.path.exists(COTIZACIONES_PATH):
        return []
    with open(COTIZACIONES_PATH, "r") as archivo:
        return json.load(archivo)


def guardar_datos_velas(data):
    os.makedirs(os.path.dirname(VELAS_PATH), exist_ok=True)
    print("ğŸ’¾ Guardando datos en datos_velas.json...")
    print(f"Cantidad de velas a guardar: {len(data)}")
    print("ğŸ“ Guardando en:", os.path.abspath(VELAS_PATH))

    try:
        with open(VELAS_PATH, "w") as archivo:
            json.dump(
                data,
                archivo,
                indent=4,
                default=lambda o: float(o) if isinstance(o, Decimal) else o,
            )
        print("âœ… Datos guardados correctamente")
    except Exception as e:
        print("âŒ Error al guardar el archivo:", e)


==================================================
=== ARCHIVO: ./backend/swagger.yaml ===
==================================================

openapi: 3.0.0
info:
  title: Simulador de Exchange
  description: API para simular operaciones de compra/venta de criptomonedas.
  version: "1.0.0"
  contact:
    name: Tu Nombre
    email: tunombre@email.com

servers:
  - url: http://localhost:5000
    description: Servidor local

paths:
  /:
    get:
      summary: PÃ¡gina principal
      responses:
        '200':
          description: PÃ¡gina principal renderizada

  /trading:
    get:
      summary: Muestra la interfaz de trading
      responses:
        '200':
          description: PÃ¡gina de trading renderizada
    post:
      summary: Procesa una operaciÃ³n de compra o venta
      requestBody:
        content:
          application/x-www-form-urlencoded:
            schema:
              type: object
              properties:
                tipo:
                  type: string
                  example: "compra"
                ticker:
                  type: string
                  example: "BTC"
                cantidad:
                  type: string
                  example: "0.1"
      responses:
        '302':
          description: Redirecciona con resultado

  /billetera:
    get:
      summary: Vista HTML con el estado de la billetera
      responses:
        '200':
          description: Renderiza billetera.html

  /estado:
    get:
      summary: Devuelve el estado actual de la billetera en JSON
      responses:
        '200':
          description: Datos de billetera

  /api/billetera:
    get:
      summary: Fragmento HTML con detalle financiero
      responses:
        '200':
          description: Fragmento HTML generado

  /api/historial:
    get:
      summary: Fragmento HTML del historial de transacciones
      responses:
        '200':
          description: Historial renderizado

  /actualizar:
    get:
      summary: Actualiza las cotizaciones desde CoinGecko
      responses:
        '200':
          description: Devuelve estado y cantidad

  /datos_tabla:
    get:
      summary: Devuelve fragmento de tabla de cotizaciones
      responses:
        '200':
          description: Tabla HTML renderizada

  /api/velas:
    get:
      summary: Retorna los datos de velas desde archivo local
      responses:
        '200':
          description: JSON de velas
        '500':
          description: Error de lectura

==================================================
=== ARCHIVO: ./backend/utils/formateo_decimales.py ===
==================================================

def formato_valor(valor, decimales=2, umbral=0.0001, simbolo="$"):
    try:
        val = float(valor)
        if 0 < abs(val) < umbral:
            return f"&lt; {simbolo}{umbral:.{decimales}f}"
        return f"{simbolo}{val:.{decimales}f}"
    except (TypeError, ValueError):
        return "-"


def formato_cantidad(valor, decimales=8, umbral=0.00000001):
    try:
        val = float(valor)
        if 0 < abs(val) < umbral:
            return f"&lt; {umbral:.{decimales}f}"
        return f"{val:.{decimales}f}"
    except (TypeError, ValueError):
        return "-"


def registrar_filtros(app):
    app.jinja_env.filters["formato_valor"] = formato_valor
    app.jinja_env.filters["formato_cantidad"] = formato_cantidad


==================================================
=== ARCHIVO: ./config.py ===
==================================================

import os
from decimal import getcontext, ROUND_HALF_DOWN

# Base del proyecto y carpeta de datos
PROYECTO_DIR = os.path.dirname(os.path.abspath(__file__))
BASE_DATA_DIR = os.path.join(PROYECTO_DIR, "datos")
os.makedirs(BASE_DATA_DIR, exist_ok=True)

# Rutas de archivos JSON
COTIZACIONES_PATH = os.path.join(BASE_DATA_DIR, "cotizaciones.json")
BILLETERA_PATH = os.path.join(BASE_DATA_DIR, "billetera.json")
HISTORIAL_PATH = os.path.join(BASE_DATA_DIR, "historial.json")
VELAS_PATH = os.path.join(BASE_DATA_DIR, "velas.json")

# ConfiguraciÃ³n general
BALANCE_INICIAL_USDT = "10000"
FLASK_SECRET_KEY = os.environ.get("FLASK_SECRET_KEY", "clave_por_defecto_insegura")

# URLs de APIs
COINGECKO_URL = "https://api.coingecko.com/api/v3/coins/markets"
BINANCE_URL = "https://api.binance.com/api/v3/klines"

# ParÃ¡metros de scraping
CANTIDAD_CRIPTOMONEDAS = 100
CANTIDAD_VELAS = 250

# Decimal global
getcontext().prec = 28
getcontext().rounding = ROUND_HALF_DOWN


==================================================
=== ARCHIVO: ./documentacion.md ===
==================================================

**TPO_simulador_exchange** es un simulador de exchange de criptomonedas desarrollado en Python y Flask, orientado a prÃ¡cticas acadÃ©micas. Permite consultar cotizaciones en tiempo real, realizar operaciones de compra/venta simuladas y visualizar el estado de la billetera del usuario.

---

## ğŸ“¦ InstalaciÃ³n

1. Clonar el repositorio:

```bash
git clone https://github.com/FaustoLovera/Trabajo_Simulador_Exchange.git
cd TPO_simulador_exchange
```

2. Crear entorno virtual:

```bash
python3 -m venv .venv
source .venv/bin/activate  # en Windows: .venv\Scripts\activate
```

3. Instalar dependencias:

```bash
pip install -r requirements.txt
```

4. Ejecutar la aplicaciÃ³n:

```bash
python -m backend.app
```

---

## ğŸ—‚ï¸ Estructura principal del backend

```
backend/
â”œâ”€â”€ app.py                  # Punto de entrada principal de la app
â”œâ”€â”€ __init__.py             # ConfiguraciÃ³n de Flask, Swagger y registros
â”œâ”€â”€ rutas/                  # Blueprints y vistas del sistema
â”‚   â”œâ”€â”€ __init__.py         # InicializaciÃ³n de blueprints
â”‚   â”œâ”€â”€ home.py             # Ruta principal
â”‚   â”œâ”€â”€ trading_vista.py    # Interfaz de compra/venta
â”‚   â”œâ”€â”€ billetera_vista.py  # Vista para la billetera
â”‚   â””â”€â”€ api_externa.py      # Rutas para datos externos
â”œâ”€â”€ servicios/              # LÃ³gica de negocio: consultas API, cÃ¡lculo, etc.
â”‚   â”œâ”€â”€ api_cotizaciones.py # Consulta cotizaciones a CoinGecko
â”‚   â”œâ”€â”€ trading_logica.py   # LÃ³gica principal de operaciones de trading
â”‚   â”œâ”€â”€ velas_logica.py     # Consulta y guarda datos de velas de Binance
â”‚   â”œâ”€â”€ cotizaciones.py     # Procesa y ordena cotizaciones
â”‚   â””â”€â”€ estado_billetera.py # CÃ¡lculo de estadÃ­sticas y visualizaciÃ³n de billetera
â”œâ”€â”€ acceso_datos/           # Lectura y escritura de archivos JSON
â”‚   â”œâ”€â”€ datos_billetera.py
â”‚   â”œâ”€â”€ datos_historial.py
â”‚   â””â”€â”€ datos_cotizaciones.py
frontend/
â”œâ”€â”€ templates/              # Plantillas HTML (Jinja2)
â”œâ”€â”€ static/                 # CSS, JS e imÃ¡genes estÃ¡ticas
```

---

## ğŸš€ Funcionalidad bÃ¡sica

1. **Ver cotizaciones**: Se consultan desde la API de CoinGecko.
2. **Operar**: Se simula la compra o venta de criptomonedas.
3. **Billetera**: Se visualiza el balance actual y el historial de operaciones.

---

## ğŸ”§ ConfiguraciÃ³n

El archivo `config.py` centraliza:

- Las rutas a archivos JSON (`datos/`)
- Clave secreta de Flask
- URLs de APIs externas (CoinGecko y Binance)
- ParÃ¡metros de scraping
- ConfiguraciÃ³n global de `Decimal`

---

## ğŸ“Œ Notas

- El proyecto estÃ¡ diseÃ±ado para ejecutarse en **entorno local**.
- A futuro se planea incorporar tests automÃ¡ticos.
- La documentaciÃ³n Swagger estÃ¡ disponible en `http://localhost:5000/apidocs`.

---

# ğŸ§© DescripciÃ³n de mÃ³dulos clave

### `backend/app.py`

Punto de entrada principal de la aplicaciÃ³n.

- Crea la instancia Flask mediante `crear_app()` (importado desde `__init__.py`).
- Configura Swagger para la documentaciÃ³n interactiva.
- Ejecuta el servidor solo si el archivo se ejecuta directamente (bloque `if __name__ == "__main__"`).

---

### `backend/__init__.py`

- Define la funciÃ³n `crear_app()` que:
  - Crea la app Flask.
  - Registra los blueprints desde `backend.rutas`.
  - Configura la clave secreta desde `config.py`.

---

### `backend/rutas/home.py`

- Define un blueprint `bp` que maneja la ruta principal (`/`).
- Puede incluir lÃ³gicas complementarias al `index`.

---

### `backend/rutas/trading_vista.py`

- Define un blueprint `bp` para las rutas de compra y venta.
- Utiliza lÃ³gica de `trading_logica.py` y lectura de archivos desde `acceso_datos/`.
- Encargado de procesar operaciones y mostrar la billetera.

---

### `backend/servicios/api_cotizaciones.py`

- Contiene funciones para obtener cotizaciones de criptomonedas desde la API de CoinGecko.
- Incluye funciones auxiliares para ordenar o filtrar datos antes de usarlos en la app.

---

### `backend/servicios/trading_logica.py`

- LÃ³gica principal de las operaciones de trading:
  - CÃ¡lculo de compra/venta.
  - VerificaciÃ³n de saldos.
  - CÃ¡lculo de precio promedio y ganancias/perdidas.

---

### `backend/servicios/velas_logica.py`

- Obtiene y guarda datos de velas (candlestick) desde la API de Binance.
- Sirve como base para anÃ¡lisis tÃ©cnico o visualizaciÃ³n de grÃ¡ficos (a futuro).

---

### `backend/acceso_datos/datos_billetera.py`

- Lectura y escritura de la billetera en `datos/billetera.json`.
- Gestiona saldos de criptomonedas y USDT.

---

### `backend/acceso_datos/datos_historial.py`

- Maneja el historial de operaciones guardado en `datos/historial.json`.
- Permite consultar o registrar movimientos.

---

### `config.py`

- Define rutas absolutas a los archivos del sistema (`cotizaciones.json`, `billetera.json`, etc.).
- Contiene claves, parÃ¡metros, URLs de API y configuraciÃ³n global de decimales.

---

### `backend/rutas/billetera_vista.py`

- Muestra y actualiza visualmente el estado de la billetera.
- Utiliza fragmentos HTML renderizados desde el backend.

---

### `backend/rutas/api_externa.py`

- Expone rutas de la API que devuelven datos en formato JSON (probablemente para frontend dinÃ¡mico o AJAX).

---

### `backend/servicios/cotizaciones.py`

- Procesamiento y filtrado adicional de cotizaciones antes de ser mostradas.

---

### `backend/servicios/estado_billetera.py`

- CÃ¡lculo de estadÃ­sticas y visualizaciÃ³n del estado general de la billetera.

---

### `backend/utils/formateo_decimales.py`

- Centraliza el formateo consistente de decimales para mostrar precios y saldos en la interfaz.

---

### `backend/swagger.yaml`

- Archivo de definiciÃ³n OpenAPI (YAML) para Swagger. Describe rutas, parÃ¡metros y respuestas esperadas.


---

# Inicio Proyecto

## app.py

## ExplicaciÃ³n paso a paso de `app.py`

Este archivo es el punto de entrada del proyecto. Se encarga de crear la app de Flask, activar Swagger para documentaciÃ³n y definir una ruta principal.

---

### 1. Importaciones

```python
from flask import render_template
```
Importa la funciÃ³n `render_template` que permite mostrar archivos HTML en el navegador.

```python
from backend.servicios.api_cotizaciones import obtener_datos_criptos_coingecko
```
Importa una funciÃ³n que consulta precios de criptomonedas desde CoinGecko.

```python
from . import crear_app
```
Importa la funciÃ³n `crear_app()` que configura y devuelve la app Flask. EstÃ¡ definida en `__init__.py`.

```python
from flasgger import Swagger
```
Importa `Swagger`, una herramienta que genera documentaciÃ³n interactiva para la API.

---

### 2. CreaciÃ³n de la app y Swagger

```python
app = crear_app()
```
Llama a `crear_app()` y devuelve una instancia de Flask ya configurada.

```python
swagger = Swagger(app)
```
Activa Swagger sobre la app. La documentaciÃ³n estarÃ¡ disponible en `http://localhost:5000/apidocs`.

---

> Nota: anteriormente esta ruta estaba definida directamente en `app.py`, pero ahora forma parte del blueprint `home` definido en `rutas/home.py`.


### 4. Arranque del servidor

```python
if __name__ == "__main__":
    app.run(debug=True)
```

Este bloque significa: "si este archivo se ejecuta directamente, levantÃ¡ el servidor Flask en modo debug".

---

### 5. Â¿Por quÃ© se separan `app.py` y `__init__.py`?

Esta separaciÃ³n sigue el patrÃ³n recomendado por Flask conocido como *Application Factory Pattern*.

#### Ventajas:

- **Modularidad**: `__init__.py` se encarga de crear y configurar la app. `app.py` solo la ejecuta.
- **ReutilizaciÃ³n**: PodÃ©s importar `crear_app()` en otros contextos (por ejemplo, para testing) sin lanzar el servidor.
- **Escalabilidad**: Permite crear mÃºltiples instancias de la aplicaciÃ³n con diferentes configuraciones si fuera necesario.
- **SeparaciÃ³n de responsabilidades**: `__init__.py` configura la app, `app.py` se encarga del arranque.

#### Resumen:

| Archivo        | Rol                                                       |
|----------------|------------------------------------------------------------|
| `__init__.py`  | Configura y devuelve la instancia de Flask (`crear_app`)   |
| `app.py`       | Ejecuta la aplicaciÃ³n (`app.run(debug=True)`)              |

---

## ExplicaciÃ³n paso a paso de `__init__.py`

Este archivo contiene la funciÃ³n `crear_app()`, que se encarga de crear y configurar la instancia de Flask. Esta funciÃ³n devuelve una aplicaciÃ³n completamente configurada y lista para ser ejecutada por `app.py`.

---

### 1. Importaciones

```python
from flask import Flask
from config import FLASK_SECRET_KEY
from backend.utils.formateo_decimales import registrar_filtros
from backend.rutas import registrar_rutas
```

Estas lÃ­neas importan:

- `Flask`: clase principal para crear una app Flask.
- `FLASK_SECRET_KEY`: clave secreta usada para sesiones y seguridad, definida en `config.py`.
- `registrar_filtros`: funciÃ³n auxiliar que registra filtros personalizados para templates.
- `registrar_rutas`: funciÃ³n que registra todas las rutas del sistema (blueprints).

---

### 2. CreaciÃ³n de la app Flask

```python
app = Flask(
    __name__,
    static_folder="../frontend/static",
    template_folder="../frontend/templates",
)
```

Se crea una instancia de Flask, indicando:

- `__name__`: ayuda a Flask a saber dÃ³nde estÃ¡n los archivos.
- `static_folder`: ruta a los archivos CSS, JS e imÃ¡genes.
- `template_folder`: ruta a los archivos HTML (Jinja2).

---

### 3. ConfiguraciÃ³n de clave secreta

```python
app.secret_key = FLASK_SECRET_KEY
```

Configura la clave secreta que permite usar sesiones y mostrar mensajes "flash" en Flask.

---

### 4. Registro de componentes

```python
registrar_filtros(app)
registrar_rutas(app)
```

- `registrar_filtros`: agrega filtros personalizados de formateo de decimales que luego se pueden usar en templates HTML.
- `registrar_rutas`: importa y registra todas las rutas del sistema (por ejemplo, `/`, `/billetera`, `/trading`).

---

### 5. Devolver la app

```python
return app
```

Una vez configurada, se devuelve la instancia `app` para que pueda ser utilizada por `app.py`.

==================================================
=== ARCHIVO: ./frontend/static/css/styles_index.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030;
    color: #f0c000;
}

.logo-cripto {
    margin-right: 1.5rem;
    vertical-align: middle;
}

.nombre-cripto {
    padding-left: 0.75rem;
    font-weight: bold;
    font-size: 1.05rem;
}

.logo-cripto {
    margin-right: 10px;
    vertical-align: middle;
}

.ticker-cripto {
    color: #aaaaaa;
    font-size: 0.85rem;
    margin-left: 4px;
}

table thead th {
    font-size: 0.85rem;
    font-weight: 500;
    text-transform: uppercase;
}

td,
th {
    white-space: nowrap;
}

/* PRECIO */
table td:nth-child(3),
table th:nth-child(3) {
    min-width: 100px;
    font-weight: bold;
}
table td:nth-child(4),
table th:nth-child(4),
table td:nth-child(5),
table th:nth-child(5),
table td:nth-child(6),
table th:nth-child(6) {
    min-width: 80px; /* 1H, 24H, 7D */
}
table td:nth-child(8),
table th:nth-child(8),
table td:nth-child(9),
table th:nth-child(9) {
    min-width: 100px; /* VOLUME, SUPPLY */
}

/* Limita el ancho de la columna Name (columna 2) */
table td:nth-child(2),
table th:nth-child(2) {
    max-width: 220px; /* probÃ¡ ajustar este valor */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.positivo {
    color: var(--color-verde);
    font-weight: 500;
}

.negativo {
    color: var(--color-rojo);
    font-weight: 500;
}

.flecha-verde,
.flecha-roja {
    font-size: 0.7em; /* mÃ¡s pequeÃ±o que el texto base */
    vertical-align: middle;
    margin-right: 4px;
}

.flecha-verde {
    color: var(--color-verde);
    margin-right: 4px;
}

.flecha-roja {
    color: var(--color-rojo);
    margin-right: 4px;
}


==================================================
=== ARCHIVO: ./frontend/static/css/styles_trading.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
    /* --bs-dark-rgb: 30, 30, 30 !important;
    --bs-body-bg: 44, 44, 44 !important;
    --bs-border-width: 1px solid rgb(219, 71, 71) !important; */
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030 !important;
    color: #f0c000;
}

#chart {
    display: block;
    overflow: hidden;
    width: 100%;
    max-width: 100%;
}

.text-verde {
    color: var(--color-verde);
}

.text-rojo {
    color: var(--color-rojo);
}

/* FORMULARIO TRADING */

.form-control {
    background-color: 44, 44, 44 !important;
}

/* CAMBIO DE COLOR DEL PUNTO DEL SLIDER THUMB DINÃMICO */

/* Chrome/Safari */
input[type='range'].slider-compra::-webkit-slider-thumb {
    background-color: rgb(31, 191, 113) !important; /* verde */
}

input[type='range'].slider-venta::-webkit-slider-thumb {
    background-color: rgb(226, 33, 52) !important; /* rojo */
}

/* Firefox */
input[type='range'].slider-compra::-moz-range-thumb {
    background-color: rgb(31, 191, 113) !important;
}

input[type='range'].slider-venta::-moz-range-thumb {
    background-color: rgb(226, 33, 52) !important;
}


==================================================
=== ARCHIVO: ./frontend/static/js/cotizacionesApiService.js ===
==================================================

// Este mÃ³dulo se encarga de toda la comunicaciÃ³n con la API del backend.

/**
 * Obtiene el fragmento HTML de la tabla de cotizaciones.
 * @returns {Promise<string>} El HTML de la tabla.
 */
export async function fetchTablaCotizacionesHTML() {
    try {
        const response = await fetch('/api/datos_tabla');
        if (!response.ok) {
            throw new Error(`Error en la respuesta del servidor: ${response.statusText}`);
        }
        return await response.text();
    } catch (error) {
        console.error('âŒ Error al obtener el HTML de la tabla:', error);
        return '<tr><td colspan="9" class="text-center text-danger">No se pudieron cargar los datos.</td></tr>';
    }
}

/**
 * Llama al endpoint que actualiza los datos de cotizaciones en el backend.
 * @returns {Promise<object>} El resultado de la actualizaciÃ³n.
 */
export async function triggerActualizacionDatos() {
    try {
        const response = await fetch('/api/actualizar');
        if (!response.ok) {
            throw new Error(`Error en la respuesta del servidor: ${response.statusText}`);
        }
        return await response.json();
    } catch (error) {
        console.error('âŒ Error al solicitar la actualizaciÃ³n de datos:', error);
        return { estado: 'error', mensaje: error.message };
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/domElements.js ===
==================================================

// Centraliza todos los selectores del DOM en un Ãºnico objeto para fÃ¡cil acceso y mantenimiento.
export const DOMElements = {
    form: $('#formulario-trading'),
    selectorPrincipal: $('#cripto'),
    selectorPagarCon: $('#moneda-pago'),
    selectorRecibirEn: $('#moneda-recibir'),
    botonComprar: $('.boton-comprar'),
    botonVender: $('.boton-vender'),
    botonConfirmar: $('.boton-confirmar'),
    inputAccion: $('#accion'),
    campoPagarCon: $('#campo-pagar-con'),
    campoRecibirEn: $('#campo-recibir-en'),
    spanSaldoDisponible: $('#saldo-disponible'),
    radioModoIngreso: $('input[name="modo-ingreso"]'),
    labelMonto: $('label[for="monto"]'),
    inputMonto: $('#monto'),
    sliderMonto: $('#slider-monto'),
};

==================================================
=== ARCHIVO: ./frontend/static/js/formLogic.js ===
==================================================

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';

// Contiene la lÃ³gica de negocio del formulario, como poblar selectores y cÃ¡lculos.
export const FormLogic = {
    popularSelector(selector, lista, valorPorDefecto) {
        selector.empty();
        lista.forEach(({ nombre, ticker }) => selector.append(new Option(nombre, ticker)));
        const valorFinal = (valorPorDefecto && lista.some(m => m.ticker === valorPorDefecto)) ? valorPorDefecto : (lista.length > 0 ? lista[0].ticker : null);
        if (valorFinal) {
            selector.val(valorFinal).trigger('change');
        }
        return valorFinal;
    },

    calcularMontoSlider() {
        const porcentaje = parseFloat(DOMElements.sliderMonto.val());
        const esCompra = UIState.esModoCompra();
        
        const tickerDeSaldo = esCompra ? UIState.getTickerPago() : UIState.getTickerPrincipal();
        const saldoDisponible = parseFloat(window.billetera[tickerDeSaldo] || '0');
        
        if (!tickerDeSaldo) return 0;

        return (saldoDisponible * porcentaje) / 100.0;
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/indexPage.js ===
==================================================

// Este es el punto de entrada para la pÃ¡gina de cotizaciones (index.html).
import { triggerActualizacionDatos } from './cotizacionesApiService.js';
import { renderTabla } from './tablaCotizacionesUI.js';

const UPDATE_INTERVAL_MS = 15000; // 15 segundos

/**
 * Configura la actualizaciÃ³n automÃ¡tica de la tabla de cotizaciones.
 */
function inicializarActualizadorAutomatico() {
    setInterval(async () => {
        console.log("â³ Solicitando actualizaciÃ³n de datos...");
        await triggerActualizacionDatos();
        await renderTabla();
    }, UPDATE_INTERVAL_MS);
}

/**
 * FunciÃ³n principal que se ejecuta al cargar la pÃ¡gina.
 */
function main() {
    // Asegurarse de que estamos en la pÃ¡gina correcta verificando la existencia de la tabla.
    if (document.getElementById('tabla-datos')) {
        console.log("ğŸš€ Inicializando pÃ¡gina de cotizaciones.");
        
        // Carga inicial de la tabla
        renderTabla();
        
        // Inicia el ciclo de actualizaciÃ³n automÃ¡tica
        inicializarActualizadorAutomatico();
    }
}

// Ejecutar la funciÃ³n principal
main();

==================================================
=== ARCHIVO: ./frontend/static/js/renderizarGraficoVelas.js ===
==================================================

console.log('ğŸŸ¢ Script grafico_velas.js cargado');

document.addEventListener('DOMContentLoaded', function () {
    const chartContainer = document.getElementById('chart');

    const chart = window.LightweightCharts.createChart(chartContainer, {
        width: chartContainer.clientWidth,
        height: 500,

        layout: {
            textColor: '#0f0f0f', // negro
        },
        grid: {
            vertLines: { color: '#444' },
            horLines: { color: '#444' },
        },
        priceScale: {
            borderColor: '#ffffff',
            ticksVisible: true,
            scaleMargins: {
                top: 0.1,
                bottom: 0.2,
                right: 0.5
            },
        },
        timeScale: {
            borderColor: '#ffffff',
            timeVisible: true,
            secondsVisible: false,
            ticksVisible: true,
        },
        crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
        },
    });

    const candleSeries = chart.addCandlestickSeries();
    candleSeries.priceScale().applyOptions({
        scaleMargins: {
            top: 0.1,
            bottom: 0.1,
        },
    });

    fetch('/api/velas')
        .then((response) => response.json())
        .then((data) => {
            if (data.error) {
                console.error('Error del backend:', data.error);
                return;
            }

            const parsedData = data.map((item) => ({
                time: item.time,
                open: Number(item.open),
                high: Number(item.high),
                low: Number(item.low),
                close: Number(item.close),
                volume: Number(item.volume),
            }));

            console.log('Datos recibidos para el grÃ¡fico:', parsedData);

            parsedData.forEach((vela, i) => {
                console.log(`Vela ${i + 1}:`, vela);
            });

            candleSeries.setData(parsedData);

            const volumeSeries = chart.addHistogramSeries({
                priceFormat: {
                    type: 'volume',
                },
                priceScaleId: '',
            });
            volumeSeries.priceScale().applyOptions({
                scaleMargins: {
                    top: 0.8,
                    bottom: 0,
                },
            });

            const volumeData = parsedData.map((vela) => ({
                time: vela.time,
                value: vela.volume,
                color: vela.close > vela.open ? '#26a69a' : '#ef5350',
            }));

            volumeSeries.setData(volumeData);

            // Agregar evento para mostrar/ocultar el volumen
            const volumeCheckbox = document.getElementById('toggleVolume');
            if (volumeCheckbox) {
                volumeCheckbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        volumeSeries.setData(volumeData);
                    } else {
                        volumeSeries.setData([]);
                    }
                });
            }

            chart.timeScale().fitContent();
        })
        .catch((error) => {
            console.error('Error al obtener datos:', error);
        });

    new ResizeObserver(() => {
        chart.applyOptions({ width: chartContainer.clientWidth });
    }).observe(chartContainer);
});


==================================================
=== ARCHIVO: ./frontend/static/js/tablaCotizacionesUI.js ===
==================================================

// Este mÃ³dulo se encarga de manipular el DOM para la tabla de cotizaciones.
import { fetchTablaCotizacionesHTML } from './cotizacionesApiService.js';

const cuerpoTabla = document.getElementById('tabla-datos');

/**
 * Obtiene el HTML de la tabla desde la API y lo renderiza en el DOM.
 */
export async function renderTabla() {
    if (!cuerpoTabla) {
        console.warn("Elemento 'tabla-datos' no encontrado. No se puede renderizar la tabla.");
        return;
    }
    
    console.log("ğŸ”„ Cargando datos de la tabla...");
    const html = await fetchTablaCotizacionesHTML();
    cuerpoTabla.innerHTML = html;
    console.log("âœ… Tabla de cotizaciones renderizada.");
}

==================================================
=== ARCHIVO: ./frontend/static/js/tradingPage.js ===
==================================================

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';
import { UIUpdater } from './uiUpdater.js';
import { FormLogic } from './formLogic.js';

// Este es el punto de entrada principal. Orquesta todos los mÃ³dulos.
document.addEventListener('DOMContentLoaded', () => {
    
    // --- LÃ“GICA DE CONTROL DE ALTO NIVEL ---
    function cambiarModo(modo) {
        DOMElements.inputAccion.val(modo);
        
        UIUpdater.actualizarBotones();
        UIUpdater.actualizarVisibilidadCampos();
        
        let tickerParaSaldo = '';
        if (UIState.esModoCompra()) {
            const criptosSinUSDT = window.todasLasCriptos.filter(c => c.ticker !== 'USDT');
            FormLogic.popularSelector(DOMElements.selectorPrincipal, criptosSinUSDT, 'BTC');
            tickerParaSaldo = UIState.getTickerPago();
        } else {
            const tickerPorDefecto = window.monedasPropias.length > 0 ? window.monedasPropias[0].ticker : null;
            tickerParaSaldo = FormLogic.popularSelector(DOMElements.selectorPrincipal, window.monedasPropias, tickerPorDefecto);
        }
        
        UIUpdater.mostrarSaldo(tickerParaSaldo);
        UIUpdater.actualizarLabelMonto();
        UIUpdater.resetSlider();
    }

    // --- CONFIGURACIÃ“N DE EVENT LISTENERS ---
    function setupEventListeners() {
        DOMElements.botonComprar.on('click', () => cambiarModo('comprar'));
        DOMElements.botonVender.on('click', () => cambiarModo('vender'));

        DOMElements.selectorPrincipal.on('change', () => {
            UIUpdater.actualizarLabelMonto();
            if (!UIState.esModoCompra()) {
                UIUpdater.mostrarSaldo(UIState.getTickerPrincipal());
            }
        });

        DOMElements.selectorPagarCon.on('change', () => {
            UIUpdater.actualizarLabelMonto();
            if (UIState.esModoCompra()) {
                UIUpdater.mostrarSaldo(UIState.getTickerPago());
            }
        });
        
        DOMElements.selectorRecibirEn.on('change', UIUpdater.actualizarLabelMonto);
        DOMElements.radioModoIngreso.on('change', UIUpdater.actualizarLabelMonto);

        DOMElements.sliderMonto.on('input', () => {
            const valorCalculado = FormLogic.calcularMontoSlider();
            UIUpdater.setInputMonto(valorCalculado.toFixed(8));
        });
    }

    // --- INICIALIZACIÃ“N ---
    function initialize() {
        // Inicializar Select2 en todos los selectores
        [DOMElements.selectorPrincipal, DOMElements.selectorPagarCon, DOMElements.selectorRecibirEn].forEach(sel => {
            sel.select2({ width: '100%', dropdownCssClass: 'text-dark' });
        });
        
        // Poblar selectores secundarios una sola vez
        FormLogic.popularSelector(DOMElements.selectorPagarCon, window.monedasPropias, 'USDT');
        FormLogic.popularSelector(DOMElements.selectorRecibirEn, window.todasLasCriptos, 'USDT');
        
        setupEventListeners();
        
        // Iniciar en modo compra por defecto
        cambiarModo('comprar');
    }

    initialize();
});

==================================================
=== ARCHIVO: ./frontend/static/js/uiState.js ===
==================================================

import { DOMElements } from './domElements.js';

// Mantiene y provee el estado actual de la UI, desacoplando la lÃ³gica de la lectura directa del DOM.
export const UIState = {
    esModoCompra() {
        return DOMElements.inputAccion.val() === 'comprar';
    },
    getModoIngreso() {
        return DOMElements.radioModoIngreso.filter(':checked').val();
    },
    getTickerPrincipal() {
        return DOMElements.selectorPrincipal.val();
    },
    getTickerPago() {
        return DOMElements.selectorPagarCon.val();
    },
    getTickerRecibo() {
        return DOMElements.selectorRecibirEn.val();
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/uiUpdater.js ===
==================================================

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';

// Contiene todas las funciones que modifican visualmente el DOM.
export const UIUpdater = {
    actualizarBotones() {
        const esCompra = UIState.esModoCompra();
        DOMElements.botonConfirmar.text(esCompra ? 'COMPRAR' : 'VENDER').toggleClass('btn-success', esCompra).toggleClass('btn-danger', !esCompra);
        DOMElements.botonComprar.toggleClass('active btn-success', esCompra).toggleClass('btn-outline-secondary', !esCompra);
        DOMElements.botonVender.toggleClass('active btn-danger', !esCompra).toggleClass('btn-outline-secondary', esCompra);
    },

    actualizarVisibilidadCampos() {
        const esCompra = UIState.esModoCompra();
        DOMElements.campoPagarCon.toggle(esCompra);
        DOMElements.campoRecibirEn.toggle(!esCompra);
        DOMElements.selectorPagarCon.prop('disabled', !esCompra);
        DOMElements.selectorRecibirEn.prop('disabled', esCompra);
    },

    actualizarLabelMonto() {
        const esModoMonto = UIState.getModoIngreso() === 'monto';
        const esCompra = UIState.esModoCompra();
        let tickerRelevante = '';

        if (esCompra) {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerPago();
        } else {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerRecibo();
        }
        
        const etiqueta = esModoMonto ? 'Monto' : 'Total';
        DOMElements.labelMonto.text(`${etiqueta} (${tickerRelevante || '...'})`);
    },

    mostrarSaldo(ticker) {
        if (!ticker) {
            DOMElements.spanSaldoDisponible.text('--');
            return;
        }
        // Asume que 'billetera' es una variable global disponible (desde el HTML)
        const saldo = window.billetera[ticker] || '0.00';
        const saldoFormateado = parseFloat(saldo).toFixed(8);
        DOMElements.spanSaldoDisponible.text(`${saldoFormateado} ${ticker}`);
    },

    setInputMonto(valor) {
        DOMElements.inputMonto.val(valor);
    },

    resetSlider() {
        DOMElements.sliderMonto.val(0);
    }
};

==================================================
=== ARCHIVO: ./frontend/templates/billetera.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Billetera</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="bg-dark text-white">
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <main class="container my-4">
        <div class="text-center">
            <h2 class="text-warning mb-4">Billetera</h2>
        </div>

        <div class="table-responsive mt-4">
            <table class="table table-dark table-bordered align-middle text-center">
                <thead class="table-secondary">
                    <tr class="table-dark">
                        <th>Nombre</th>
                        <th>Cantidad</th>
                        <th>Precio Actual</th>
                        <th>Valor USD</th>
                        <th>G&P (USD)</th>
                        <th>G&P (%)</th>
                        <th>% Billetera</th>
                    </tr>
                </thead>
                <tbody id="tabla-billetera">
                    {% include "fragmento_billetera.html" %}
                </tbody>
            </table>
        </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/fragmento_billetera.html ===
==================================================

{% for cripto in datos %}
<tr>
    <td class="text-center">
        {{ cripto.ticker }}
        {% if cripto.es_polvo %}
            <span class="text-muted" style="font-size: 0.8em;">(polvo)</span>
        {% endif %}
    </td>
    <td class="text-center">
        {% if cripto.ticker != 'USDT' %}
            {{ cripto.cantidad | formato_cantidad }}
        {% else %}
            {{ cripto.cantidad | formato_valor(2, 0.01, '') }}
        {% endif %}
    </td>
    <td class="text-center">{{ cripto.precio_actual | formato_valor(6, 0.000001, '') }}</td>
    <td class="text-center">{{ cripto.valor_usdt | formato_valor }}</td>
    <td class="text-center" style="color: {{ cripto.color_ganancia }};">
        {{ cripto.ganancia_perdida | formato_valor }}
    </td>
    <td class="text-center" style="color: {{ cripto.color_porcentaje }};">
        {{ cripto.porcentaje_ganancia | formato_valor(2, 0.0001, '') }}%
    </td>
    <td class="text-center">{{ cripto.porcentaje | formato_valor(2, 0.01, '') }}%</td>
</tr>
{% endfor %}

==================================================
=== ARCHIVO: ./frontend/templates/fragmento_historial.html ===
==================================================

{% for item in historial %}
    <tr>
        <!-- Columna 1: Fecha y Hora -->
        <td class="text-start ps-3">
            {{ item.fecha_formateada }} <span class="text-white-50" style="padding-left: 1em">{{ item.hora_formateada }}</span>
        </td>

        <!-- Columna 2: Par de Trading -->
        <td class="fw-bold">
            {% if item.tipo == 'compra' %}
                {{ item.destino.ticker }}/{{ item.origen.ticker }}
            {% else %}
                {{ item.origen.ticker }}/{{ item.destino.ticker }}
            {% endif %}
        </td>
        
        <!-- Columna 3: Tipo -->
        <td class="{% if item.tipo == 'compra' %}text-success{% elif item.tipo == 'venta' %}text-danger{% else %}text-warning{% endif %}">
            {{ item.tipo|capitalize }}
        </td>

        <!-- Columna 4: Cantidad (de la moneda principal del par) -->
        <td>
            {% if item.tipo == 'compra' %}
                {{ item.destino.cantidad | formato_cantidad }} {{ item.destino.ticker }}
            {% else %}
                {{ item.origen.cantidad | formato_cantidad }} {{ item.origen.ticker }}
            {% endif %}
        </td>
        
        <!-- Columna 5: Valor Total -->
        <td>{{ item.valor_usd | formato_valor }}</td>
    </tr>
{% endfor %}

==================================================
=== ARCHIVO: ./frontend/templates/fragmento_tabla.html ===
==================================================

{% for fila in tabla %}
<tr>
    {% for valor in fila %}
        <td class="{{ clases_por_columna[loop.index0] if clases_por_columna is defined else '' }} py-3">{{ valor|safe }}</td>
    {% endfor %}
</tr>
{% endfor %}

==================================================
=== ARCHIVO: ./frontend/templates/index.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BlocX</title>
	<link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
	<link rel="stylesheet" href="{{ url_for('static', filename='css/styles_index.css') }}">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
</head>

<body class="bg-dark text-white">


	<nav class="navbar navbar-expand-lg bg-black shadow">
		<div class="container-fluid">
			<a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
				<img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
				<span>BlocX</span>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
				<span class="navbar-toggler-icon bg-light"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarNav">
				<ul class="navbar-nav ms-auto">
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Contenedor principal -->
	<main class="container-fluid mt-4">
		<div class="row">
			<div class="col-12">
				<div class="p-2 shadow text-center">
					<h3 class="text-warning">Cotizaciones</h3>
					<table class="table table-dark table-striped mt-4">
						<thead>
							<tr>
								<th class="text-start px-3">#</th>
								<th class="text-start px-3">Nombre</th>
								<th class="text-start px-3">Precio</th>
								<th class="text-end px-3">1h</th>
								<th class="text-end px-3">24h</th>
								<th class="text-end px-3">7d</th>
								<th class="text-end px-3">Cap. Mercado</th>
								<th class="text-end px-3">Volumen</th>
								<th class="text-end px-3">Suministro</th>
							</tr>
						</thead>
						<tbody id="tabla-datos" class="align-middle">
							<!-- AquÃ­ se insertarÃ¡n las filas con JS -->
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</main>

</body>



<script type="module" src="{{ url_for('static', filename='js/indexPage.js') }}"></script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"
	integrity="sha384-k6d4wzSIapyDyv1kpU366/PK5hCdSbCRGRCMv+eplOQJWyd1fbcAu9OCUj5zNLiq"
	crossorigin="anonymous"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/trading.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Trading</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
</head>

<body class="bg-dark text-white">

    <!-- ========== BARRA DE NAVEGACIÃ“N ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- ========== CONTENIDO PRINCIPAL ========== -->
    <div class="container mt-5">
        <div class="row">
            <!-- ===== SECCIÃ“N GRÃFICO ===== -->
            <div class="col-md-7">
                <h3 class="text-light">GrÃ¡fico velas</h3>
                <div class="form-check form-switch mb-2">
                    <input class="form-check-input" type="checkbox" id="toggleVolume" checked>
                    <label class="form-check-label text-light" for="toggleVolume">Mostrar volumen</label>
                </div>
                <div class="py-3">
                    <div id="chart"></div>
                </div>
            </div>

            <!-- ===== SECCIÃ“N FORMULARIO DE TRADING ===== -->
            <form class="col-md-5 p-3" id="formulario-trading" method="POST"
                action="{{ url_for('trading.procesar_trading_form') }}">
                <h2 class="text-warning">Trading</h2>

                <!-- Fila para los selectores de moneda -->
                <div class="row g-2 mb-3">
                    <!-- Columna Izquierda: Criptomoneda Principal -->
                    <div class="col-6">
                        <label for="cripto" class="form-label">Criptomoneda</label>
                        <select class="form-select" id="cripto" name="ticker" required></select>
                    </div>

                    <!-- Columna Derecha: Moneda de Pago o Recibo -->
                    <div class="col-6">
                        <!-- Campo para "Pagar con" (visible en modo compra) -->
                        <div id="campo-pagar-con" style="display: none;">
                            <label for="moneda-pago" class="form-label">Pagar con</label>
                            <select class="form-select" id="moneda-pago" name="moneda-pago">
                                <!-- Las opciones se poblarÃ¡n dinÃ¡micamente con JS -->
                            </select>
                        </div>

                        <!-- Campo para "Recibir en" (visible en modo venta) -->
                        <div id="campo-recibir-en" style="display: none;">
                            <label for="moneda-recibir" class="form-label">Recibir en</label>
                            <select class="form-select" id="moneda-recibir" name="moneda-recibir">
                                <!-- Las opciones se poblarÃ¡n dinÃ¡micamente con JS -->
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Botones de Compra/Venta -->
                <div class="btn-group mb-3 w-100" role="group" id="toggle-trade-type">
                    <input type="hidden" name="accion" id="accion" value="comprar">
                    <button type="button" class="btn w-50 btn-success active boton-comprar"
                        data-action="comprar">Comprar</button>
                    <button type="button" class="btn w-50 btn-outline-secondary boton-vender"
                        data-action="vender">Vender</button>
                </div>

                <!-- Tipo de Orden -->
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Tipo de orden</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-mercado" value="mercado"
                            autocomplete="off" checked required>
                        <label class="btn btn-outline-primary rounded-start-pill" for="tipo-mercado">Mercado</label>

                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-limite" value="limite"
                            autocomplete="off">
                        <label class="btn btn-outline-primary" for="tipo-limite">LÃ­mite</label>

                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-stop-limit" value="stop-limit"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="tipo-stop-limit">Stop-Limit</label>
                    </div>
                </div>

                <!-- Modo de Ingreso -->
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Ingresar por</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-monto" value="monto"
                            autocomplete="off" checked required>
                        <label class="btn btn-outline-primary rounded-start-pill" for="modo-monto">Monto
                            (Cripto)</label>

                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-total" value="total"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="modo-total">Total (USD)</label>
                    </div>
                </div>

                <!-- Campo para el Monto -->
                <div class="mb-3">
                    <label for="monto" class="form-label">Monto</label>
                    <input type="number" class="form-control" id="monto" placeholder="0.00" name="monto" required
                        min="0.00000001" step="any">
                </div>

                <!-- Slider de Porcentaje -->
                <div class="mb-3">
                    <input type="range" class="form-range" min="0" max="100" step="1" id="slider-monto" value="0"
                        name="slider">
                    <div class="d-flex justify-content-between text-white-50 small">
                        <span>0%</span><span>25%</span><span>50%</span><span>75%</span><span>100%</span>
                    </div>
                </div>

                <!-- Saldo Disponible (se actualizarÃ¡ con JS) -->
                <div class="mb-3 text-end text-secondary">
                    <small>Disponible: <span id="saldo-disponible">--</span></small>
                </div>

                <!-- BotÃ³n de ConfirmaciÃ³n -->
                <button type="submit" class="btn w-100 btn-success boton-confirmar"
                    id="boton-confirmar">CONFIRMAR</button>
            </form>
        </div>

        <!-- ===== SECCIÃ“N HISTORIAL DE TRANSACCIONES ===== -->
        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">Historial de transacciones</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Cantidad</th>
                                <th>Valor Total</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-historial">
                            {% include "fragmento_historial.html" %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== SECCIÃ“N SCRIPTS ===== -->
    <script>
        // Estas variables ahora se asignan a window para ser accesibles globalmente por los mÃ³dulos
        window.todasLasCriptos = JSON.parse('{{ lista_todas_las_criptos_json|safe }}');
        window.monedasPropias = JSON.parse('{{ lista_monedas_propias_json|safe }}');
        window.billetera = JSON.parse('{{ billetera_json|safe }}');
    </script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script defer
        src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script defer src="{{ url_for('static', filename='js/renderizarGraficoVelas.js') }}"></script>

    <!-- ===> CARGA DEL NUEVO SCRIPT PRINCIPAL MODULAR <=== -->
    <script type="module" src="{{ url_for('static', filename='js/tradingPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./README.md ===
==================================================

# Simulador Exchange - **BlokX**

Este proyecto educativo fue desarrollado en el marco de la materia "Algoritmos y Estructuras de Datos I" de UADE, bajo la supervisiÃ³n de la profesora Julia Monasterio.  
Su objetivo es aplicar los conocimientos de la cÃ¡tedra simulando el funcionamiento bÃ¡sico de un exchange de criptomonedas.  
El sistema permite a los usuarios operar con saldo ficticio utilizando datos reales de cotizaciÃ³n obtenidos de CoinGecko y Binance.

## ğŸ¯ Objetivos del proyecto

- Familiarizar a los usuarios con el entorno de un exchange de criptomonedas.
- Simular operaciones de compra y venta mediante distintos tipos de Ã³rdenes: Market, Limit y Stop-Loss.
- Calcular y visualizar ganancias, pÃ©rdidas y balances del portafolio.
- Almacenar toda la informaciÃ³n de manera local utilizando archivos `.json`.
- Comprender la interacciÃ³n entre frontend y backend mediante una arquitectura moderna (HTML, CSS, Flask y Python).

## âš™ï¸ Funcionalidades

### Panel general de cotizaciones
- VisualizaciÃ³n del top de criptomonedas con:
  - Nombre, ticker, precio, market cap, volumen, supply.
  - VariaciÃ³n en 1h, 24h y 7 dÃ­as.
- ActualizaciÃ³n automÃ¡tica de precios cada 15 segundos.

### Panel de trading
En este panel se verÃ¡n tres secciones diferentes que contemplan lo necesario para ejecutar las ordenes de compra/venta.

#### GrÃ¡fico de velas japonesas
- Grafico en el cual se va a poder visualizar los diferentes pares de criptos usando Lightweight Charts (Libreria de JavaScript), en diferentes time frames: 1m, 5m, 15m, 1h, 4hs, 1d y 1w.

#### Ã“rdenes
- Compra y venta de activos con Ã³rdenes:
  - Market
  - Limit
  - Stop-loss
- ComisiÃ³n fija del 0.5% por transacciÃ³n.
- Validaciones de saldo y tenencias disponibles.

#### Historial
- Registro de todas las operaciones realizadas.
- Incluye tipo de orden, precio, cantidad, fecha y fee aplicado.
  
### Billetera
- VisualizaciÃ³n de tenencias actuales:
  - Cantidad, precio promedio, valor actual, ganancia/pÃ©rdida por activo.
- Balance total del portafolio en USDT.

## ğŸ§  CÃ³mo funciona el sistema

El sistema estÃ¡ diseÃ±ado bajo una arquitectura modular que separa responsabilidades:

- **Rutas (`rutas/`)**: contienen los blueprints de Flask, que responden a las URLs y renderizan las plantillas HTML.
- **Servicios (`servicios/`)**: implementan la lÃ³gica de negocio (por ejemplo, compra y venta de criptomonedas, cÃ¡lculos de balances, renderizado dinÃ¡mico de fragmentos).
- **Acceso a datos (`acceso_datos/`)**: se encargan de leer y escribir archivos JSON, simulando una base de datos local.
- **Frontend (`frontend/`)**: contiene el HTML, CSS y JavaScript para la interfaz del usuario, incluyendo grÃ¡ficos interactivos y recarga dinÃ¡mica de datos.

### Flujo general

1. Al ingresar a la app, se cargan cotizaciones reales desde CoinGecko.
2. El usuario puede:
   - Consultar cotizaciones (actualizadas cada 15 segundos).
   - Ingresar al panel de trading y operar.
   - Visualizar su billetera y el historial de operaciones.
3. Toda la informaciÃ³n es persistida automÃ¡ticamente en archivos `.json`.

## ğŸ—ƒï¸ Estructura del proyecto

```
simulador_exchange/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ app.py                      # Servidor Flask y punto de entrada
â”‚   â”œâ”€â”€ config.py                   # ConfiguraciÃ³n del sistema y constantes globales
â”‚   â”œâ”€â”€ rutas/                      # Blueprints que definen las vistas
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ home.py
â”‚   â”‚   â”œâ”€â”€ trading_vista.py
â”‚   â”‚   â”œâ”€â”€ billetera_vista.py
â”‚   â”‚   â””â”€â”€ api_externa.py
â”‚   â”œâ”€â”€ servicios/                  # LÃ³gica de negocio de cada mÃ³dulo
â”‚   â”‚   â”œâ”€â”€ api_cotizaciones.py
â”‚   â”‚   â”œâ”€â”€ cotizaciones.py
â”‚   â”‚   â”œâ”€â”€ estado_billetera.py
â”‚   â”‚   â”œâ”€â”€ trading_logica.py
â”‚   â”‚   â””â”€â”€ velas_logica.py
â”‚   â”œâ”€â”€ acceso_datos/              # Acceso y manipulaciÃ³n de archivos .json
â”‚   â”‚   â”œâ”€â”€ datos_billetera.py
â”‚   â”‚   â”œâ”€â”€ datos_cotizaciones.py
â”‚   â”‚   â””â”€â”€ datos_historial.py
â”‚   â””â”€â”€ utils/                     # Utilidades auxiliares
â”‚       â””â”€â”€ formateo_decimales.py
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ templates/                 # Plantillas HTML renderizadas por Flask
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ billetera.html
â”‚   â”‚   â”œâ”€â”€ trading.html
â”‚   â”‚   â”œâ”€â”€ fragmento_billetera.html
â”‚   â”‚   â”œâ”€â”€ fragmento_formulario_trading.html
â”‚   â”‚   â”œâ”€â”€ fragmento_historial.html
â”‚   â”‚   â”œâ”€â”€ fragmento_mensajes_flash.html
â”‚   â”‚   â””â”€â”€ fragmento_tabla.html
â”‚   â””â”€â”€ static/                    # Archivos estÃ¡ticos
â”‚       â”œâ”€â”€ css/
â”‚       â”‚   â”œâ”€â”€ styles_index.css
â”‚       â”‚   â””â”€â”€ styles_trading.css
â”‚       â”œâ”€â”€ img/
â”‚       â”‚   â””â”€â”€ logo_BlocX.png
â”‚       â””â”€â”€ js/
â”‚           â”œâ”€â”€ funciones.js
â”‚           â””â”€â”€ grafico_velas.js
â”‚
â”œâ”€â”€ datos/                         # Archivos de persistencia
â”‚   â”œâ”€â”€ billetera.json
â”‚   â”œâ”€â”€ datos_cotizaciones.json
â”‚   â”œâ”€â”€ datos_velas.json
â”‚   â””â”€â”€ historial_operaciones.json
â”‚
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ .gitignore
â””â”€â”€ README.md
```

## ğŸš€ CÃ³mo ejecutar el proyecto

### 1. Crear entorno virtual (recomendado)
```bash
python3 -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

### 2. Instalar dependencias
```bash
pip install -r requirements.txt
```

### 3. Iniciar la app
```bash
python3 app.py
```

Y luego acceder desde el navegador a:  
```
http://localhost:5000
```

## ğŸ“¦ TecnologÃ­as utilizadas

- Python 3.13
- Flask
- HTML, CSS, JavaScript
- Lightweight Charts (TradingView)

## ğŸ“Œ Notas

- Todos los datos se almacenan localmente en formato JSON.
- No se requiere conexiÃ³n a bases de datos externas.
- El sistema estÃ¡ pensado para ser didÃ¡ctico y extensible.

---

**Grupo 12**  
Fausto Lovera â€” Patricio Menta â€” Andrei Veis


==================================================
=== ARCHIVO: ./requirements.txt ===
==================================================

Flask==3.1.0
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
requests==2.32.3
Werkzeug==3.1.3
flasgger==0.9.5


==================================================
=== FIN DEL REPORTE ===
==================================================
