==================================================
=== REPORTE DE CÓDIGO CONSOLIDADO ===
Proyecto: Trabajo_Simulador_Exchange
Ruta: /Users/andreiveis/UADE/2do cuatrimestre/05_Algoritmos y Estructura de datos I/Trabajo_Simulador_Exchange
Generado el: Thu Jun 26 23:16:39 -03 2025
==================================================

--- INFORMACIÓN DEL REPOSITORIO GIT ---
Rama actual: fix_codigo
Último commit: b9bc3ad - Ordenes MARKET y LIMITE OK. Falta correcto diseño de stop-limit. Ahora trabajando en eso. (andreiveisuade, 6 hours ago)
---

--- ESTRUCTURA DEL DIRECTORIO ---
.
├── .env
├── .gitignore
├── backend
│   ├── __init__.py
│   ├── acceso_datos
│   │   ├── datos_billetera.py
│   │   ├── datos_comisiones.py
│   │   ├── datos_cotizaciones.py
│   │   ├── datos_historial.py
│   │   └── datos_ordenes.py
│   ├── app.py
│   ├── rutas
│   │   ├── __init__.py
│   │   ├── api_externa.py
│   │   ├── billetera_vista.py
│   │   ├── home.py
│   │   └── trading_vista.py
│   ├── servicios
│   │   ├── __init__.py
│   │   ├── api_cotizaciones.py
│   │   ├── estado_billetera.py
│   │   ├── presentacion_datos.py
│   │   └── trading
│   │       ├── __init__.py
│   │       ├── ejecutar_orden.py
│   │       ├── gestor.py
│   │       ├── motor.py
│   │       └── procesador.py
│   └── utils
│       ├── formatters.py
│       └── utilidades_numericas.py
├── config.py
├── documentacion.md
├── frontend
│   ├── static
│   │   ├── css
│   │   │   ├── styles_index.css
│   │   │   └── styles_trading.css
│   │   ├── img
│   │   └── js
│   │       ├── components
│   │       │   ├── chartRenderer.js
│   │       │   ├── domElements.js
│   │       │   ├── formLogic.js
│   │       │   ├── tablaCotizacionesUI.js
│   │       │   ├── uiState.js
│   │       │   └── uiUpdater.js
│   │       ├── pages
│   │       │   ├── billeteraPage.js
│   │       │   ├── indexPage.js
│   │       │   └── tradingPage.js
│   │       ├── services
│   │       │   ├── apiService.js
│   │       │   ├── appState.js
│   │       │   └── statePersistence.js
│   │       └── utils
│   │           └── sweetalert-init.js
│   └── templates
│       ├── _flashes.html
│       ├── billetera.html
│       ├── index.html
│       └── trading.html
├── pytest.ini
├── README.md
├── requirements.txt
└── tests
    ├── __init__.py
    ├── test_estado_billetera.py
    ├── test_trading_logica.py
    └── test_velas_logica.py

18 directories, 53 files
---

==================================================
=== ARCHIVO: ./.env ===
==================================================

# Clave secreta para sesiones de Flask. ¡NO COMPARTIR!
FLASK_SECRET_KEY='f9ce7ff641c611e7e519d1551ccdfd699929967d87528324'


==================================================
=== ARCHIVO: ./.gitignore ===
==================================================

# ARCHIVOS PROPIOS NUESTROS
/datos/datos_cotizaciones.json
/datos/datos_velas.json
/datos/billetera.json
/datos/historial_operaciones.json


# Python
__pycache__/
backend/__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.env
.venv
env/
venv/
ENV/
.pytest_cache/
.coverage
coverage.xml
*.cover
.hypothesis/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
__MACOSX/

# IDEs and editors
.idea/
.vscode/
*.swp
*.swo
.project
.classpath
*.sublime-workspace
*.sublime-project

# Frontend
node_modules/
/dist
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env.local
.env.*.local
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
*.sqlite
*.sqlite3
*.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Backup files
*.bak
*.backup
*~

# Environment variables
.env
.env.*
!.env.example

# System Files
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
datos/billetera.json
datos/datos_cotizaciones.json
datos/datos_velas.json
*.pyc
# D2 files
*.d2
diagrama.png


==================================================
=== ARCHIVO: ./backend/__init__.py ===
==================================================

"""
Paquete principal del backend de la aplicación.

Este archivo `__init__.py` no solo marca el directorio `backend` como un paquete de
Python, sino que también contiene la "Application Factory" `crear_app`.
Este patrón es una buena práctica en Flask que permite crear múltiples instancias
de la aplicación con diferentes configuraciones, facilitando las pruebas y la
escalabilidad.
"""

from flask import Flask
from config import FLASK_SECRET_KEY
from backend.rutas import registrar_rutas

def crear_app() -> Flask:
    """
    Crea, configura y devuelve una instancia de la aplicación Flask.

    Esta función sigue el patrón de diseño "Application Factory". Se encarga de:
    1. Crear la instancia de la aplicación Flask.
    2. Configurar la ubicación de las carpetas de plantillas y archivos estáticos.
    3. Establecer la clave secreta para la gestión de sesiones y mensajes flash.
    4. Registrar todos los blueprints (conjuntos de rutas) de la aplicación.

    Returns:
        Flask: La instancia de la aplicación Flask configurada y lista para usarse.
    """
    app = Flask(
        __name__,
        static_folder="../frontend/static",
        template_folder="../frontend/templates",
    )

    app.secret_key = FLASK_SECRET_KEY

    registrar_rutas(app)

    return app

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_billetera.py ===
==================================================

# backend/acceso_datos/datos_billetera.py
### MODIFICADO Y SIMPLIFICADO ###

import json
import os
from decimal import Decimal

from backend.utils.utilidades_numericas import a_decimal, cuantizar_cripto
from config import BILLETERA_PATH, BALANCE_INICIAL_USDT

def _crear_billetera_inicial() -> dict:
    """Crea el objeto de billetera inicial con la nueva estructura."""
    return {
        "USDT": {
            "nombre": "Tether",
            "saldos": {
                "disponible": a_decimal(BALANCE_INICIAL_USDT),
                "reservado": a_decimal("0")
            }
        }
    }

def cargar_billetera() -> dict[str, dict]:
    """
    Carga la billetera de criptomonedas desde un archivo JSON.
    Asume que el archivo ya está en el nuevo formato.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    if not os.path.exists(BILLETERA_PATH) or os.path.getsize(BILLETERA_PATH) == 0:
        billetera_inicial = _crear_billetera_inicial()
        guardar_billetera(billetera_inicial)
        return billetera_inicial

    try:
        with open(BILLETERA_PATH, "r", encoding="utf-8") as f:
            datos_cargados = json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(f"Advertencia: Archivo '{BILLETERA_PATH}' corrupto. Se reiniciará la billetera.")
        billetera_inicial = _crear_billetera_inicial()
        guardar_billetera(billetera_inicial)
        return billetera_inicial

    # Carga directa asumiendo el nuevo formato
    billetera_final = {}
    for ticker, activo in datos_cargados.items():
        billetera_final[ticker] = {
            "nombre": activo.get("nombre", ticker),
            "saldos": {
                "disponible": a_decimal(activo["saldos"].get("disponible", "0")),
                "reservado": a_decimal(activo["saldos"].get("reservado", "0"))
            }
        }
    return billetera_final

def guardar_billetera(billetera: dict[str, dict]):
    """
    Guarda el estado actual de la billetera en un archivo JSON.
    Usa la nueva estructura y formatea los ceros para mejorar la legibilidad.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    # Renombramos 'billetera_serializable' a 'datos_para_json' para más claridad
    datos_para_json = {}
    for ticker, activo in billetera.items():
        saldos = activo.get("saldos", {})
        
        saldo_disponible = saldos.get("disponible", a_decimal(0))
        saldo_reservado = saldos.get("reservado", a_decimal(0))
        
        saldo_disponible_q = cuantizar_cripto(saldo_disponible)
        saldo_reservado_q = cuantizar_cripto(saldo_reservado)
        
        # Formateo de ceros para legibilidad
        str_disponible = "0.00000000" if saldo_disponible_q.is_zero() else str(saldo_disponible_q)
        str_reservado = "0.00000000" if saldo_reservado_q.is_zero() else str(saldo_reservado_q)
        
        datos_para_json[ticker] = {
            "nombre": activo.get("nombre", ticker),
            "saldos": {
                "disponible": str_disponible,
                "reservado": str_reservado,
            }
        }

    with open(BILLETERA_PATH, "w", encoding="utf-8") as f:
        json.dump(datos_para_json, f, indent=4)

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_comisiones.py ===
==================================================

# backend/acceso_datos/datos_comisiones.py
### MODIFICADO ###

import json
import os
from datetime import datetime
from decimal import Decimal

# Importamos las nuevas utilidades numéricas
from backend.utils.utilidades_numericas import cuantizar_cripto, cuantizar_usd
from config import COMISIONES_PATH

def cargar_comisiones() -> list:
    """Carga el historial de comisiones desde el archivo JSON."""
    if not os.path.exists(COMISIONES_PATH) or os.path.getsize(COMISIONES_PATH) == 0:
        return []
    try:
        with open(COMISIONES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(f"Advertencia: No se pudo leer o el archivo '{COMISIONES_PATH}' está corrupto.")
        return []

def registrar_comision(
    ticker_comision: str,
    cantidad_comision: Decimal,
    valor_usd_comision: Decimal
):
    """
    Guarda un nuevo registro de comisión usando las utilidades de cuantización.
    """
    os.makedirs(os.path.dirname(COMISIONES_PATH), exist_ok=True)
    comisiones = cargar_comisiones()

    cantidad_comision_q = cuantizar_cripto(cantidad_comision)
    valor_usd_comision_q = cuantizar_usd(valor_usd_comision)

    nueva_comision = {
        "id": len(comisiones) + 1,
        "timestamp": datetime.now().isoformat(),
        "ticker": ticker_comision,
        "cantidad": str(cantidad_comision_q),
        "valor_usd": str(valor_usd_comision_q),
    }
    
    print(
        f"💰 COMISIÓN REGISTRADA: "
        f"{nueva_comision['cantidad']} {nueva_comision['ticker']} "
        f"(valor: ${nueva_comision['valor_usd']})"
    )

    comisiones.insert(0, nueva_comision)

    with open(COMISIONES_PATH, "w", encoding="utf-8") as f:
        json.dump(comisiones, f, indent=4)

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_cotizaciones.py ===
==================================================

"""
Módulo de acceso a datos de cotizaciones.

Este módulo utiliza un patrón de fábrica (closure) para gestionar un caché de precios
en memoria de forma segura, evitando el uso de variables globales explícitas.

Expone públicamente:
- obtener_precio(ticker): Obtiene el precio de una cripto, usando el caché.
- cargar_datos_cotizaciones(): Carga la lista de cotizaciones desde el archivo.
- guardar_datos_cotizaciones(data): Guarda las cotizaciones en el archivo y
  automáticamente actualiza el caché.
"""

import json
import os
from decimal import Decimal
from typing import Callable, Tuple, Any

from config import COTIZACIONES_PATH


# Función fábrica
def _crear_gestor_cache_precios() -> Tuple[Callable[[str], Decimal | None], Callable[[], None]]:
    """
    Función de fábrica interna que crea un gestor de caché de precios.

    Usa un closure para encapsular el diccionario del caché (_cache), protegiéndolo
    del acceso externo y eliminando la necesidad de variables globales o de módulo.

    Returns:
        Una tupla con dos funciones que operan sobre el mismo caché encapsulado:
        - La función para obtener un precio.
        - La función para forzar una recarga del caché.
    """
    _cache = {}  # Este diccionario es privado y solo vive en este módulo.

    def _recargar_desde_archivo():
        """
        Función interna y privada que lee el archivo JSON y puebla el caché.
        Modifica la variable `_cache` de su closure.
        """
        nonlocal _cache
        print("🔄 Recargando caché de precios desde el archivo...")
        
        if not os.path.exists(COTIZACIONES_PATH) or os.path.getsize(COTIZACIONES_PATH) == 0:
            lista_criptos = []
        else:
            try:
                with open(COTIZACIONES_PATH, "r", encoding="utf-8") as f:
                    lista_criptos = json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                lista_criptos = []
        
        _cache = {
            cripto.get("ticker", "").upper(): Decimal(str(cripto.get("precio_usd", "0")))
            for cripto in lista_criptos
        }
        print("✅ Caché de precios actualizado en memoria.")

    def obtener_precio_desde_cache(ticker: str) -> Decimal | None:
        """
        Obtiene el precio de un ticker desde el caché.
        Si el caché está vacío, dispara la recarga la primera vez.
        """
        if not _cache:
            _recargar_desde_archivo()
        
        return _cache.get(ticker.upper())

    def forzar_recarga_cache():
        """Función pública para forzar la recarga del caché."""
        _recargar_desde_archivo()

    # La fábrica devuelve las dos funciones que el resto de la app usará.
    return obtener_precio_desde_cache, forzar_recarga_cache

# --- Punto de Entrada del Módulo ---

# 1. Llamamos a la fábrica UNA SOLA VEZ cuando se importa este módulo.
# 2. Se crea un caché privado y dos funciones ('_obtener', '_recargar') que lo gestionan.
# 3. Asignamos esas funciones a nombres a nivel de módulo que serán exportados.
_obtener, _recargar = _crear_gestor_cache_precios()


# --- API Pública del Módulo ---

def obtener_precio(ticker: str) -> Decimal | None:
    """
    Interfaz pública para obtener el precio de una criptomoneda desde el caché.
    """
    return _obtener(ticker)


def cargar_datos_cotizaciones() -> list[dict]:
    """
    Interfaz pública para cargar la lista completa de cotizaciones desde el archivo.
    Esto es necesario para el módulo de presentación que formatea todos los datos.
    """
    if not os.path.exists(COTIZACIONES_PATH) or os.path.getsize(COTIZACIONES_PATH) == 0:
        return []
    try:
        with open(COTIZACIONES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return []


def guardar_datos_cotizaciones(data: list[dict[str, Any]]):
    """
    Interfaz pública para guardar los datos de cotizaciones en el archivo.
    Después de guardar, fuerza automáticamente la recarga del caché en memoria.
    """
    os.makedirs(os.path.dirname(COTIZACIONES_PATH), exist_ok=True)
    print("💾 Guardando datos en datos_cotizaciones.json...")
    try:
        with open(COTIZACIONES_PATH, "w") as archivo:
            # Usar un default handler para convertir Decimal a float en la serialización.
            # Esto es solo si los datos de entrada contienen Decimals, lo cual no debería ser el caso.
            json.dump(data, archivo, indent=4)
        print("✅ Datos de cotizaciones guardados en archivo.")
        # Llama a la función de recarga para mantener el caché sincronizado.
        _recargar()
    except (IOError, TypeError) as e:
        print(f"❌ Error al guardar el archivo de cotizaciones: {e}")

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_historial.py ===
==================================================

# backend/acceso_datos/datos_historial.py
### MODIFICADO ###

import json
import os
from datetime import datetime
from decimal import Decimal

# Importamos las nuevas utilidades numéricas
from backend.utils.utilidades_numericas import cuantizar_cripto, cuantizar_usd
from config import HISTORIAL_PATH


def cargar_historial():
    """
    Carga el historial de transacciones desde el archivo JSON.
    (Sin cambios en la carga, la conversión a Decimal se hace en la capa de servicios).
    """
    if not os.path.exists(HISTORIAL_PATH) or os.path.getsize(HISTORIAL_PATH) == 0:
        return []

    try:
        with open(HISTORIAL_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: No se pudo leer o el archivo '{HISTORIAL_PATH}' está corrupto."
        )
        return []


def guardar_en_historial(
    tipo_operacion: str,
    moneda_origen: str,
    cantidad_origen: Decimal,
    moneda_destino: str,
    cantidad_destino: Decimal,
    valor_usd: Decimal,
):
    """
    Guarda una nueva operación en el historial de transacciones.

    Usa las utilidades de cuantización para asegurar la precisión correcta
    antes de guardar los datos en el archivo JSON.
    """
    os.makedirs(os.path.dirname(HISTORIAL_PATH), exist_ok=True)
    historial = cargar_historial()

    # ### ANTES: usaba .quantize() con valores mágicos.
    # ### DESPUÉS: usamos las utilidades centralizadas.
    cantidad_origen_q = cuantizar_cripto(cantidad_origen)
    cantidad_destino_q = cuantizar_cripto(cantidad_destino)
    valor_usd_q = cuantizar_usd(valor_usd)

    operacion = {
        "id": len(historial) + 1,
        "timestamp": datetime.now().isoformat(),
        "tipo": tipo_operacion,
        "origen": {"ticker": moneda_origen, "cantidad": str(cantidad_origen_q)},
        "destino": {"ticker": moneda_destino, "cantidad": str(cantidad_destino_q)},
        "valor_usd": str(valor_usd_q),
    }

    historial.insert(0, operacion)

    with open(HISTORIAL_PATH, "w", encoding="utf-8") as f:
        json.dump(historial, f, indent=4)

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_ordenes.py ===
==================================================

# backend/acceso_datos/datos_ordenes.py

"""
Módulo de Acceso a Datos para las Órdenes Pendientes.

Este módulo se encarga de la persistencia de las órdenes de trading que no se
ejecutan de inmediato (Límite, Stop-Loss) y que están a la espera de que se
cumplan ciertas condiciones de mercado.
"""
import json
import os
from config import ORDENES_PENDIENTES_PATH


def cargar_ordenes_pendientes() -> list[dict]:
    """
    Carga la lista de órdenes pendientes desde el archivo JSON.

    Si el archivo no existe o está vacío, devuelve una lista vacía.

    Returns:
        list[dict]: Una lista de diccionarios, donde cada uno es una orden pendiente.
    """
    # Asegura que el directorio exista
    os.makedirs(os.path.dirname(ORDENES_PENDIENTES_PATH), exist_ok=True)
    
    if not os.path.exists(ORDENES_PENDIENTES_PATH) or os.path.getsize(ORDENES_PENDIENTES_PATH) == 0:
        return []

    try:
        with open(ORDENES_PENDIENTES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(f"Advertencia: No se pudo leer o el archivo '{ORDENES_PENDIENTES_PATH}' está corrupto.")
        return []


def guardar_ordenes_pendientes(lista_ordenes: list[dict]):
    """
    Guarda la lista completa de órdenes pendientes en el archivo JSON.

    Esta función sobrescribe el archivo con la lista proporcionada. Se utiliza
    para actualizar el estado de las órdenes (ej. de 'pendiente' a 'ejecutada').

    Args:
        lista_ordenes (list[dict]): La lista completa de órdenes a guardar.
    """
    # Asegura que el directorio exista
    os.makedirs(os.path.dirname(ORDENES_PENDIENTES_PATH), exist_ok=True)

    with open(ORDENES_PENDIENTES_PATH, "w", encoding="utf-8") as f:
        json.dump(lista_ordenes, f, indent=4)


def agregar_orden_pendiente(nueva_orden: dict):
    """
    Añade una nueva orden a la lista de órdenes pendientes y la guarda.

    Args:
        nueva_orden (dict): El diccionario que representa la nueva orden a agregar.
    """
    ordenes = cargar_ordenes_pendientes()
    ordenes.append(nueva_orden)
    guardar_ordenes_pendientes(ordenes)

==================================================
=== ARCHIVO: ./backend/app.py ===
==================================================

"""
Punto de entrada para ejecutar la aplicación Flask en modo de desarrollo.

Este script importa la 'Application Factory' (`crear_app`), la utiliza para
crear una instancia de la aplicación y, si se ejecuta directamente, inicia
el servidor de desarrollo de Flask.

Para iniciar la aplicación, ejecuta el siguiente comando desde el directorio raíz
del proyecto:
    python -m backend.app
"""

from flask import Flask
from . import crear_app

# Se crea la instancia global de la aplicación llamando a la factory.
app: Flask = crear_app()

# El siguiente bloque se ejecuta solo si el script es llamado directamente
# por el intérprete de Python (por ejemplo, `python -m backend.app`).
if __name__ == "__main__":
    # Inicia el servidor de desarrollo de Flask.
    # `debug=True` activa el modo de depuración, que proporciona un depurador
    # interactivo y recarga automáticamente el servidor al detectar cambios.
    app.run(debug=True)

==================================================
=== ARCHIVO: ./backend/rutas/__init__.py ===
==================================================

"""
Inicializa el paquete de rutas y registra todos los Blueprints de la aplicación.

Este archivo importa los Blueprints definidos en los diferentes módulos de vistas
(home, trading, billetera, etc.) y proporciona una función centralizada `registrar_rutas`
para vincularlos a la instancia principal de la aplicación Flask.
"""

from .home import bp as home_bp
from .trading_vista import bp as trading_bp
from .billetera_vista import bp as billetera_bp
from .api_externa import bp as api_ruta_bp


def registrar_rutas(app):
    """
    Registra todos los Blueprints de la aplicación en la instancia de Flask.

    Args:
        app (Flask): La instancia principal de la aplicación Flask a la que se
                     registrarán los Blueprints.

    Side Effects:
        Modifica el objeto `app` registrando las rutas definidas en los Blueprints.
    """
    app.register_blueprint(home_bp)
    app.register_blueprint(trading_bp)
    app.register_blueprint(billetera_bp)
    app.register_blueprint(api_ruta_bp)


==================================================
=== ARCHIVO: ./backend/rutas/api_externa.py ===
==================================================

# backend/rutas/api_externa.py

"""
Define los endpoints de la API externa de la aplicación.

Este módulo contiene las rutas que exponen datos del mercado de criptomonedas,
como cotizaciones y datos de velas (candlestick), para ser consumidos por el frontend
u otros clientes.
"""

from flask import Blueprint, jsonify
from backend.servicios.api_cotizaciones import obtener_datos_criptos_coingecko, obtener_velas_de_api
from backend.servicios.presentacion_datos import obtener_cotizaciones_formateadas

from backend.servicios.trading.motor import verificar_y_ejecutar_ordenes_pendientes

bp = Blueprint("api_externa", __name__, url_prefix="/api")


@bp.route("/actualizar")
def actualizar():
    """
    Endpoint para forzar la actualización de los datos de cotizaciones desde CoinGecko.

    Al ser llamado, este endpoint invoca al servicio que obtiene los precios más
    recientes y, crucialmente, LUEGO invoca al motor de ejecución de órdenes
    para ver si alguna orden pendiente debe dispararse con los nuevos precios.
    """
    print("--- PING: Endpoint /api/actualizar ALCANZADO ---")
    
    # 1. Obtener los datos más recientes de cotizaciones y guardarlos.
    datos_criptos = obtener_datos_criptos_coingecko()
    
    # --- 2. ¡ACTIVAR EL MOTOR DE EJECUCIÓN DE ÓRDENES! ---
    # Con los precios frescos en memoria, verificamos si alguna orden pendiente se cumple.
    verificar_y_ejecutar_ordenes_pendientes()
    
    # 3. Devolver la respuesta al frontend.
    return jsonify({"estado": "ok", "cantidad_criptos": len(datos_criptos)})


@bp.route("/cotizaciones")
def get_cotizaciones():
    """
    Retorna la lista completa de cotizaciones, formateada para la presentación.

    Esta ruta utiliza el servicio de presentación para tomar los datos crudos
    y enriquecerlos con formato antes de enviarlos al frontend.

    Returns:
        Response: Un objeto JSON que contiene una lista de todas las criptomonedas
                  y sus datos de cotización listos para ser mostrados.
                  Ejemplo: `[{"ticker": "BTC", "precio_usd_formatted": "$65,000.10", ...}]`
    """
    return jsonify(obtener_cotizaciones_formateadas())


@bp.route("/velas/<string:ticker>/<string:interval>")
def obtener_datos_velas_por_ticker(ticker: str, interval: str):
    """
    Obtiene los datos de velas (candlestick) para un par y un intervalo específicos.

    Esta ruta dinámica consulta a una API externa para obtener los datos históricos
    de precios (OHLCV) necesarios para graficar las velas.

    Args:
        ticker (str): El símbolo del par a consultar (ej. "BTCUSDT").
        interval (str): El intervalo de tiempo para las velas (ej. "1h", "4h", "1d").

    Returns:
        Response: Un objeto JSON con una lista de listas, donde cada sublista
                  representa una vela. En caso de error, retorna una lista vacía.
                  Ejemplo: `[[1622505600000, "49000.00", ...], ...]`
    """
    try:
        datos = obtener_velas_de_api(ticker, interval)
        return jsonify(datos)
    except Exception as e:
        print(f"❌ Error en la ruta de velas para {ticker}/{interval}: {e}")
        return jsonify([])

==================================================
=== ARCHIVO: ./backend/rutas/billetera_vista.py ===
==================================================

"""
Define las rutas relacionadas con la visualización de la billetera y el historial.

Este módulo contiene los endpoints para renderizar la página de la billetera
y para proporcionar datos financieros (estado actual y transacciones pasadas)
 a través de una API REST al frontend.
"""

from flask import Blueprint, render_template, jsonify, request, flash, redirect, url_for
from backend.servicios.estado_billetera import estado_actual_completo, obtener_historial_formateado
from backend.acceso_datos.datos_comisiones import cargar_comisiones
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes
from backend.servicios.trading.gestor import cancelar_orden_pendiente

bp = Blueprint("billetera", __name__)


@bp.route("/billetera")
def mostrar_billetera():
    """
    Renderiza la página principal de la billetera.

    Esta ruta sirve el archivo `billetera.html`, que actúa como el contenedor
    principal para la interfaz de la billetera. Los datos se cargan de forma
    asíncrona a través de llamadas a la API desde JavaScript.

    Returns:
        Response: El contenido HTML renderizado de la página de la billetera.
    """
    return render_template("billetera.html")


@bp.route("/api/billetera/estado-completo")
def get_estado_billetera_completo():
    """
    Endpoint de API que devuelve el estado financiero completo de la billetera.

    Proporciona un resumen detallado que incluye el balance de cada criptomoneda,
    su valor en USD, el total general, y el rendimiento.

    Returns:
        Response: Un objeto JSON con el estado completo de la billetera.
            Ejemplo: `{"total_usd": "10500.50", "rendimiento": "5.00", ...}`
    """
    datos = estado_actual_completo()
    return jsonify(datos)


@bp.route("/api/historial")
def get_historial_transacciones():
    """
    Endpoint de API que devuelve el historial completo de transacciones.

    Retorna una lista de todas las operaciones de compra y venta realizadas,
    formateadas para su visualización en el frontend.

    Returns:
        Response: Un objeto JSON que contiene una lista de transacciones.
            Ejemplo: `[{"id": 1, "fecha": "21/06/2025", "tipo": "compra", ...}]`
    """
    return jsonify(obtener_historial_formateado())

@bp.route("/api/comisiones")
def get_historial_comisiones():
    """
    Endpoint de API que devuelve el historial completo de comisiones cobradas.
    """
    return jsonify(cargar_comisiones())

@bp.route("/api/ordenes-abiertas")
def get_ordenes_abiertas():
    """
    Endpoint de API que devuelve la lista de órdenes que están pendientes de ejecución.
    """
    todas_las_ordenes = cargar_ordenes_pendientes()
    # Filtramos para devolver solo las que están activas
    ordenes_abiertas = [o for o in todas_las_ordenes if o.get("estado") == "pendiente"]
    return jsonify(ordenes_abiertas)

@bp.route("/api/orden/cancelar/<string:id_orden>", methods=["POST"])
def cancelar_orden_api(id_orden: str):
    """
    ### REFACTORIZADO ### - Endpoint de API para cancelar una orden pendiente.
    Devuelve una respuesta JSON estandarizada.
    """
    resultado = cancelar_orden_pendiente(id_orden)
    
    if "error" in resultado:
        # Si el diccionario de resultado contiene un error, devolvemos un estado 400 (Bad Request).
        return jsonify({
            "estado": "error",
            "mensaje": resultado["error"]
        }), 400
    else:
        # Si no hay error, devolvemos un estado 200 (OK).
        return jsonify({
            "estado": "ok",
            "mensaje": resultado["mensaje"],
            "datos": resultado.get("datos", {})
        }), 200

==================================================
=== ARCHIVO: ./backend/rutas/home.py ===
==================================================

"""
Define la ruta principal (landing page) de la aplicación.

Este módulo es responsable de servir la página de inicio (index.html),
que actúa como el punto de entrada para los usuarios.
"""

from flask import Blueprint, render_template

bp = Blueprint("home", __name__)


@bp.route("/")
def index():
    """
    Renderiza la página de inicio de la aplicación.

    Esta ruta sirve el archivo `index.html`, que es el esqueleto principal
    de la interfaz. El contenido dinámico, como las cotizaciones, se carga
    posteriormente de forma asíncrona mediante JavaScript.

    Returns:
        Response: El contenido HTML renderizado de la página de inicio.
    """
    return render_template("index.html")

==================================================
=== ARCHIVO: ./backend/rutas/trading_vista.py ===
==================================================

# backend/rutas/trading_vista.py
### REFACTORIZADO ###

import json # Importamos la librería json
from flask import Blueprint, request, redirect, url_for, render_template, flash
from backend.servicios.trading.procesador import procesar_operacion_trading

bp = Blueprint("trading", __name__)

@bp.route("/trading", methods=["GET"])
def mostrar_trading_page():
    """ SIN CAMBIOS - Renderiza la página de trading. """
    return render_template("trading.html")

@bp.route("/trading/operar", methods=["POST"])
def procesar_trading_form():
    """
    ### REFACTORIZADO ###
    Procesa el formulario y pasa un JSON al sistema de flash en caso de éxito.
    """
    print(">>> DATOS RECIBIDOS DEL FORMULARIO:", request.form)

    ticker_operado = request.form.get("ticker", "BTC").upper()
    
    # Ahora 'mensaje' puede ser un diccionario o un string de error
    exito, mensaje = procesar_operacion_trading(request.form)

    if exito:
        # Si la operación fue exitosa, 'mensaje' es un diccionario.
        # Lo convertimos a un string JSON para guardarlo en la sesión flash.
        flash(json.dumps(mensaje), "success")
    else:
        # Si falló, 'mensaje' ya es un string de error.
        flash(mensaje, "danger")
    
    # La lógica de redirección no cambia.
    redirect_url = url_for("trading.mostrar_trading_page", ticker=ticker_operado)
    return redirect(redirect_url)

==================================================
=== ARCHIVO: ./backend/servicios/__init__.py ===
==================================================

"""
El paquete 'servicios' contiene la lógica de negocio de la aplicación.

Este módulo separa las operaciones complejas, los cálculos y las interacciones
con APIs externas de las capas de acceso a datos y de las vistas (rutas).
Su objetivo es mantener el código organizado, reutilizable y fácil de mantener.
"""

==================================================
=== ARCHIVO: ./backend/servicios/api_cotizaciones.py ===
==================================================

"""
Servicio para interactuar con APIs externas de criptomonedas.

Este módulo centraliza las llamadas a las APIs de CoinGecko (para cotizaciones
generales del mercado) y Binance (para datos de velas/k-lines). Se encarga de
realizar las peticiones, procesar los datos y guardarlos localmente.
"""

from decimal import Decimal
import requests
import json

from backend.acceso_datos.datos_cotizaciones import guardar_datos_cotizaciones
from config import COINGECKO_URL, BINANCE_URL, CANTIDAD_CRIPTOMONEDAS, CANTIDAD_VELAS

def obtener_datos_criptos_coingecko() -> list[dict]:
    """
    Obtiene y procesa datos de mercado desde la API de CoinGecko.

    Realiza una petición para obtener una lista de las principales criptomonedas,
    procesa la respuesta JSON y guarda los datos crudos en un archivo local.
    El formateo para la UI se delega a otra capa de servicio.
    """
    params = {
        "vs_currency": "usd",
        "order": "market_cap_desc",
        "per_page": CANTIDAD_CRIPTOMONEDAS,
        "page": 1,
        "sparkline": "false",
        "price_change_percentage": "1h,24h,7d",
    }

    try:
        respuesta = requests.get(COINGECKO_URL, params, timeout=10)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"❌ Error al obtener datos de CoinGecko: {str(e)}")
        return []

    print(f"✅ Estado de la respuesta CoinGecko: {respuesta.status_code}")

    try:
        datos = respuesta.json()
        resultado = []
        for i, dato in enumerate(datos, start=1):
            resultado.append({
                "id": i,
                "nombre": dato.get("name"),
                "ticker": dato.get('symbol', '').upper(),
                "logo": dato.get("image"),
                "precio_usd": str(Decimal(str(dato.get("current_price", 0)))),
                "1h_%": str(Decimal(str(dato.get("price_change_percentage_1h_in_currency", 0)))),
                "24h_%": str(Decimal(str(dato.get("price_change_percentage_24h_in_currency", 0)))),
                "7d_%": str(Decimal(str(dato.get("price_change_percentage_7d_in_currency", 0)))),
                "market_cap": str(Decimal(str(dato.get("market_cap", 0)))),
                "volumen_24h": str(Decimal(str(dato.get("total_volume", 0)))),
                "circulating_supply": str(Decimal(str(dato.get("circulating_supply", 0)))),
            })
    except (KeyError, TypeError, ValueError, json.JSONDecodeError) as e:
        print(f"❌ Error al procesar los datos de CoinGecko: {str(e)}")
        return []

    print(f"💡 Total de criptos procesadas: {len(resultado)}")
    guardar_datos_cotizaciones(resultado)
    return resultado


def obtener_velas_de_api(ticker: str, interval: str) -> list[dict]:
    """
    Obtiene datos históricos de velas (K-lines) desde la API de Binance.
    """
    params = {
        "symbol": f"{ticker.upper()}USDT",
        "interval": interval,
        "limit": CANTIDAD_VELAS,
    }
    try:
        respuesta = requests.get(BINANCE_URL, params, timeout=10)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"❌ Error al obtener datos de Binance para {ticker} ({interval}): {str(e)}")
        return []

    print(f"✅ Estado de la respuesta Binance para {ticker} ({interval}): {respuesta.status_code}")

    try:
        datos = respuesta.json()
        if not isinstance(datos, list):
            print(f"⚠️ Respuesta inesperada de Binance para {ticker} ({interval}): {datos}")
            return []
        
        resultado = [
            {
                "time": int(vela[0] / 1000), "open": str(Decimal(vela[1])),
                "high": str(Decimal(vela[2])), "low": str(Decimal(vela[3])),
                "close": str(Decimal(vela[4])), "volume": str(Decimal(vela[5])),
            }
            for vela in datos
        ]
        return resultado
    except (json.JSONDecodeError, IndexError, TypeError) as e:
        print(f"❌ Error al procesar los datos de velas de Binance para {ticker}: {e}")
        return []

==================================================
=== ARCHIVO: ./backend/servicios/estado_billetera.py ===
==================================================

# backend/servicios/estado_billetera.py

from decimal import Decimal
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_historial import cargar_historial
# ### LÍNEA CORREGIDA ###
from backend.acceso_datos.datos_cotizaciones import obtener_precio, cargar_datos_cotizaciones
from backend.utils.utilidades_numericas import (
    a_decimal, formato_cantidad_usd, formato_cantidad_cripto, formato_porcentaje
)
from backend.utils.formatters import format_datetime
from config import UMBRAL_POLVO_USD, UMBRAL_CASI_CERO

def _division_segura(numerador: Decimal, denominador: Decimal) -> Decimal:
    return numerador / denominador if denominador > a_decimal(0) else a_decimal(0)

def _preparar_datos_compra(historial: list[dict]) -> dict[str, dict]:
    datos_compra_por_ticker = {}
    for operacion in historial:
        if operacion.get("tipo", "").endswith("compra"):
            destino = operacion.get("destino", {})
            ticker = destino.get("ticker")
            if not ticker or ticker == "USDT": continue
            if ticker not in datos_compra_por_ticker:
                datos_compra_por_ticker[ticker] = {"total_invertido": a_decimal(0), "cantidad_comprada": a_decimal(0)}
            datos_compra_por_ticker[ticker]["total_invertido"] += a_decimal(operacion.get("valor_usd"))
            datos_compra_por_ticker[ticker]["cantidad_comprada"] += a_decimal(destino.get("cantidad"))
    return datos_compra_por_ticker

def _calcular_metricas_activo(ticker: str, cantidad_total: Decimal, precio_actual: Decimal, datos_compra: dict) -> dict:
    valor_actual_usd = cantidad_total * precio_actual
    total_invertido = datos_compra.get("total_invertido", a_decimal(0))
    cantidad_comprada = datos_compra.get("cantidad_comprada", a_decimal(0))
    precio_promedio_compra = _division_segura(total_invertido, cantidad_comprada)
    costo_base_actual = cantidad_total * precio_promedio_compra
    ganancia_o_perdida = valor_actual_usd - costo_base_actual if costo_base_actual > 0 else a_decimal(0)
    porcentaje_ganancia = _division_segura(ganancia_o_perdida, costo_base_actual) * Decimal("100")
    return {
        "ticker": ticker, "cantidad": cantidad_total, "precio_actual": precio_actual,
        "valor_usdt": valor_actual_usd, "precio_promedio_compra": precio_promedio_compra,
        "costo_base_actual": costo_base_actual, "ganancia_perdida": ganancia_o_perdida,
        "porcentaje_ganancia": porcentaje_ganancia,
    }

def _formatear_activo_para_presentacion(activo_calculado: dict, cripto_info: dict, saldos: dict, total_billetera_usd: Decimal) -> dict:
    porcentaje_en_billetera = _division_segura(activo_calculado["valor_usdt"], total_billetera_usd) * Decimal("100")
    es_polvo = activo_calculado["valor_usdt"] < UMBRAL_POLVO_USD

    cantidad_total = activo_calculado["cantidad"]
    saldo_disponible = saldos.get("disponible", a_decimal(0))
    saldo_reservado = saldos.get("reservado", a_decimal(0))

    return {
        "ticker": activo_calculado["ticker"],
        "nombre": cripto_info.get("nombre", activo_calculado["ticker"]),
        "logo": cripto_info.get("logo", ""),
        "es_polvo": es_polvo,
        
        "cantidad_total": str(cantidad_total),
        "cantidad_disponible": str(saldo_disponible),
        "cantidad_reservada": str(saldo_reservado),

        "cantidad_total_formatted": formato_cantidad_cripto(cantidad_total),
        "cantidad_disponible_formatted": formato_cantidad_cripto(saldo_disponible),
        "cantidad_reservada_formatted": formato_cantidad_cripto(saldo_reservado),
        
        "precio_actual_formatted": formato_cantidad_usd(activo_calculado["precio_actual"]),
        "valor_usdt_formatted": formato_cantidad_usd(activo_calculado["valor_usdt"]),
        "ganancia_perdida_formatted": formato_cantidad_usd(activo_calculado["ganancia_perdida"]),
        "ganancia_perdida_cruda": str(activo_calculado["ganancia_perdida"]),
        "porcentaje_ganancia_formatted": formato_porcentaje(activo_calculado["porcentaje_ganancia"]),
        "porcentaje_formatted": formato_porcentaje(porcentaje_en_billetera),
    }

def estado_actual_completo() -> list[dict]:
    billetera = cargar_billetera()
    historial = cargar_historial()
    
    info_criptos = {c['ticker']: c for c in cargar_datos_cotizaciones()}
    
    # ### LA SOLUCIÓN ESTÁ AQUÍ ###
    # Forzamos el nombre y logo canónicos para USDT, ignorando lo que venga de la API.
    # Esto asegura consistencia y evita nombres como "Polygon Bridged USDT".
    info_criptos['USDT'] = {
        'nombre': 'Tether', 
        'logo': 'https://assets.coingecko.com/coins/images/325/large/Tether.png?1696501661',
        'ticker': 'USDT'
    }

    datos_compra_por_ticker = _preparar_datos_compra(historial)
    activos_calculados = []
    
    for ticker, activo_data in billetera.items():
        saldos = activo_data.get("saldos", {})
        cantidad_total = saldos.get("disponible", a_decimal(0)) + saldos.get("reservado", a_decimal(0))

        if cantidad_total < UMBRAL_CASI_CERO:
            continue
            
        # Obtenemos la información de la cripto de nuestro diccionario 'curado'.
        cripto_info_actual = info_criptos.get(ticker, {"nombre": ticker, "logo": ""})

        if ticker == "USDT":
            metricas = {
                "ticker": "USDT", "cantidad": cantidad_total, "precio_actual": a_decimal(1),
                "valor_usdt": cantidad_total, "ganancia_perdida": a_decimal(0),
                "porcentaje_ganancia": a_decimal(0),
            }
        else:
            precio_actual = obtener_precio(ticker) or a_decimal(0)
            datos_compra_activo = datos_compra_por_ticker.get(ticker, {})
            metricas = _calcular_metricas_activo(ticker, cantidad_total, precio_actual, datos_compra_activo)
        
        metricas['cripto_info'] = cripto_info_actual
        metricas['saldos'] = saldos
        activos_calculados.append(metricas)

    activos_calculados.sort(key=lambda x: x['valor_usdt'], reverse=True)
    total_billetera_usd = sum(activo['valor_usdt'] for activo in activos_calculados)

    activos_para_presentacion = [
        _formatear_activo_para_presentacion(activo, activo['cripto_info'], activo['saldos'], total_billetera_usd)
        for activo in activos_calculados
    ]
    return activos_para_presentacion

def obtener_historial_formateado() -> list[dict]:
    historial_crudo = cargar_historial()
    historial_formateado = []
    for item in historial_crudo:
        tipo_op = item.get('tipo', '')
        par_origen = item.get('origen', {}).get('ticker', '?')
        par_destino = item.get('destino', {}).get('ticker', '?')
        cantidad = a_decimal(item.get('destino', {}).get('cantidad')) if tipo_op.endswith('compra') else a_decimal(item.get('origen', {}).get('cantidad'))
        item_formateado = {
            "id": item.get("id"), "tipo": tipo_op,
            "fecha_formatted": format_datetime(item.get('timestamp')),
            "par_formatted": f"{par_destino}/{par_origen}",
            "tipo_formatted": tipo_op.replace('-', ' ').capitalize(),
            "cantidad_formatted": formato_cantidad_cripto(cantidad),
            "valor_total_formatted": formato_cantidad_usd(a_decimal(item.get('valor_usd'))),
        }
        historial_formateado.append(item_formateado)
    return historial_formateado

==================================================
=== ARCHIVO: ./backend/servicios/presentacion_datos.py ===
==================================================

"""
Servicio de Presentación de Datos.

Este módulo se encarga de tomar los datos crudos de la aplicación (como las cotizaciones)
y enriquecerlos con formato y lógica de presentación para ser consumidos directamente
por el frontend. Utiliza el módulo `utilidades_numericas` para todo el formateo numérico.
"""

from backend.acceso_datos.datos_cotizaciones import cargar_datos_cotizaciones
from backend.utils.formatters import get_performance_indicator
from backend.utils.utilidades_numericas import (
    formato_cantidad_usd,
    formato_porcentaje,
    formato_numero_grande,
    a_decimal
)

def obtener_cotizaciones_formateadas() -> list[dict]:
    """
    Carga las cotizaciones crudas y las transforma en una lista de diccionarios
    listos para ser renderizados en el frontend.
    """
    cotizaciones_crudas = cargar_datos_cotizaciones()
    cotizaciones_presentacion = []

    for cripto in cotizaciones_crudas:
        precio_usd = a_decimal(cripto.get("precio_usd"))
        perf_1h = a_decimal(cripto.get("1h_%"))
        perf_24h = a_decimal(cripto.get("24h_%"))
        perf_7d = a_decimal(cripto.get("7d_%"))
        market_cap = a_decimal(cripto.get("market_cap"))
        volumen_24h = a_decimal(cripto.get("volumen_24h"))
        circulating_supply = a_decimal(cripto.get("circulating_supply"))
        ticker = cripto.get("ticker", "")

        cripto_presentacion = {
            "id": cripto.get("id"),
            "nombre": cripto.get("nombre"),
            "ticker": ticker,
            "logo": cripto.get("logo"),

            "precio_usd_formatted": formato_cantidad_usd(precio_usd),
            "market_cap_formatted": formato_numero_grande(market_cap),
            "volumen_24h_formatted": formato_numero_grande(volumen_24h),
            
            "circulating_supply_formatted": (
                f"{circulating_supply:,.0f} {ticker}"
                if circulating_supply > 0
                else "-"
            ),

            "1h_formatted": formato_porcentaje(perf_1h),
            "24h_formatted": formato_porcentaje(perf_24h),
            "7d_formatted": formato_porcentaje(perf_7d),

            "perf_1h": get_performance_indicator(perf_1h),
            "perf_24h": get_performance_indicator(perf_24h),
            "perf_7d": get_performance_indicator(perf_7d),
        }
        cotizaciones_presentacion.append(cripto_presentacion)

    return cotizaciones_presentacion

==================================================
=== ARCHIVO: ./backend/servicios/trading/__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./backend/servicios/trading/ejecutar_orden.py ===
==================================================

from decimal import Decimal
from typing import Dict

from backend.acceso_datos.datos_billetera import guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio, cargar_datos_cotizaciones
from backend.acceso_datos.datos_historial import guardar_en_historial
from backend.acceso_datos.datos_comisiones import registrar_comision
from config import TASA_COMISION
from backend.utils.utilidades_numericas import a_decimal

# --- Funciones Privadas del Módulo ---

def _crear_activo_si_no_existe(billetera: dict, ticker: str):
    """Crea una entrada para un activo en la billetera si no existe."""
    if ticker not in billetera:
        info_criptos = {c['ticker']: c for c in cargar_datos_cotizaciones()}
        info_nueva_moneda = info_criptos.get(ticker, {"nombre": ticker})
        billetera[ticker] = {"nombre": info_nueva_moneda.get("nombre", ticker), "saldos": {"disponible": a_decimal("0"), "reservado": a_decimal("0")}}

# --- Punto de Entrada Público del Módulo ---

def ejecutar_transaccion(
    billetera: Dict,
    moneda_origen: str,
    cantidad_origen_bruta: Decimal,
    moneda_destino: str,
    tipo_operacion_historial: str,
    es_orden_pendiente: bool = False
) -> tuple[bool, dict]:
    """
    ### NUEVO - Función Atómica y Centralizada ###
    Ejecuta una transacción completa: calcula comisión, actualiza saldos,
    registra en historial y devuelve los detalles.
    
    Args:
        billetera: El objeto de la billetera actual.
        moneda_origen: Ticker de la moneda que se gasta.
        cantidad_origen_bruta: Cantidad total que se deduce del origen.
        moneda_destino: Ticker de la moneda que se recibe.
        tipo_operacion_historial: String para guardar en el historial (ej. "Compra", "limit-compra").
        es_orden_pendiente: True si los fondos vienen de 'reservado' en lugar de 'disponible'.

    Returns:
        Una tupla (éxito, diccionario_de_resultados).
    """
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)

    if not all([precio_origen_usdt, precio_destino_usdt, not precio_destino_usdt.is_zero()]):
        return False, {"error": "No se pudo obtener la cotización para ejecutar la transacción."}

    # 1. Calcular comisión y cantidades netas
    cantidad_comision = cantidad_origen_bruta * TASA_COMISION
    cantidad_origen_neta = cantidad_origen_bruta - cantidad_comision
    valor_neto_usd_final = cantidad_origen_neta * precio_origen_usdt
    cantidad_destino_neta_final = valor_neto_usd_final / precio_destino_usdt

    # 2. Actualizar saldos de la billetera
    saldo_a_modificar = "reservado" if es_orden_pendiente else "disponible"
    billetera[moneda_origen]["saldos"][saldo_a_modificar] -= cantidad_origen_bruta
    
    _crear_activo_si_no_existe(billetera, moneda_destino)
    billetera[moneda_destino]["saldos"]["disponible"] += cantidad_destino_neta_final
    
    # 3. Registrar comisión e historial
    registrar_comision(moneda_origen, cantidad_comision, cantidad_comision * precio_origen_usdt)
    guardar_en_historial(
        tipo_operacion_historial,
        moneda_origen,
        cantidad_origen_neta,
        moneda_destino,
        cantidad_destino_neta_final,
        valor_neto_usd_final
    )
    
    # 4. Devolver los detalles de la ejecución
    detalles_ejecucion = {
        "cantidad_destino_final": cantidad_destino_neta_final,
        "cantidad_origen_neta": cantidad_origen_neta,
        "cantidad_comision": cantidad_comision,
        "valor_usd_final": valor_neto_usd_final,
    }
    
    return True, detalles_ejecucion

==================================================
=== ARCHIVO: ./backend/servicios/trading/gestor.py ===
==================================================



from datetime import datetime
from typing import Dict

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes, guardar_ordenes_pendientes
from backend.utils.utilidades_numericas import a_decimal


def cancelar_orden_pendiente(id_orden_a_cancelar: str) -> Dict:
    """
    ### REFACTORIZADO ### - Devuelve un único diccionario de resultados.
    La presencia de la clave 'error' determina el fallo.
    """
    todas_las_ordenes = cargar_ordenes_pendientes()
    orden_encontrada = next((o for o in todas_las_ordenes if o.get("id_orden") == id_orden_a_cancelar), None)
            
    if not orden_encontrada:
        return {"error": f"No se encontró una orden con el ID {id_orden_a_cancelar}."}
    
    if orden_encontrada.get("estado") != "pendiente":
        return {"error": f"La orden {id_orden_a_cancelar} ya no está pendiente y no puede ser cancelada."}

    billetera = cargar_billetera()
    
    moneda_reservada = orden_encontrada["moneda_reservada"]
    cantidad_reservada = a_decimal(orden_encontrada["cantidad_reservada"])
    
    activo_a_liberar = billetera.get(moneda_reservada)

    if not activo_a_liberar or a_decimal(activo_a_liberar["saldos"].get("reservado")) < cantidad_reservada:
        orden_encontrada["estado"] = "error_cancelacion"
        orden_encontrada["mensaje_error"] = "Error de consistencia: los fondos a liberar no se encontraron en la billetera."
        guardar_ordenes_pendientes(todas_las_ordenes)
        return {"error": "Error de consistencia en la billetera. No se pudieron liberar los fondos."}

    activo_a_liberar["saldos"]["reservado"] -= cantidad_reservada
    activo_a_liberar["saldos"]["disponible"] += cantidad_reservada
    
    orden_encontrada.update({
        "estado": "cancelada",
        "timestamp_cancelacion": datetime.now().isoformat()
    })
    
    guardar_billetera(billetera)
    guardar_ordenes_pendientes(todas_las_ordenes)
    
    mensaje_exito = f"Orden {orden_encontrada['par']} cancelada. Se liberaron {formato_cantidad_cripto(cantidad_reservada)} {moneda_reservada}."
    
    return {"mensaje": mensaje_exito, "datos": orden_encontrada}


==================================================
=== ARCHIVO: ./backend/servicios/trading/motor.py ===
==================================================

# backend/servicios/trading/motor.py

from datetime import datetime
from decimal import Decimal

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes, guardar_ordenes_pendientes
from backend.servicios.trading.ejecutar_orden import ejecutar_transaccion
from backend.utils.utilidades_numericas import a_decimal, cuantizar_cripto

def _verificar_condicion_orden(orden: dict, precio_actual: Decimal) -> bool:
    """Verifica si el precio actual cumple la condición de DISPARO (Stop) de la orden."""
    precio_disparo = a_decimal(orden["precio_disparo"])
    tipo_orden = orden.get("tipo_orden", "limit") # Por defecto, 'limit' si no está definido
    
    # Para órdenes Límite
    if tipo_orden == "limit":
        if orden["accion"] == "compra":
            return precio_actual <= precio_disparo
        elif orden["accion"] == "venta":
            return precio_actual >= precio_disparo
            
    # Para órdenes Stop-Limit (antes 'stop-loss')
    elif tipo_orden == "stop-limit":
        # Para una compra stop, queremos comprar cuando el precio SUBE a un nivel.
        if orden["accion"] == "compra":
            return precio_actual >= precio_disparo
        # Para una venta stop, queremos vender cuando el precio CAE a un nivel.
        elif orden["accion"] == "venta":
            return precio_actual <= precio_disparo

    return False

def _ejecutar_orden_pendiente(orden: dict, billetera: dict) -> dict:
    """
    Ejecuta una orden pendiente que ya ha sido disparada,
    con lógica especial para la verificación del precio límite en órdenes Stop-Limit.
    """
    # ### NUEVO: VERIFICACIÓN DEL PRECIO LÍMITE PARA ÓRDENES STOP-LIMIT ###
    if orden.get("tipo_orden") == "stop-limit":
        precio_limite = a_decimal(orden.get("precio_limite"))
        
        # Si no hay precio límite en la orden, es un error de datos.
        if not precio_limite or precio_limite.is_zero():
             print(f"❌ ERROR DE DATOS: Orden Stop-Limit {orden['id_orden']} no tiene precio límite válido.")
             orden["estado"] = "error_datos"
             return billetera
             
        # Obtenemos el precio de mercado actual para la comprobación del límite.
        ticker_base = orden["par"].split('/')[0]
        precio_actual_mercado = obtener_precio(ticker_base)

        if not precio_actual_mercado:
             print(f"⚠️ No se pudo obtener precio para la verificación límite de la orden {orden['id_orden']}. Se reintentará.")
             return billetera # No hacemos nada, esperamos al siguiente ciclo

        # Condición de ejecución para COMPRA LÍMITE (después del stop)
        if orden["accion"] == "compra" and precio_actual_mercado > precio_limite:
            print(f"🚦 ORDEN STOP-LIMIT {orden['id_orden']} DISPARADA, PERO NO EJECUTADA: Precio actual ({precio_actual_mercado}) > Precio Límite ({precio_limite}).")
            return billetera # Se mantiene pendiente hasta que el precio sea favorable
        
        # Condición de ejecución para VENTA LÍMITE (después del stop)
        elif orden["accion"] == "venta" and precio_actual_mercado < precio_limite:
            print(f"🚦 ORDEN STOP-LIMIT {orden['id_orden']} DISPARADA, PERO NO EJECUTADA: Precio actual ({precio_actual_mercado}) < Precio Límite ({precio_limite}).")
            return billetera # Se mantiene pendiente hasta que el precio sea favorable

    # --- Lógica de ejecución de la transacción (común a Limit y Stop-Limit que pasaron el filtro) ---
    moneda_origen = orden["moneda_reservada"]
    cantidad_origen_bruta = a_decimal(orden["cantidad_reservada"])
    # Para una compra, el destino es la cripto principal. Para una venta, el origen es la cripto principal.
    moneda_destino = orden["moneda_destino"] if orden["accion"] == "compra" else orden["moneda_origen"]

    # Aquí es importante determinar correctamente el destino final de la transacción
    # Si es una compra, la moneda destino es la moneda principal del par.
    # Si es una venta, la moneda destino es la moneda cotizada (quote).
    moneda_destino_final = orden["moneda_destino"]

    tipo_op_historial = f"{orden['tipo_orden'].replace('-', ' ').title()} {orden['accion'].title()}"
    
    exito_ejecucion, detalles_ejecucion = ejecutar_transaccion(
        billetera=billetera,
        moneda_origen=moneda_origen,
        cantidad_origen_bruta=cantidad_origen_bruta,
        moneda_destino=moneda_destino_final,
        tipo_operacion_historial=tipo_op_historial,
        es_orden_pendiente=True
    )
    
    if not exito_ejecucion:
        print(f"❌ ERROR al ejecutar orden pendiente {orden['id_orden']}: {detalles_ejecucion.get('error')}")
        orden.update({"estado": "error_ejecucion", "mensaje_error": detalles_ejecucion.get("error")})
        return billetera

    print(f"✅ ORDEN EJECUTADA: {orden['id_orden']} ({orden['par']})")
    orden.update({
        "estado": "ejecutada",
        "timestamp_ejecucion": datetime.now().isoformat(),
        "cantidad_destino_final": str(cuantizar_cripto(detalles_ejecucion["cantidad_destino_final"]))
    })
    
    return billetera

def verificar_y_ejecutar_ordenes_pendientes():
    """Motor principal que itera sobre órdenes pendientes y las ejecuta si cumplen la condición."""
    todas_las_ordenes = cargar_ordenes_pendientes()
    ordenes_activas = [o for o in todas_las_ordenes if o.get("estado") == "pendiente"]
    if not ordenes_activas: 
        return

    billetera = cargar_billetera()
    precios_cacheados = {}
    alguna_orden_ejecutada = False

    for orden in ordenes_activas:
        ticker_principal = orden["par"].split('/')[0]
        if ticker_principal not in precios_cacheados:
            precios_cacheados[ticker_principal] = obtener_precio(ticker_principal)
        
        precio_actual = precios_cacheados[ticker_principal]
        if precio_actual and _verificar_condicion_orden(orden, precio_actual):
            billetera = _ejecutar_orden_pendiente(orden, billetera)
            # Verificamos si la orden cambió de estado
            if orden.get("estado") != "pendiente":
                alguna_orden_ejecutada = True

    if alguna_orden_ejecutada:
        print("💾 Guardando cambios en billetera y lista de órdenes...")
        guardar_billetera(billetera)
        guardar_ordenes_pendientes(todas_las_ordenes)

==================================================
=== ARCHIVO: ./backend/servicios/trading/procesador.py ===
==================================================

# backend/servicios/trading/procesador.py

import uuid
from datetime import datetime
from decimal import Decimal
from typing import Tuple, Dict, Any

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_ordenes import agregar_orden_pendiente
from backend.servicios.trading.ejecutar_orden import ejecutar_transaccion
from backend.utils.utilidades_numericas import (
    a_decimal, cuantizar_cripto, cuantizar_usd, 
    formato_cantidad_cripto, formato_cantidad_usd
)

def _validar_saldo_disponible(billetera: dict, moneda_origen: str, cantidad_requerida: Decimal) -> Tuple[bool, str | None]:
    """Valida si hay suficiente saldo disponible en la billetera."""
    activo = billetera.get(moneda_origen)
    if not activo:
        return False, f"❌ No posees {moneda_origen} en tu billetera."
    saldo_disponible = a_decimal(activo['saldos'].get("disponible"))
    if cantidad_requerida > saldo_disponible:
        return False, f"❌ Saldo insuficiente. Tienes {formato_cantidad_cripto(saldo_disponible)} {moneda_origen} disponibles, pero se requieren {formato_cantidad_cripto(cantidad_requerida)}."
    return True, None

def _calcular_detalles_intercambio(
    accion: str,
    modo_ingreso: str,
    monto_form: Decimal,
    precio_origen_usdt: Decimal,
    precio_destino_usdt: Decimal
) -> Tuple[bool, Dict[str, Any] | str]:
    """
    Función de cálculo pura para un intercambio.
    No modifica estado, solo realiza matemáticas. Devuelve las cantidades brutas.
    """
    if precio_origen_usdt.is_zero() or precio_destino_usdt.is_zero():
        return False, "No se pudo obtener una cotización válida para el par."

    cantidad_origen_bruta = Decimal("0")
    cantidad_destino_bruta = Decimal("0")
    valor_usd = Decimal("0")
    
    if accion == "comprar":
        if modo_ingreso == "monto":
            cantidad_destino_bruta = monto_form
            valor_usd = cantidad_destino_bruta * precio_destino_usdt
            cantidad_origen_bruta = valor_usd / precio_origen_usdt
        elif modo_ingreso == "total":
            cantidad_origen_bruta = monto_form
            valor_usd = cantidad_origen_bruta * precio_origen_usdt
            cantidad_destino_bruta = valor_usd / precio_destino_usdt
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no válido para una compra."
    
    elif accion == "vender":
        if modo_ingreso == "monto":
            cantidad_origen_bruta = monto_form
            valor_usd = cantidad_origen_bruta * precio_origen_usdt
            cantidad_destino_bruta = valor_usd / precio_destino_usdt
        elif modo_ingreso == "total":
            cantidad_destino_bruta = monto_form
            valor_usd = cantidad_destino_bruta * precio_destino_usdt
            cantidad_origen_bruta = valor_usd / precio_origen_usdt
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no válido para una venta."
    
    else:
        return False, f"Acción de trading desconocida: '{accion}'."

    return True, {
        "cantidad_origen_bruta": cantidad_origen_bruta,
        "cantidad_destino_bruta": cantidad_destino_bruta,
        "valor_usd": valor_usd
    }
    
def _ejecutar_orden_mercado(moneda_origen: str, moneda_destino: str, monto_form: Decimal, modo_ingreso: str, accion: str) -> Tuple[bool, Dict[str, Any] | str]:
    """Orquesta la ejecución de una orden a precio de mercado."""
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)
    if not all([precio_origen_usdt, precio_destino_usdt]):
        return False, "❌ No se pudo obtener la cotización para realizar el swap."

    exito_calculo, detalles_brutos = _calcular_detalles_intercambio(accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt)
    if not exito_calculo:
        return False, f"❌ {detalles_brutos}"

    cantidad_origen_bruta = detalles_brutos["cantidad_origen_bruta"]
    billetera = cargar_billetera()
    exito_validacion, mensaje_error = _validar_saldo_disponible(billetera, moneda_origen, cantidad_origen_bruta)
    if not exito_validacion: 
        return False, mensaje_error

    tipo_op_historial = "Compra" if accion == "comprar" else "Venta"
    exito_ejecucion, detalles_ejecucion = ejecutar_transaccion(
        billetera=billetera,
        moneda_origen=moneda_origen,
        cantidad_origen_bruta=cantidad_origen_bruta,
        moneda_destino=moneda_destino,
        tipo_operacion_historial=tipo_op_historial,
        es_orden_pendiente=False
    )

    if not exito_ejecucion:
        return False, detalles_ejecucion.get("error", "Error desconocido durante la ejecución.")

    guardar_billetera(billetera)

    resultado_operacion = {
        "titulo": "Operación de Mercado Exitosa",
        "tipo": "mercado",
        "detalles": {
            "recibiste": {"cantidad": formato_cantidad_cripto(detalles_ejecucion["cantidad_destino_final"]), "ticker": moneda_destino},
            "pagaste": {"cantidad": formato_cantidad_cripto(cantidad_origen_bruta), "ticker": moneda_origen},
            "comision": {"cantidad": formato_cantidad_cripto(detalles_ejecucion["cantidad_comision"]), "ticker": moneda_origen}
        }
    }
    return True, resultado_operacion

def _crear_orden_pendiente(moneda_origen: str, moneda_destino: str, monto_form: Decimal, modo_ingreso: str, precio_disparo: Decimal, tipo_orden: str, accion: str, precio_limite: Decimal | None) -> Tuple[bool, Dict[str, Any] | str]:
    """Crea y guarda una orden pendiente (Límite o Stop-Limit)."""
    billetera = cargar_billetera()
    
    if precio_disparo.is_zero():
        return False, "❌ El precio de disparo no puede ser cero."

    if accion == 'comprar':
        moneda_a_reservar = moneda_origen
        if modo_ingreso == 'monto':
            cantidad_cripto_principal = monto_form
            cantidad_a_reservar = cantidad_cripto_principal * precio_disparo
        elif modo_ingreso == 'total':
            cantidad_a_reservar = monto_form
            cantidad_cripto_principal = cantidad_a_reservar / precio_disparo
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no válido para una compra límite."

    elif accion == 'vender':
        moneda_a_reservar = moneda_origen
        if modo_ingreso == 'monto':
            cantidad_cripto_principal = monto_form
            cantidad_a_reservar = cantidad_cripto_principal
        elif modo_ingreso == 'total':
            precio_destino_usdt = obtener_precio(moneda_destino)
            if not precio_destino_usdt or precio_destino_usdt.is_zero():
                return False, f"❌ No se pudo obtener la cotización actual de {moneda_destino} para calcular la reserva."
            valor_usd_objetivo = monto_form * precio_destino_usdt
            cantidad_cripto_principal = valor_usd_objetivo / precio_disparo
            cantidad_a_reservar = cantidad_cripto_principal
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no válido para una venta límite."
    else:
        return False, f"Acción desconocida: {accion}"

    exito_validacion, mensaje_error = _validar_saldo_disponible(billetera, moneda_a_reservar, cantidad_a_reservar)
    if not exito_validacion: 
        return False, mensaje_error

    billetera[moneda_a_reservar]["saldos"]["disponible"] -= cantidad_a_reservar
    billetera[moneda_a_reservar]["saldos"]["reservado"] += cantidad_a_reservar
    guardar_billetera(billetera)

    nueva_orden = {
        "id_orden": str(uuid.uuid4()),
        "timestamp_creacion": datetime.now().isoformat(),
        "tipo_orden": tipo_orden,
        "accion": accion,
        "par": f"{moneda_origen}/{moneda_destino}", # Correcto: BASE/QUOTE
        "moneda_origen": moneda_origen,
        "moneda_destino": moneda_destino,
        "cantidad_cripto_principal": str(cuantizar_cripto(cantidad_cripto_principal)),
        "precio_disparo": str(cuantizar_usd(precio_disparo)),
        "precio_limite": str(cuantizar_usd(precio_limite)) if precio_limite else None, # ### NUEVO ###
        "cantidad_reservada": str(cuantizar_cripto(cantidad_a_reservar)),
        "moneda_reservada": moneda_a_reservar,
        "estado": "pendiente"
    }
    agregar_orden_pendiente(nueva_orden)
    
    accion_texto = "Compra" if accion == 'comprar' else "Venta"
    ticker_mostrado = moneda_destino if accion == 'comprar' else moneda_origen
    
    resultado_operacion = {
        "titulo": f"Orden {tipo_orden.replace('-', ' ').title()} Creada",
        "tipo": tipo_orden,
        "detalles": {
            "accion": f"{accion_texto} de {formato_cantidad_cripto(cantidad_cripto_principal)} {ticker_mostrado}",
            "precio_disparo": formato_cantidad_usd(precio_disparo)
        }
    }
    return True, resultado_operacion

def procesar_operacion_trading(formulario: dict) -> Tuple[bool, Dict[str, Any] | str]:
    """Punto de entrada principal para procesar una operación desde el formulario."""
    try:
        ticker_principal = formulario["ticker"].upper()
        accion = formulario["accion"]
        monto_form = a_decimal(formulario["monto"])
        modo_ingreso = formulario.get("modo-ingreso", "monto")
        tipo_orden = formulario.get("tipo-orden", "market").lower()
    except (KeyError, ValueError) as e:
        return False, f"❌ Error en los datos del formulario: {e}"

    if monto_form <= a_decimal(0): return False, "❌ El monto debe ser un número positivo."

    moneda_origen, moneda_destino = (formulario.get("moneda-pago", "USDT").upper(), ticker_principal) if accion == "comprar" else (ticker_principal, formulario.get("moneda-recibir", "USDT").upper())
    if moneda_origen == moneda_destino: return False, "❌ La moneda de origen y destino no pueden ser la misma."

    if tipo_orden == "market":
        return _ejecutar_orden_mercado(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion)
    
    elif tipo_orden in ["limit", "stop-limit"]:
        try:
            precio_disparo = a_decimal(formulario.get("precio_disparo"))
            if precio_disparo <= a_decimal(0): 
                return False, "❌ Se requiere un precio de disparo válido y positivo."
            
            precio_limite = None
            if tipo_orden == 'stop-limit':
                precio_limite = a_decimal(formulario.get("precio_limite"))
                if precio_limite <= a_decimal(0):
                    return False, "❌ Se requiere un precio límite válido y positivo para una orden Stop-Limit."

        except (KeyError, ValueError, TypeError):
            return False, "❌ Precio de disparo o límite inválido o faltante."
        
        return _crear_orden_pendiente(moneda_origen, moneda_destino, monto_form, modo_ingreso, precio_disparo, tipo_orden, accion, precio_limite)
    
    return False, f"❌ Tipo de orden desconocido: '{tipo_orden}'."

==================================================
=== ARCHIVO: ./backend/utils/formatters.py ===
==================================================

"""
Utilidades de formateo para la presentación de datos no numéricos.

Este módulo proporciona un conjunto de funciones reutilizables para dar formato a
diversos tipos de datos como fechas y otros indicadores de UI.
La lógica de formateo numérico se ha movido a `utils.number_utils`.
"""

from datetime import datetime
from decimal import Decimal
from typing import Union


def get_performance_indicator(value: Union[str, Decimal]) -> dict:
    """
    Analiza un valor de rendimiento y devuelve un diccionario con la clase CSS y
    el símbolo de flecha correspondiente.

    Args:
        value (Union[str, Decimal]): El valor de rendimiento.

    Returns:
        dict: Un diccionario con las claves 'className' y 'arrow'.
    """
    try:
        valor_decimal = Decimal(str(value))
        if valor_decimal >= 0:
            return {"className": "positivo", "arrow": "▲"}
        return {"className": "negativo", "arrow": "▼"}
    except (ValueError, TypeError, InvalidOperation):
        return {"className": "", "arrow": ""}


def format_datetime(timestamp: Union[int, float, str]) -> str:
    """
    Formatea un timestamp o un string ISO a una fecha y hora local.

    Maneja tanto timestamps numéricos (segundos desde la época) como strings
    de fecha en formato ISO 8601.

    Args:
        timestamp: El timestamp o string a formatear.

    Returns:
        La fecha y hora formateada. Ej: "21/06/2024 15:45:12".
    """
    if not timestamp:
        return "--:--"
    
    try:
        if isinstance(timestamp, (int, float)):
            dt_object = datetime.fromtimestamp(timestamp)
        elif isinstance(timestamp, str):
            dt_object = datetime.fromisoformat(timestamp)
        else:
            return "--:--"
            
        return dt_object.strftime("%d/%m/%Y %H:%M:%S")
    except (ValueError, TypeError):
        return "--:--"

==================================================
=== ARCHIVO: ./backend/utils/utilidades_numericas.py ===
==================================================

"""
Módulo de Utilidades Numéricas.

Este módulo centraliza todas las operaciones relacionadas con la manipulación
de números en la aplicación, especialmente para garantizar la consistencia
y precisión al trabajar con la librería `Decimal`.

Funciones:
- Conversión segura a `Decimal`.
- Cuantización a precisiones estándar (cripto, USD).
- Formateo para presentación en el frontend.
"""

from decimal import Decimal, InvalidOperation

from config import PRECISION_CRIPTOMONEDA, PRECISION_USD


def a_decimal(valor) -> Decimal:
    """
    Convierte de forma segura un valor a un objeto Decimal.

    Maneja diferentes tipos de entrada (int, float, str, None) y valores
    inválidos, devolviendo siempre Decimal('0') en caso de error o entrada nula.

    Args:
        valor: El valor a convertir.

    Returns:
        Un objeto Decimal.
    """
    if valor is None:
        return Decimal("0")
    try:
        # Convertir a string primero es la forma más segura de crear un Decimal,
        # especialmente desde un float, para evitar imprecisiones binarias.
        return Decimal(str(valor))
    except (InvalidOperation, TypeError, ValueError):
        return Decimal("0")

def cuantizar_cripto(valor: Decimal) -> Decimal:
    """
    Cuantiza un valor Decimal a la precisión estándar para criptomonedas.

    Args:
        valor: El objeto Decimal a cuantizar.

    Returns:
        El valor Decimal cuantizado a 8 decimales.
    """
    return valor.quantize(PRECISION_CRIPTOMONEDA)

def cuantizar_usd(valor: Decimal) -> Decimal:
    """
    Cuantiza un valor Decimal a la precisión estándar para USD.

    Args:
        valor: El objeto Decimal a cuantizar.

    Returns:
        El valor Decimal cuantizado a 2 o 4 decimales, según config.
    """
    return valor.quantize(PRECISION_USD)


# --- Funciones de Formateo para Presentación ---

def formato_cantidad_cripto(valor: Decimal) -> str:
    """
    Formatea una cantidad de criptomoneda como string con 8 decimales.

    Args:
        valor (Decimal): La cantidad a formatear.

    Returns:
        La cantidad formateada como string. Ej: "0.12345678".
    """
    return f"{cuantizar_cripto(valor):.8f}"

def formato_cantidad_usd(valor: Decimal, simbolo: str = "$") -> str:
    """
    Formatea un valor monetario en USD con 2 decimales y separadores de miles.

    Args:
        valor (Decimal): El valor a formatear.
        simbolo (str, optional): Símbolo de la moneda. Por defecto es "$".

    Returns:
        El valor formateado. Ej: "$1,234.56".
    """
    # La cantidad de decimales en la f-string debe coincidir con la precisión en config.py
    # Decimal('0.0001'), usa .4f.
    decimales = abs(PRECISION_USD.as_tuple().exponent)
    return f"{simbolo}{cuantizar_usd(valor):,.{decimales}f}"

def formato_numero_grande(valor: Decimal, simbolo: str = "$") -> str:
    """
    Formatea números grandes con abreviaturas (M, B, T).

    Args:
        valor (Decimal): El número a formatear.
        simbolo (str, optional): Símbolo a prefijar. Por defecto es "$".

    Returns:
        El número formateado como string. Ej: "$1.25M", "$2.5B".
    """
    numero = a_decimal(valor)

    if numero >= 1_000_000_000_000:
        return f"{simbolo}{(numero / Decimal('1e12')).quantize(Decimal('0.01'))}T"
    if numero >= 1_000_000_000:
        return f"{simbolo}{(numero / Decimal('1e9')).quantize(Decimal('0.01'))}B"
    if numero >= 1_000_000:
        return f"{simbolo}{(numero / Decimal('1e6')).quantize(Decimal('0.01'))}M"
    return f"{simbolo}{numero:,.0f}"

def formato_porcentaje(valor: Decimal) -> str:
    """
    Formatea un número como un porcentaje con dos decimales.

    Args:
        valor (Decimal): El número a formatear.

    Returns:
        El número como string de porcentaje. Ej: "25.45%".
    """
    return f"{a_decimal(valor):.2f}%"

==================================================
=== ARCHIVO: ./config.py ===
==================================================

# config.py
### MODIFICADO ###

import os
from decimal import getcontext, ROUND_HALF_DOWN, Decimal
from dotenv import load_dotenv

# Cargar variables de entorno desde el archivo .env
load_dotenv()

# Base del proyecto y carpeta de datos
PROYECTO_DIR = os.path.dirname(os.path.abspath(__file__))
BASE_DATA_DIR = os.path.join(PROYECTO_DIR, "datos")
os.makedirs(BASE_DATA_DIR, exist_ok=True)

# Rutas de archivos JSON
COTIZACIONES_PATH = os.path.join(BASE_DATA_DIR, "cotizaciones.json")
BILLETERA_PATH = os.path.join(BASE_DATA_DIR, "billetera.json")
HISTORIAL_PATH = os.path.join(BASE_DATA_DIR, "historial.json")
VELAS_PATH = os.path.join(BASE_DATA_DIR, "velas.json")
COMISIONES_PATH = os.path.join(BASE_DATA_DIR, "comisiones.json")
ORDENES_PENDIENTES_PATH = os.path.join(BASE_DATA_DIR, "ordenes_pendientes.json")

# Configuración inicial de los USDT con los cuales inicializa la app
BALANCE_INICIAL_USDT = "10000"

# Comisión por trade
TASA_COMISION = Decimal("0.005")  # 0.5% de comisión

# Clave secreta para Flask
FLASK_SECRET_KEY = os.getenv("FLASK_SECRET_KEY", "clave_por_defecto_insegura")

# URLs de APIs
COINGECKO_URL = "https://api.coingecko.com/api/v3/coins/markets"
BINANCE_URL = "https://api.binance.com/api/v3/klines"

# Parámetros de scraping
CANTIDAD_CRIPTOMONEDAS = 100
CANTIDAD_VELAS = 250

# --- CONFIGURACIÓN NUMÉRICA GLOBAL --- ### NUEVO ###
# Precisión para los cálculos intermedios de la librería Decimal
getcontext().prec = 28
getcontext().rounding = ROUND_HALF_DOWN

# Precisión estándar para el almacenamiento y la visualización
# de cantidades de criptomonedas (8 decimales)
PRECISION_CRIPTOMONEDA = Decimal("0.00000001")

# Precisión de decimales 4 para valores en USD
PRECISION_USD = Decimal("0.0001")

# Umbrales para la lógica de "polvo" (saldos pequeños)
UMBRAL_POLVO_USD = Decimal("0.01") # Valor en USD por debajo del cual se considera polvo
UMBRAL_CASI_CERO = Decimal("0.00000001") # Cantidad por debajo de la cual se considera cero para ciertas validaciones

==================================================
=== ARCHIVO: ./documentacion.md ===
==================================================

¡Excelente! Ahora que has completado la refactorización, es el momento perfecto para dar un paso atrás y consolidar el conocimiento sobre la nueva arquitectura. Has transformado tu proyecto en un sistema mucho más robusto y profesional.

Basándome en el código finalizado y en la estructura de tu `documentacion.md`, he preparado una explicación actualizada y detallada de la arquitectura y las responsabilidades de cada componente.

---

### **Diagrama de Arquitectura Actualizado: "BlocX - Simulador de Exchange"**

Este diagrama refleja la nueva estructura, destacando la especialización dentro del paquete de servicios de trading.

```
+-----------------------------------------------------------------------------------------------------------------------+
|                                                  NAVEGADOR DEL USUARIO                                                |
|      - Renderiza HTML/CSS, ejecuta JS.                                                                                |
|      - Envía acciones del usuario (formularios, clics) al Backend.                                                    |
|      - Muestra notificaciones de SweetAlert2 construidas desde datos JSON.                                            |
+------------------------------------------+--------------------------------------------------+-------------------------+
                                           |                                                  |                         ^
 (1) Petición inicial (GET /trading)       | (16) Muestra UI actualizada                      | (3) Sirve HTML inicial  |
                                           |      con datos de la API                         |                         |
                                           v                                                  |                         |
+------------------------------------------+--------------------------------------------------+-------------------------+
|                                                      FRONTEND (Cliente)                                               |
|                                            (Se ejecuta completamente en el navegador)                                   |
|-----------------------------------------------------------------------------------------------------------------------|
| HTML: /templates/                                                                                                     |
|  - _flashes.html: Componente JS-HTML que parsea JSON y renderiza notificaciones.                                       |
|                                                                                                                       |
| JS: /static/js/                                                                                                       |
|                                                                                                                       |
|  (4) Inicia lógica (pages/tradingPage.js)  (14) Recibe JSON, actualiza DOM     (18) Muestra Toast/Popup                  |
|            +                                     |                                     ^                               |
|            |     +-----------------------------+ v                                     |                               |
|            +---> |   pages/*.js                | --(15) Llama a componentes--->+---------------------------------+    |
|                  |   - Orquesta la página.     |                               |    components/*.js              |    |
|                  |   - Llama a servicios.      |                               |    (uiUpdater, chartRenderer)   |    |
|                  +------------+----------------+                               +------------------^--------------+    |
|                               | (5, 17) Solicita datos a API                                      |                  |
|                               v                                                                                     |
|                  +-----------------------------+  (13) Devuelve JSON          +------------------------------------+  |
|                  |  services/apiService.js     | <--------------------------+ |  services/appState.js              |  |
|                  |  - Centraliza llamadas      |                              |  - Gestiona el estado global (JS)  |  |
|                  |    fetch() al backend.      |                              |                                    |  |
|                  +-----------------------------+                              +------------------------------------+  |
|                               | (6) Petición HTTP (POST /trading/operar, POST /api/orden/cancelar/...)                 |
+-------------------------------v-------------------------------------------------------------------------------------+
                                | (A) Recibe POST /trading/operar                                                       (2) Sirve HTML
                                | (B) Recibe POST /api/orden/cancelar/...                                               (vía render_template)
                                | (C) Recibe GET /api/actualizar
+-------------------------------v-------------------------------------------------------------------------------------+
|                                                       BACKEND (Servidor)                                            |
|                                                 (Aplicación Flask - Python)                                         |
|---------------------------------------------------------------------------------------------------------------------|
| __init__.py -> app.py                                                                                               |
| - Inicia la app Flask y registra las rutas.                                                                         |
|                                                                                                                     |
| +-----------------------------------------------------------------------------------------------------------------+ |
| |                                            RUTAS (Capa de Vistas)                                               | |
| | /rutas/*.py (trading_vista.py, billetera_vista.py, api_externa.py)                                              | |
| | - Definen los endpoints (URL).                                                                                  | |
| | - (A, B, C) Delegan la lógica a la capa de Servicios.                                                           | |
| | - Devuelven JSON (para /api/...) o HTML (para rutas base).                                                      | |
| +--------------------------------------------------------+--+-----------------------------------------------------+ |
|                                                          |  |  (C.1) Llama a motor                                  |
|                                     (A.1) Llama a procesador |  (B.1) Llama a gestor                                |
|                                                          v  v                                                      |
| +--------------------------------------------------------+--+-----------------------------------------------------+ |
| |                                     SERVICIOS (Capa de Lógica de Negocio)                                       | |
| | /servicios/*.py (estado_billetera.py, api_cotizaciones.py)                                                      | |
| |                                                                                                                 | |
| | +-------------------------------------------------------------------------------------------------------------+ | |
| | |                                            /servicios/trading/                                              | | |
| | | - procesador.py: El "Recepcionista". Valida y CREA órdenes.                                                 | | |
| | | - motor.py: El "Vigilante". VERIFICA condiciones de órdenes pendientes.                                     | | |
| | | - gestor.py: El "Administrador". GESTIONA órdenes existentes (ej. cancelar).                               | | |
| | | - ejecutor.py: El "Brazo Ejecutor". EJECUTA la transacción atómica (comisión, saldos, historial).          | | |
| | +---------------------------------------------------------+---------------------------------------------------+ | |
| |                                                           | (D) Llama a ejecutor para completar la transacción    |
| +-----------------------------------------------------------v-----------------------------------------------------+ |
|                                                             | (E) Pide/guarda datos crudos                          |
|                                                             v                                                       |
| +-----------------------------------------------------------+-----------------------------------------------------+ |
| |                              ACCESO A DATOS (Capa de Persistencia)                                              | |
| | /acceso_datos/*.py (datos_billetera.py, datos_ordenes.py, etc.)                                                 | |
| | - Leen y escriben en los archivos .json.                                                                        | |
| | - Abstraen el manejo de archivos.                                                                               | |
| +---------------------+-------------------------------------+-----------------------------------------------------+ |
|                       |                                     |                                                       |
|             (F) Lee/Escribe                                 | (G) Lee/Escribe                                       |
|                       v                                     v                                                       |
| +---------------------+---------+  +------------------------+-------+  +--------------------------+  +----------------+
| | billetera.json, historial.json|  | ordenes_pendientes.json        |  | cotizaciones.json        |  | comisiones.json|
| +-------------------------------+  +--------------------------------+  +--------------------------+  +----------------+
+---------------------------------------------------------------------------------------------------------------------+

```

### **Glosario de Componentes y Responsabilidades Actualizado**

Aquí desglosamos qué hace cada parte del sistema en su estado actual y refactorizado.

#### **1. Backend (`/backend`)**

Es el cerebro del sistema. Su única responsabilidad es gestionar la lógica de negocio y exponer los datos a través de una API que habla en JSON. **No sabe ni le importa cómo se ve la página web.**

*   **Rutas (`/rutas`)**: Son los **"Controladores de Tráfico"**.
    *   **Responsabilidad**: Definen las URLs (endpoints) que el frontend puede llamar. Reciben las peticiones HTTP, validan los parámetros más básicos y delegan inmediatamente el trabajo a la capa de Servicios.
    *   **Ejemplo**: `trading_vista.py` recibe el `POST` del formulario de trading, pero no sabe qué es una orden de mercado; simplemente llama a `procesar_operacion_trading()` en el servicio correspondiente. Luego, toma la respuesta (un diccionario o un error) y la formatea como JSON o la pasa al sistema de `flash`.

*   **Acceso a Datos (`/acceso_datos`)**: Son los **"Bibliotecarios"**.
    *   **Responsabilidad**: Son los únicos que saben leer y escribir en los archivos `.json`. Aíslan al resto de la aplicación del "cómo" se guardan los datos. Si mañana decidieras cambiar de archivos JSON a una base de datos en memoria, solo tendrías que modificar esta capa.
    *   **Ejemplo**: `datos_billetera.py` tiene las funciones `cargar_billetera()` y `guardar_billetera()`. Nadie más en la aplicación toca `billetera.json` directamente.

*   **Servicios (`/servicios`)**: Es el **"Núcleo del Negocio"**. Aquí reside toda la inteligencia de la aplicación.
    *   **Responsabilidad**: Orquestar la lógica de negocio, realizar cálculos complejos, interactuar con APIs externas y preparar los datos para ser consumidos.
    *   **Ejemplo**: `estado_billetera.py` toma los datos crudos de la billetera y el historial (pedidos a `acceso_datos`), los cruza con los precios actuales y calcula el valor del portafolio, las ganancias/pérdidas, etc.
    *   **Subpaquete `servicios/trading/` (La Lógica de Trading Refactorizada)**: Este es el corazón de tu sistema y ahora tiene responsabilidades muy bien definidas:
        *   **`procesador.py` - El "Recepcionista"**: Es el punto de entrada para cualquier *intención de trading* que provenga de un usuario. Su trabajo es validar los datos de un formulario y **CREAR** una orden (ya sea para ejecución inmediata o para ponerla en espera).
        *   **`motor.py` - El "Vigilante del Mercado"**: Es un proceso *automatizado*. Su única misión es **VERIFICAR** periódicamente si alguna de las órdenes pendientes cumple las condiciones del mercado para ser ejecutada. No ejecuta nada por sí mismo; si una orden se debe disparar, le pasa la posta al `ejecutor`.
        *   **`gestor.py` - El "Administrador de Órdenes"**: Se encarga de **GESTIONAR** las órdenes que ya existen pero que no están siendo ejecutadas. Su principal función hoy es `cancelar_orden_pendiente`.
        *   **`ejecutor.py` - El "Brazo Ejecutor" o "Notario"**: Es la pieza más crítica y centralizada. Contiene la función `ejecutar_transaccion()`, que realiza una **transacción atómica**. Su única responsabilidad es tomar los detalles de una operación y **EJECUTARLA**: calcular la comisión, modificar los saldos, y registrarla en el historial. Es llamado tanto por el `procesador` (para órdenes de mercado) como por el `motor` (para órdenes pendientes).

#### **2. Frontend (`/frontend`)**

Es la cara visible de la aplicación. Es un cliente completamente dinámico que se ejecuta en el navegador.

*   **Templates (`/templates`)**: Son los **"Esqueletos HTML"**.
    *   **Responsabilidad**: Proveer la estructura HTML inicial de cada página. Son deliberadamente simples.
    *   **Ejemplo**: `trading.html` contiene los `divs` y `table` vacíos que actuarán como contenedores. `_flashes.html` es ahora un componente "inteligente" que ya no contiene HTML, sino un script que sabe cómo construir el HTML de la notificación a partir de los datos JSON que recibe.

*   **JS - Services (`/js/services`)**: Son los **"Módulos de Soporte"** del frontend.
    *   **Responsabilidad**: Proporcionar funcionalidades reutilizables para el resto del código JavaScript.
    *   **`apiService.js`**: El "Embajador". Centraliza todas las llamadas `fetch` a la API del backend.
    *   **`appState.js`**: El "Estado Global del Cliente". Guarda en memoria (del navegador) los datos que vienen de la API (como la lista de monedas o el estado de la billetera) para que otros componentes puedan acceder a ellos sin tener que pedirlos de nuevo.

*   **JS - Components (`/js/components`)**: Son los **"Especialistas de la UI"**.
    *   **Responsabilidad**: Cada módulo se encarga de una parte muy específica de la interfaz de usuario.
    *   **Ejemplo**: `chartRenderer.js` solo sabe de gráficos. `uiUpdater.js` solo sabe cómo cambiar el texto de las etiquetas o el color de los botones.

*   **JS - Pages (`/js/pages`)**: Son los **"Directores de Orquesta"** de cada página.
    *   **Responsabilidad**: Es el punto de entrada para la lógica de una página específica. Cuando se carga `trading.html`, `tradingPage.js` se ejecuta y comienza a orquestar todo: llama a `apiService` para traer los datos, los guarda en `appState` y luego usa los `components` para llenar la página con esa información.

#### **3. Persistencia (`/datos/*.json`)**

Son la **"Base de Datos"** de tu proyecto.
*   **Responsabilidad**: Almacenar el estado de la aplicación (la billetera, las órdenes, el historial) de forma que los datos persistan incluso si el servidor se reinicia. Son la "única fuente de verdad" del sistema.
*   



¡Excelente pregunta! Seguir el flujo de una operación de principio a fin es la mejor manera de entender cómo todas las piezas del sistema encajan. Aquí tienes el recorrido detallado, paso a paso, sin asumir nada, desde que abres el navegador hasta que la compra se concreta.

### **Escenario: Comprar $100 de BTC a Precio de Mercado**

---

#### **Fase 1: Carga Inicial de la Página de Trading**

1.  **Paso 1: Abrir el Navegador**
    *   Escribes `http://127.0.0.1:5000/` en tu navegador y presionas Enter. Por defecto, Flask te redirigirá (o la ruta `/` ya apunta) a la página de cotizaciones (`index.html`). Haces clic en el enlace "Trading" en la barra de navegación. La URL cambia a `http://127.0.0.1:5000/trading`.

2.  **Paso 2: Petición HTTP al Backend (GET)**
    *   Tu navegador envía una petición `GET` al servidor Flask, solicitando el recurso en la ruta `/trading`.

3.  **Paso 3: El Backend Responde (Capa de Rutas)**
    *   Flask recibe la petición. El archivo `backend/rutas/trading_vista.py` tiene una función `mostrar_trading_page()` asociada a la ruta `/trading`.
    *   Esta función ejecuta `render_template("trading.html")`. Flask toma este archivo de plantilla, lo procesa (incluyendo el `_flashes.html`, que en este punto no tiene mensajes) y lo devuelve al navegador como una respuesta HTML.

4.  **Paso 4: El Frontend Cobra Vida (HTML y JS)**
    *   El navegador recibe el archivo HTML. Es un "esqueleto": contiene la estructura, los `divs` para el gráfico, el formulario y las tablas, pero están casi todos vacíos o con mensajes de "Cargando...".
    *   El navegador parsea el HTML y, al final, encuentra la línea `<script type="module" src=".../tradingPage.js"></script>`. Inmediatamente, descarga y ejecuta este archivo JavaScript.

5.  **Paso 5: Orquestación del Frontend (`tradingPage.js`)**
    *   Se ejecuta la función `initialize()` dentro de `tradingPage.js`.
    *   Esta función es el "director de orquesta". Sabe que necesita muchos datos para llenar la página, así que usa `Promise.all` para hacer varias peticiones a la API del backend de forma concurrente, a través de las funciones en `apiService.js`:
        *   `fetchCotizaciones()` -> `GET /api/cotizaciones`
        *   `fetchEstadoBilletera()` -> `GET /api/billetera/estado-completo`
        *   `fetchHistorial()` -> `GET /api/historial`
        *   `fetchOrdenesAbiertas()` -> `GET /api/ordenes-abiertas`
        *   `fetchVelas('BTC', '1d')` -> `GET /api/velas/BTC/1d` (asumiendo BTC como default)

6.  **Paso 6: El Backend Sirve los Datos (Servicios y Acceso a Datos)**
    *   Para cada una de esas peticiones GET, el backend realiza un ciclo:
        *   La **Ruta** (ej. `api_externa.py`) recibe la petición.
        *   Llama al **Servicio** correspondiente (ej. `presentacion_datos.py` o `estado_billetera.py`).
        *   El **Servicio** pide los datos crudos a la capa de **Acceso a Datos** (ej. `datos_cotizaciones.py` lee `cotizaciones.json`).
        *   El **Servicio** procesa, calcula y formatea los datos.
        *   La **Ruta** toma los datos procesados y los devuelve como una respuesta JSON.

7.  **Paso 7: El Frontend Renderiza la Página**
    *   De vuelta en `tradingPage.js`, las promesas de `Promise.all` se resuelven. El script ahora tiene todos los datos que necesita.
    *   Guarda estos datos en el estado global del cliente (`AppState.js`).
    *   Llama a los componentes "especialistas":
        *   `UIUpdater.renderHistorial()` para construir la tabla de historial.
        *   `initializeChart()` para dibujar el gráfico de velas.
        *   `actualizarFormularioUI()` para rellenar los selectores de criptomonedas y mostrar tu saldo inicial de USDT.
    *   **Resultado visual**: La página está completamente cargada. Ves el gráfico de BTC, el formulario de trading y tus saldos.

---

#### **Fase 2: Interacción del Usuario y Envío del Formulario**

8.  **Paso 8: Configurar la Operación**
    *   En el formulario de trading, seleccionas "BTC" (si no estaba ya por defecto).
    *   El modo "Comprar" está activado por defecto.
    *   El tipo de orden "Mercado" está activado por defecto.
    *   Seleccionas el modo de ingreso "Total (USDT)". El script `tradingPage.js` detecta este cambio (`radioModoIngreso.on('change', ...)` ) y, a través de `UIUpdater.js`, actualiza la etiqueta del campo de monto a "Total (USDT)".
    *   En el campo de monto, escribes `100`.

9.  **Paso 9: Confirmar la Compra**
    *   Haces clic en el botón "COMPRAR".
    *   Esto dispara el evento `submit` del formulario `<form id="formulario-trading" ...>`.

10. **Paso 10: Petición HTTP al Backend (POST)**
    *   El navegador empaqueta todos los datos del formulario (ticker: 'BTC', accion: 'comprar', tipo-orden: 'market', modo-ingreso: 'total', monto: '100', moneda-pago: 'USDT') y envía una petición `POST` a la URL especificada en el `action` del formulario: `/trading/operar`.

---

#### **Fase 3: Procesamiento de la Operación en el Backend**

11. **Paso 11: La Ruta Recibe la Petición**
    *   Flask recibe el `POST`. La función `procesar_trading_form()` en `backend/rutas/trading_vista.py` se ejecuta.

12. **Paso 12: Delegación al Servicio Procesador**
    *   La ruta no sabe cómo procesar un trade. Delega inmediatamente todo el trabajo llamando a `procesar_operacion_trading(request.form)` en `backend/servicios/trading/procesador.py`.

13. **Paso 13: El Procesador Analiza la Orden**
    *   `procesar_operacion_trading` recibe el diccionario del formulario.
    *   Valida los datos: el monto es positivo, las monedas de origen (USDT) y destino (BTC) no son la misma.
    *   Detecta que `tipo_orden` es "market", por lo que llama a su función auxiliar `_ejecutar_orden_mercado(...)`.

14. **Paso 14: Orquestación de la Orden de Mercado**
    *   `_ejecutar_orden_mercado` comienza su trabajo:
        a.  Llama a `obtener_precio('USDT')` y `obtener_precio('BTC')` desde `datos_cotizaciones.py`. Supongamos que BTC está a $50,000.
        b.  Llama a su función de cálculo pura: `_calcular_detalles_intercambio('comprar', 'total', 100, 1, 50000)`. Esta función devuelve `{ "cantidad_origen_bruta": 100, "cantidad_destino_bruta": 0.002, ... }`.
        c.  Carga tu billetera actual usando `cargar_billetera()`.
        d.  Valida si tienes saldo suficiente con `_validar_saldo_disponible(billetera, 'USDT', 100)`. Como tienes $10,000 iniciales, la validación es exitosa.

15. **Paso 15: La Ejecución Atómica**
    *   Ahora, `_ejecutar_orden_mercado` tiene todo lo que necesita. Llama a la función centralizada `ejecutar_transaccion()` del módulo `ejecutor.py`, pasándole todos los detalles.
    *   Dentro de `ejecutar_transaccion()`:
        a.  **Cálculo de Comisión**: `cantidad_comision = 100 (USDT) * 0.005 = 0.5 USDT`.
        b.  **Cálculo Neto**: La cantidad neta de origen que se usará para el intercambio es `100 - 0.5 = 99.5 USDT`.
        c.  **Cálculo Final**: La cantidad final de BTC que recibirás es `99.5 / 50000 = 0.00199 BTC`.
        d.  **Modificación de Billetera (en memoria)**:
            *   Resta 100 del saldo `disponible` de USDT.
            *   Suma 0.00199 al saldo `disponible` de BTC.
        e.  **Registro de Comisión**: Llama a `registrar_comision()` en `datos_comisiones.py`, que abre `comisiones.json` y añade la nueva línea.
        f.  **Registro de Historial**: Llama a `guardar_en_historial()` en `datos_historial.py`, que abre `historial.json` y añade el registro de la compra.
        g.  Devuelve un diccionario con los detalles de la ejecución a `_ejecutar_orden_mercado`.

16. **Paso 16: Finalización y Respuesta**
    *   `_ejecutar_orden_mercado` recibe la confirmación de éxito del ejecutor.
    *   Llama a `guardar_billetera(billetera)`, que abre `billetera.json` y **sobrescribe el archivo completo** con los nuevos saldos.
    *   Construye el diccionario de respuesta final para el frontend: `{"titulo": "Operación de Mercado Exitosa", "tipo": "mercado", "detalles": {...}}`.
    *   Este diccionario se devuelve a `procesar_operacion_trading`.
    *   `procesar_operacion_trading` lo devuelve a la ruta `procesar_trading_form`.

---

#### **Fase 4: Redirección y Notificación al Usuario**

17. **Paso 17: El Sistema de "Flashes" de Flask**
    *   La ruta `procesar_trading_form` tiene la tupla `(True, diccionario_resultado)`.
    *   Como fue exitosa, convierte el diccionario a un string JSON usando `json.dumps()`.
    *   Llama a `flash(json_string, "success")`. Flask guarda este mensaje en una cookie de sesión temporal.
    *   Finalmente, ejecuta `return redirect(url_for('trading.mostrar_trading_page', ticker='BTC'))`.

18. **Paso 18: Nueva Petición y Renderizado**
    *   El navegador recibe la respuesta de redirección (código 302). Inmediatamente hace una **nueva petición `GET`** a `http://127.0.0.1:5000/trading?ticker=BTC`.
    *   El ciclo de carga de la página (Pasos 3 a 7) se repite. La página se carga de nuevo desde cero, pero esta vez, cuando `render_template` procesa `_flashes.html`, detecta que hay un mensaje en la sesión.

19. **Paso 19: Notificación en el Frontend**
    *   El script dentro de `_flashes.html` se ejecuta.
    *   Parsea el string JSON del mensaje flash de vuelta a un objeto JavaScript.
    *   Llama a la función `buildFlashMessageHTML()` para construir el HTML de la notificación.
    *   Usa `Toast.fire()` de SweetAlert2 para mostrar una notificación emergente en la esquina superior derecha con el resumen de la operación: "Recibiste: 0.00199000 BTC", "Pagaste: 100.00000000 USDT", etc.

20. **Paso 20: Visualización del Estado Actualizado**
    *   Como la página se recargó, las llamadas a la API en el `initialize()` de `tradingPage.js` traen los datos actualizados.
    *   La llamada a `fetchEstadoBilletera()` ahora devolverá un estado de billetera que incluye BTC.
    *   La llamada a `fetchHistorial()` incluirá la nueva transacción.
    *   El frontend renderiza las tablas con la información nueva. **Ya tienes oficialmente tus $100 (menos comisión) en BTC.**

¡Y así concluye el ciclo completo de una operación! Cada capa tiene una responsabilidad clara, y el flujo de datos entre el cliente y el servidor es predecible y robusto.

==================================================
=== ARCHIVO: ./frontend/static/css/styles_index.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030;
    color: #f0c000;
}

.logo-cripto {
    margin-right: 1.5rem;
    vertical-align: middle;
}

.nombre-cripto {
    padding-left: 0.75rem;
    font-weight: bold;
    font-size: 1.05rem;
}

.logo-cripto {
    margin-right: 10px;
    vertical-align: middle;
}

.ticker-cripto {
    color: #aaaaaa;
    font-size: 0.85rem;
    margin-left: 4px;
}

table thead th {
    font-size: 0.85rem;
    font-weight: 500;
    text-transform: uppercase;
}

td,
th {
    white-space: nowrap;
}

/* PRECIO */
table td:nth-child(3),
table th:nth-child(3) {
    min-width: 100px;
    font-weight: bold;
}
table td:nth-child(4),
table th:nth-child(4),
table td:nth-child(5),
table th:nth-child(5),
table td:nth-child(6),
table th:nth-child(6) {
    min-width: 80px; /* 1H, 24H, 7D */
}
table td:nth-child(8),
table th:nth-child(8),
table td:nth-child(9),
table th:nth-child(9) {
    min-width: 100px; /* VOLUME, SUPPLY */
}

/* Limita el ancho de la columna Name (columna 2) */
table td:nth-child(2),
table th:nth-child(2) {
    max-width: 220px; /* probá ajustar este valor */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.positivo {
    color: var(--color-verde);
    font-weight: 500;
}

.negativo {
    color: var(--color-rojo);
    font-weight: 500;
}

.flecha-verde,
.flecha-roja {
    font-size: 0.7em; /* más pequeño que el texto base */
    vertical-align: middle;
    margin-right: 4px;
}

.flecha-verde {
    color: var(--color-verde);
    margin-right: 4px;
}

.flecha-roja {
    color: var(--color-rojo);
    margin-right: 4px;
}


==================================================
=== ARCHIVO: ./frontend/static/css/styles_trading.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
    --color-azul-activo: #0d6efd; /* Azul de Bootstrap para botones activos */
    --color-fondo-base: #343a40; /* Un gris oscuro para fondos de input/select */
    --color-borde: #6c757d; /* Un gris más claro para bordes */
    --color-texto: #f8f9fa; /* Texto casi blanco */
    --border-radius-suave: 0.375rem; /* El radio de borde por defecto de Bootstrap */
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #1e1e1e !important; /* Un fondo un poco más oscuro que antes */
    color: #f0c000;
}

#chart {
    display: block;
    overflow: hidden;
    width: 100%;
    max-width: 100%;
    min-height: 500px;
}

/* --- ESTILOS UNIFICADOS PARA EL FORMULARIO --- */

/* Estilo base para todos los controles de formulario */
.form-control,
.form-select,
.select2-container--bootstrap-5 .select2-selection {
    background-color: var(--color-fondo-base) !important;
    color: var(--color-texto) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave) !important;
    box-shadow: none !important; /* Eliminar sombras por defecto */
}

/* Placeholder text color */
.form-control::placeholder {
    color: #999;
}

/* Estilo para los grupos de botones (Tipo de orden, Ingresar por, Timeframes) */
.btn-group .btn-outline-primary,
.btn-group .btn-outline-secondary {
    color: var(--color-texto);
    border-color: var(--color-borde);
}

/* Estilo para el botón ACTIVO en los grupos */
.btn-group .btn-check:checked + .btn-outline-primary,
.btn-group .btn.active {
    background-color: var(--color-azul-activo);
    border-color: var(--color-azul-activo);
    color: var(--color-texto);
}
.btn-group .timeframe-btn.active {
    background-color: var(--color-azul-activo) !important;
    border-color: var(--color-azul-activo) !important;
}

/* --- ESTILOS PERSONALIZADOS PARA SELECT2 --- */

/* Contenedor principal de Select2 */
.select2-container--bootstrap-5 .select2-selection {
    height: calc(1.5em + 0.75rem + 2px); /* Altura estándar de Bootstrap */
    padding: 0.375rem 0.75rem;
    line-height: 1.5;
}

/* Flecha del dropdown de Select2 */
.select2-container--bootstrap-5 .select2-selection__arrow b {
    border-color: var(--color-texto) transparent transparent transparent !important;
}

/* Estilos para el Dropdown (la lista que se abre) */
.select2-dropdown {
    background-color: var(--color-fondo-base) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave) !important;
}

/* Campo de búsqueda dentro del dropdown */
.select2-search__field {
    background-color: #495057 !important;
    color: var(--color-texto) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave);
}

/* Opciones de la lista */
.select2-results__option {
    color: var(--color-texto) !important;
}

/* Opción seleccionada actualmente en la lista */
.select2-results__option--selected {
    background-color: #5a6268 !important;
}

/* Opción bajo el cursor del ratón (hover) */
.select2-results__option--highlighted {
    background-color: var(--color-azul-activo) !important;
    color: var(--color-texto) !important;
}

/* --- LÓGICA DE BOTONES DE COMPRA/VENTA (SIN CAMBIOS DE LÓGICA, SÓLO ESTÉTICA) --- */
.boton-comprar.active {
    background-color: var(--color-verde) !important;
    border-color: var(--color-verde) !important;
}
.boton-vender.active {
    background-color: var(--color-rojo) !important;
    border-color: var(--color-rojo) !important;
}
.btn-outline-secondary {
    background-color: transparent;
    border-color: var(--color-borde);
}
.btn-outline-secondary:hover {
    background-color: var(--color-fondo-base);
}

/* --- OVERLAY DE ERROR (SIN CAMBIOS) --- */
.chart-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(30, 30, 30, 0.85);
    color: #f0c000;
    font-size: 1.2rem;
    font-weight: 500;
    text-align: center;
    padding: 20px;
    z-index: 10;
    border-radius: 8px;
    transition: opacity 0.3s ease-in-out;
}

.select2-container--bootstrap-5 .select2-selection--single .select2-selection__rendered,
.form-control::placeholder {
    color: var(--color-texto) !important;
}


.custom-toast-position {
    margin-top: 60px;
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/chartRenderer.js ===
==================================================

/**
 * @module chartRenderer
 * @description Gestiona la creación, inicialización y actualización del gráfico financiero
 * de velas utilizando la biblioteca Lightweight Charts™.
 * Este módulo es responsable de todas las interacciones directas con la instancia del gráfico.
 */

// Variables globales para mantener las instancias del gráfico y sus series.
let chart;
let candleSeries;
let volumeSeries;

/**
 * @typedef {object} CandleData
 * @property {string} time - Marca de tiempo en formato 'YYYY-MM-DD'.
 * @property {number} open - Precio de apertura.
 * @property {number} high - Precio máximo.
 * @property {number} low - Precio mínimo.
 * @property {number} close - Precio de cierre.
 * @property {number} volume - Volumen de la operación.
 */

/**
 * Crea e inicializa el gráfico de velas en la primera carga.
 * Configura la apariencia del gráfico, añade las series de velas y volumen,
 * y establece los listeners de eventos para la interactividad.
 *
 * @param {CandleData[]} initialData - El conjunto de datos inicial de velas para mostrar.
 * @side-effects Manipula el DOM para crear el gráfico dentro del elemento '#chart'.
 *               También adjunta un ResizeObserver para manejar el redimensionamiento responsivo.
 */
export function initializeChart(initialData) {
    const chartContainer = document.getElementById('chart');
    if (!chartContainer) {
        console.warn("Elemento #chart no encontrado. No se puede renderizar el gráfico.");
        return;
    }
    if (!window.LightweightCharts) {
        console.error("La biblioteca LightweightCharts no está cargada.");
        return;
    }

    // Crea la instancia principal del gráfico con estilos personalizados.
    chart = window.LightweightCharts.createChart(chartContainer, {
        width: chartContainer.clientWidth,
        height: 500,
        layout: { textColor: '#ccc', background: { type: 'solid', color: '#1E1E1E' } },
        grid: { vertLines: { color: '#2B2B2B' }, horzLines: { color: '#2B2B2B' } },
        priceScale: { borderColor: '#485c7b' },
        timeScale: { borderColor: '#485c7b' },
    });

    // Añade la serie principal de velas para la acción del precio.
    candleSeries = chart.addCandlestickSeries({
        upColor: 'rgb(31, 191, 113)',
        downColor: 'rgb(226, 33, 52)',
        borderDownColor: 'rgb(226, 33, 52)',
        borderUpColor: 'rgb(31, 191, 113)',
        wickDownColor: '#838ca1',
        wickUpColor: '#838ca1',
    });

    // Añade una serie secundaria de histograma para el volumen de operaciones.
    volumeSeries = chart.addHistogramSeries({
        priceFormat: { type: 'volume' },
        priceScaleId: '', // Se adjunta a una escala de precios separada.
    });
    // Ajusta la escala de precios de la serie de volumen para darle más espacio.
    volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });

    if (initialData && initialData.length > 0) {
        updateChartData(initialData);
    }

    // Añade un listener de eventos al checkbox para alternar la visibilidad del volumen.
    const volumeCheckbox = document.getElementById('toggleVolume');
    if (volumeCheckbox) {
        volumeCheckbox.addEventListener('change', (e) => {
            volumeSeries.applyOptions({ visible: e.target.checked });
        });
    }

    // Asegura que el gráfico se ajuste a su contenido y sea responsivo.
    chart.timeScale().fitContent();
    new ResizeObserver(() => chart.applyOptions({ width: chartContainer.clientWidth })).observe(chartContainer);
}

/**
 * Actualiza el gráfico con un nuevo conjunto de datos de velas.
 * Maneja tanto el caso en que hay datos disponibles como en el que no, mostrando
 * u ocultando un mensaje de error superpuesto según corresponda.
 *
 * @param {CandleData[]} data - El nuevo array de datos de velas. Si el array está vacío
 *        o es nulo, limpia el gráfico y muestra un mensaje de error.
 */
export function updateChartData(data) {
    if (!candleSeries || !volumeSeries) {
        console.warn("El gráfico no está inicializado. No se pueden actualizar los datos.");
        return;
    }

    const errorOverlay = document.getElementById('chart-error-overlay');

    if (data && data.length > 0) {
        // Oculta el mensaje de error si hay datos disponibles.
        errorOverlay.style.display = 'none';

        // Mapea los datos brutos al formato requerido por Lightweight Charts.
        const candleData = data.map(item => ({
            time: item.time,
            open: Number(item.open),
            high: Number(item.high),
            low: Number(item.low),
            close: Number(item.close)
        }));
        const volumeData = data.map(item => ({
            time: item.time,
            value: Number(item.volume),
            color: Number(item.close) > Number(item.open) ? 'rgba(31, 191, 113, 0.5)' : 'rgba(226, 33, 52, 0.5)'
        }));

        console.log(`📊 Actualizando gráfico con ${data.length} velas.`);
        candleSeries.setData(candleData);
        volumeSeries.setData(volumeData);
    } else {
        // Si no hay datos disponibles, limpia las series y muestra el overlay de error.
        console.log("📊 No hay datos de velas disponibles. Mostrando mensaje de error.");
        candleSeries.setData([]);
        volumeSeries.setData([]);
        errorOverlay.style.display = 'flex'; // Se usa 'flex' para que coincida con el centrado del CSS.
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/domElements.js ===
==================================================

/**
 * @module DOMElements
 * @description Centraliza las referencias a los elementos del DOM a los que se accede con frecuencia.
 * Este patrón mejora el rendimiento al cachear los objetos jQuery, evitando consultas
 * redundantes al DOM y facilitando el mantenimiento del código.
 */

/**
 * Un objeto que contiene referencias cacheadas de jQuery a los elementos del DOM
 * utilizados en la interfaz de trading.
 * @type {Object<string, JQuery>}
 */
export const DOMElements = {
    // Contenedor principal del formulario de trading
    form: $('#formulario-trading'),
    // Selector principal de criptomonedas (ej. BTC, ETH)
    selectorPrincipal: $('#cripto'),
    // Desplegable para seleccionar la moneda de pago (en una compra)
    selectorPagarCon: $('#moneda-pago'),
    // Desplegable para seleccionar la moneda a recibir (en una venta)
    selectorRecibirEn: $('#moneda-recibir'),
    // Botón de acción 'Comprar'
    botonComprar: $('.boton-comprar'),
    // Botón de acción 'Vender'
    botonVender: $('.boton-vender'),
    // Botón final 'Confirmar' para la transacción
    botonConfirmar: $('.boton-confirmar'),
    // Input oculto que almacena la acción actual ('comprar' o 'vender')
    inputAccion: $('#accion'),
    // Contenedor para el desplegable 'Pagar con'
    campoPagarCon: $('#campo-pagar-con'),
    // Contenedor para el desplegable 'Recibir en'
    campoRecibirEn: $('#campo-recibir-en'),
    // Span para mostrar el saldo disponible del usuario
    spanSaldoDisponible: $('#saldo-disponible'),
    // Botones de radio para cambiar entre modos de ingreso ('monto' vs 'total')
    radioModoIngreso: $('input[name="modo-ingreso"]'),
    // Etiqueta para el botón de radio 'Cantidad (Cripto)'
    labelModoMonto: $('#label-modo-monto'),
    // Etiqueta para el campo de entrada de monto
    labelMonto: $('label[for="monto"]'),
    // Campo de entrada principal para el monto
    inputMonto: $('#monto'),
    // Etiqueta para el botón de radio 'Cantidad (Cripto)'
    labelModoMonto: $('#label-modo-monto'),
    // Etiqueta para el botón de radio 'Total (USDT)'
    labelModoTotal: $('#label-modo-total'),
};


==================================================
=== ARCHIVO: ./frontend/static/js/components/formLogic.js ===
==================================================

// frontend/static/js/components/formLogic.js

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';
import { AppState } from '../services/appState.js';

export const FormLogic = {
    /**
     * Rellena un elemento <select> con una lista de opciones, SIN disparar eventos.
     */
    popularSelector(selector, lista, placeholderVacio = 'No hay opciones') {
        selector.empty();

        if (!lista || lista.length === 0) {
            selector.append(new Option(placeholderVacio, '')).prop('disabled', true);
            return;
        }

        selector.prop('disabled', false);
        lista.forEach(({ ticker, nombre }) => selector.append(new Option(`${nombre} (${ticker})`, ticker)));
    },

    /**
     * Orquesta la actualización de todos los selectores del formulario.
     */
    actualizarOpcionesDeSelectores() {
        const esCompra = UIState.esModoCompra();
        const tickerPrincipal = UIState.getTickerPrincipal();
        
        const allCryptos = AppState.getAllCryptos();
        const ownedCoins = AppState.getOwnedCoins();

        if (esCompra) {
            const opcionesPagarCon = ownedCoins.filter(c => c.ticker !== tickerPrincipal);
            FormLogic.popularSelector(DOMElements.selectorPagarCon, opcionesPagarCon, 'No tienes fondos');
            // Establecemos el valor por defecto para 'Pagar con' sin disparar el change todavía
            DOMElements.selectorPagarCon.val('USDT');

        } else {
            const opcionesRecibirEn = allCryptos.filter(c => c.ticker !== tickerPrincipal);
            FormLogic.popularSelector(DOMElements.selectorRecibirEn, opcionesRecibirEn);
            // Establecemos el valor por defecto para 'Recibir en'
            DOMElements.selectorRecibirEn.val('USDT');
        }
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/tablaCotizacionesUI.js ===
==================================================

/**
 * @module tablaCotizacionesUI
 * @description Controla la renderización y actualización de la tabla de cotizaciones de criptomonedas.
 */

import { fetchCotizaciones } from '../services/apiService.js';
import { UIUpdater } from './uiUpdater.js';

const cuerpoTabla = document.getElementById('tabla-datos');

/**
 * @typedef {object} CotizacionPresentacion
 * @property {string} logo - URL del logo de la criptomoneda.
 * @property {string} nombre - Nombre de la criptomoneda.
 * @property {string} ticker - Símbolo de la criptomoneda.
 * @property {string} precio_usd_formatted - Precio formateado en USD.
 * @property {string} '1h_formatted' - Variación porcentual formateada (1h).
 * @property {string} '24h_formatted' - Variación porcentual formateada (24h).
 * @property {string} '7d_formatted' - Variación porcentual formateada (7d).
 * @property {object} perf_1h - Objeto con {className, arrow} para rendimiento 1h.
 * @property {object} perf_24h - Objeto con {className, arrow} para rendimiento 24h.
 * @property {object} perf_7d - Objeto con {className, arrow} para rendimiento 7d.
 * @property {string} market_cap_formatted - Capitalización de mercado formateada.
 * @property {string} volumen_24h_formatted - Volumen de 24h formateado.
 * @property {string} circulating_supply_formatted - Suministro circulante formateado.
 */

/**
 * Crea el HTML para una fila de la tabla de cotizaciones a partir de datos ya procesados.
 *
 * @private
 * @param {CotizacionPresentacion} cripto - El objeto de datos de la criptomoneda, ya formateado por el backend.
 * @param {number} index - El número de fila (índice + 1).
 * @returns {string} Una cadena de texto con el HTML del `<tr>` para la criptomoneda.
 */
function createFilaCotizacionHTML(cripto, index) {
    return `
        <tr>
            <td class="text-start px-3">${index}</td>
            <td class="text-start px-3">
                <img src="${cripto.logo}" width="20" class="logo-cripto" alt="${cripto.ticker} logo">
                <span class="nombre-cripto">${cripto.nombre}</span>
                <span class="ticker-cripto">(${cripto.ticker})</span>
            </td>
            <td class="text-start px-3 fw-bold">${cripto.precio_usd_formatted}</td>
            
            <td class="text-end px-3">
                <span class="${cripto.perf_1h.className}">
                    <span class="flecha">${cripto.perf_1h.arrow}</span>
                    ${cripto['1h_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${cripto.perf_24h.className}">
                    <span class="flecha">${cripto.perf_24h.arrow}</span>
                    ${cripto['24h_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${cripto.perf_7d.className}">
                    <span class="flecha">${cripto.perf_7d.arrow}</span>
                    ${cripto['7d_formatted']}
                </span>
            </td>
            
            <td class="text-end px-3">${cripto.market_cap_formatted}</td>
            <td class="text-end px-3">${cripto.volumen_24h_formatted}</td>
            <td class="text-end px-3">${cripto.circulating_supply_formatted}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de cotizaciones y renderiza la tabla en el DOM.
 * Si no hay cotizaciones, la tabla simplemente se mostrará vacía.
 * @async
 * @side-effects Modifica el `innerHTML` del elemento '#tabla-datos'.
 *               Puede mostrar un mensaje de error si la carga de datos falla.
 */
export async function renderTabla() {
    if (!cuerpoTabla) return;
    try {
        const cotizaciones = (await fetchCotizaciones()) || [];
        cuerpoTabla.innerHTML = cotizaciones
            .map((cripto, index) => createFilaCotizacionHTML(cripto, index + 1))
            .join('');
    } catch (error) {
        console.error('❌ Error al renderizar la tabla de cotizaciones:', error);
        UIUpdater.mostrarMensajeError(
            'No se pudieron cargar las cotizaciones. La información puede estar desactualizada.'
        );
        cuerpoTabla.innerHTML =
            '<tr><td colspan="9" class="text-center text-danger py-4">Error al cargar las cotizaciones.</td></tr>';
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiState.js ===
==================================================

/**
 * @module uiState
 * @description Proporciona un objeto centralizado para consultar el estado actual de la interfaz de usuario.
 * Este módulo abstrae la lógica de acceso a los valores de los elementos del DOM, facilitando
 * la obtención de información sobre el estado de la UI sin interactuar directamente con `DOMElements`.
 */

import { DOMElements } from './domElements.js';

/**
 * @description Un objeto que agrupa funciones para obtener diferentes aspectos del estado de la UI.
 * Cada método consulta un elemento del DOM a través de `DOMElements` y devuelve su estado actual.
 * @exports UIState
 */
export const UIState = {
    /**
     * Comprueba si el modo de operación actual es 'comprar'.
     * @returns {boolean} `true` si la acción seleccionada es 'comprar', de lo contrario `false`.
     */
    esModoCompra() {
        return DOMElements.inputAccion.val() === 'comprar';
    },

    /**
     * Obtiene el modo de ingreso seleccionado (ej. 'cantidad' o 'monto').
     * @returns {string} El valor del radio button seleccionado para el modo de ingreso.
     */
    getModoIngreso() {
        return DOMElements.radioModoIngreso.filter(':checked').val();
    },

    /**
     * Obtiene el ticker de la criptomoneda principal seleccionada.
     * @returns {string} El ticker de la criptomoneda en el selector principal.
     */
    getTickerPrincipal() {
        return DOMElements.selectorPrincipal.val();
    },

    /**
     * Obtiene el ticker de la moneda utilizada para pagar.
     * @returns {string} El ticker de la moneda en el selector 'pagar con'.
     */
    getTickerPago() {
        return DOMElements.selectorPagarCon.val();
    },

    /**
     * Obtiene el ticker de la moneda que se recibirá.
     * @returns {string} El ticker de la moneda en el selector 'recibir en'.
     */
    getTickerRecibo() {
        return DOMElements.selectorRecibirEn.val();
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiUpdater.js ===
==================================================

/**
 * @module uiUpdater
 * @description Centraliza todas las funciones que actualizan dinámicamente la interfaz de usuario.
 * Este módulo es responsable de cambiar la apariencia y el contenido de los elementos del DOM
 * en respuesta a las acciones del usuario y los datos de la aplicación.
 */

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';
import { AppState } from '../services/appState.js';


export const UIUpdater = {
    actualizarBotones() {
        const esCompra = UIState.esModoCompra();
        DOMElements.botonConfirmar
            .text(esCompra ? 'COMPRAR' : 'VENDER')
            .toggleClass('btn-success', esCompra)
            .toggleClass('btn-danger', !esCompra);
        DOMElements.botonComprar
            .toggleClass('active btn-success', esCompra)
            .toggleClass('btn-outline-secondary', !esCompra);
        DOMElements.botonVender
            .toggleClass('active btn-danger', !esCompra)
            .toggleClass('btn-outline-secondary', esCompra);
    },

    actualizarVisibilidadCampos() {
        const esCompra = UIState.esModoCompra();
        DOMElements.campoPagarCon.toggle(esCompra);
        DOMElements.campoRecibirEn.toggle(!esCompra);
        DOMElements.selectorPagarCon.prop('disabled', !esCompra);
        DOMElements.selectorRecibirEn.prop('disabled', esCompra);
    },

    actualizarLabelMonto() {
        const esModoMonto = UIState.getModoIngreso() === 'monto';
        const esCompra = UIState.esModoCompra();
        let tickerRelevante = '';

        if (esCompra) {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerPago();
        } else {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerRecibo();
        }

        const etiqueta = esModoMonto ? 'Cantidad' : 'Total';
        DOMElements.labelMonto.text(`${etiqueta} (${tickerRelevante || '...'})`);
    },

    actualizarLabelsModoIngreso() {
        const tickerPrincipal = UIState.getTickerPrincipal();
        let tickerSecundario;

        if (UIState.esModoCompra()) {
            // Si compramos, el "Total" se refiere a la moneda con la que pagamos.
            tickerSecundario = UIState.getTickerPago();
        } else {
            // Si vendemos, el "Total" se refiere a la moneda que recibimos.
            tickerSecundario = UIState.getTickerRecibo();
        }
        
        // El modo "Cantidad" siempre se refiere a la criptomoneda principal de la operación.
        DOMElements.labelModoMonto.text(`Cantidad (${tickerPrincipal || 'Cripto'})`);
        
        // El modo "Total" se refiere a la otra moneda del par.
        DOMElements.labelModoTotal.text(`Total (${tickerSecundario || 'USDT'})`);
    },

    mostrarSaldo(ticker) {
        if (!ticker) {
            DOMElements.spanSaldoDisponible.text('--');
            return;
        }

        // Usamos AppState en lugar de 'window'
        const moneda = AppState.getOwnedCoinByTicker(ticker);
        // Usamos 'cantidad_formatted' para mostrar, que ya viene del backend y es más preciso.
        // Además, nos aseguramos de que el saldo mostrado sea el DISPONIBLE.
        const saldoFormateado = moneda ? moneda.cantidad_formatted : '0.00000000';
        const tickerMostrado = moneda ? moneda.ticker : ticker;
        DOMElements.spanSaldoDisponible.text(`${saldoFormateado} ${tickerMostrado}`);
    },
    
    setInputMonto(valor) {
        DOMElements.inputMonto.val(valor);
    },

    renderHistorial(historialData) {
        const tablaHistorial = $('#tabla-historial');
        if (!tablaHistorial.length) return;

        if (historialData.length === 0) {
            tablaHistorial.html(
                '<tr><td colspan="5" class="text-center text-muted py-3">No hay transacciones en el historial.</td></tr>'
            );
            return;
        }

        const historialHTML = historialData
            .map((item) => {
                const claseTipo = item.tipo.toLowerCase() === 'compra' ? 'text-success' : 'text-danger';

                return `
                <tr>
                    <td class="text-start ps-3">${item.fecha_formatted}</td>
                    <td class="fw-bold">${item.par_formatted}</td>
                    <td class="${claseTipo}">${item.tipo_formatted}</td>
                    <td>${item.cantidad_formatted}</td>
                    <td>${item.valor_total_formatted}</td>
                </tr>
            `;
            })
            .join('');

        tablaHistorial.html(historialHTML);
    },

    mostrarMensajeError(mensaje, containerSelector = '#error-container') {
        const errorContainer = $(containerSelector);
        if (!errorContainer.length) {
            console.error(`Error container '${containerSelector}' not found.`);
            return;
        }
        const alertHTML = `
            <div class="alert alert-danger alert-dismissible fade show" role="alert">
                ${mensaje}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        `;
        errorContainer.html(alertHTML);
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/pages/billeteraPage.js ===
==================================================

/**
 * @module pages/billeteraPage
 * @description Orquesta la inicialización y la lógica principal de la página de la billetera.
 */

import { fetchEstadoBilletera, fetchComisiones } from '../services/apiService.js';
import { UIUpdater } from '../components/uiUpdater.js';

/**
 * @typedef {object} ActivoBilletera
 * @property {string} ticker - El símbolo de la criptomoneda.
 * @property {boolean} es_polvo - Indica si la cantidad es considerada "polvo".
 * @property {string} ganancia_perdida_cruda - El valor numérico de la ganancia o pérdida (como string).
 * @property {string} cantidad_formatted - La cantidad formateada.
 * @property {string} precio_actual_formatted - El precio actual formateado.
 * @property {string} valor_usdt_formatted - El valor total en USDT formateado.
 * @property {string} ganancia_perdida_formatted - La ganancia o pérdida formateada.
 * @property {string} porcentaje_ganancia_formatted - El porcentaje de G/P formateado.
 * @property {string} porcentaje_formatted - El % que representa en la billetera.
 */

/**
 * Crea una fila HTML (`<tr>`) para la tabla de la billetera.
 * @param {ActivoBilletera} cripto - El objeto que contiene los datos del activo.
 * @returns {string} Una cadena de texto con el HTML de la fila de la tabla.
 */
function createBilleteraRowHTML(cripto) {
    const colorGanancia = parseFloat(cripto.ganancia_perdida_cruda) >= 0 ? 'text-success' : 'text-danger';
    const claseFila = cripto.es_polvo ? 'fila-polvo' : '';
    const reservadoClase = parseFloat(cripto.cantidad_reservada) > 0 ? 'text-warning' : '';

    return `
        <tr class="${claseFila}">
            <td class="text-start ps-3">
                <img src="${cripto.logo}" width="24" class="me-3" style="vertical-align: middle;" alt="${cripto.ticker} logo">
                <span class="fw-bold fs-6">${cripto.nombre}</span>
                <span class="text-white-50 ms-2">(${cripto.ticker})</span>
            </td>
            <td class="text-end pe-3">${cripto.cantidad_total_formatted}</td>
            <td class="text-end pe-3">${cripto.cantidad_disponible_formatted}</td>
            <td class="text-end pe-3 ${reservadoClase}">${cripto.cantidad_reservada_formatted}</td>
            <td class="text-end pe-3">${cripto.precio_actual_formatted}</td>
            <td class="text-end pe-3 fw-bold">${cripto.valor_usdt_formatted}</td>
            <td class="text-end pe-3 ${colorGanancia}">${cripto.ganancia_perdida_formatted}</td>
            <td class="text-end pe-3 ${colorGanancia}">${cripto.porcentaje_ganancia_formatted}</td>
            <td class="text-end pe-3">${cripto.porcentaje_formatted}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de la billetera desde la API y los renderiza en la tabla.
 */
async function renderBilletera() {
    const cuerpoTabla = document.getElementById('tabla-billetera');
    if (!cuerpoTabla) {
        console.warn("El elemento #tabla-billetera no fue encontrado en el DOM.");
        return;
    }

    try {
        const datosBilletera = await fetchEstadoBilletera();
        if (!datosBilletera || datosBilletera.length === 0) {
            cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-muted py-4">Tu billetera está vacía.</td></tr>';
        } else {
            cuerpoTabla.innerHTML = datosBilletera.map(createBilleteraRowHTML).join('');
        }
    } catch (error) {
        console.error('Error al renderizar la billetera:', error);
        UIUpdater.mostrarMensajeError('No se pudieron cargar los datos de la billetera.');
        cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-danger py-4">Error al cargar los datos.</td></tr>';
    }
}

/**
 * Crea una fila HTML para la tabla de historial de comisiones.
 * @param {object} comision - El objeto de datos de la comisión.
 * @returns {string} Una cadena de texto con el HTML de la fila.
 */
function createComisionRowHTML(comision) {
    const fecha = new Date(comision.timestamp).toLocaleString('es-AR', {
        day: '2-digit', month: '2-digit', year: 'numeric',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
    });

    return `
        <tr>
            <td>${fecha}</td>
            <td>${comision.ticker}</td>
            <td>${parseFloat(comision.cantidad).toFixed(8)}</td>
            <td>$${parseFloat(comision.valor_usd).toFixed(2)}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de comisiones desde la API y los renderiza en la tabla.
 */
async function renderComisiones() {
    const cuerpoTabla = document.getElementById('tabla-comisiones');
    if (!cuerpoTabla) {
        console.warn("El elemento #tabla-comisiones no fue encontrado en el DOM.");
        return;
    }

    try {
        const datosComisiones = await fetchComisiones();
        if (!datosComisiones || datosComisiones.length === 0) {
            cuerpoTabla.innerHTML = '<tr><td colspan="4" class="text-center text-muted py-3">No se han cobrado comisiones.</td></tr>';
        } else {
            cuerpoTabla.innerHTML = datosComisiones.map(createComisionRowHTML).join('');
        }
    } catch (error) {
        console.error('Error al renderizar las comisiones:', error);
        cuerpoTabla.innerHTML = '<tr><td colspan="4" class="text-center text-danger py-4">Error al cargar las comisiones.</td></tr>';
    }
}

/**
 * ### NUEVO: Configura la lógica para el switch de ocultar polvo.
 */
function setupEventListeners() {
    const switchOcultarPolvo = document.getElementById('ocultar-polvo-switch');
    if (switchOcultarPolvo) {
        switchOcultarPolvo.addEventListener('change', (event) => {
            const filasPolvo = document.querySelectorAll('.fila-polvo');
            const estaActivado = event.target.checked;
            
            filasPolvo.forEach(fila => {
                // Ocultamos la fila si el switch está activado, la mostramos si no.
                fila.style.display = estaActivado ? 'none' : 'table-row';
            });
        });
    }
}


/**
 * Listener que se ejecuta cuando el DOM está completamente cargado.
 */
document.addEventListener('DOMContentLoaded', () => {
    console.log("Página de Billetera cargada. Obteniendo datos...");
    
    // Promise.all espera a que ambas funciones de renderizado terminen.
    Promise.all([
        renderBilletera(),
        renderComisiones()
    ]).then(() => {
        // Una vez que las tablas están renderizadas, configuramos los event listeners.
        setupEventListeners();
    });
});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/indexPage.js ===
==================================================

/**
 * @module pages/indexPage
 * @description Lógica para la página principal de cotizaciones.
 * Se encarga de inicializar y gestionar la actualización periódica de la tabla de cotizaciones.
 */

import { triggerActualizacionDatos } from '../services/apiService.js';
import { renderTabla } from '../components/tablaCotizacionesUI.js';

/**
 * @const {number} UPDATE_INTERVAL_MS
 * @description Intervalo en milisegundos para la actualización automática de la tabla de cotizaciones.
 * @default 15000
 */
const UPDATE_INTERVAL_MS = 15000; // 15 segundos

/**
 * Orquesta el ciclo completo de actualización de datos y renderizado de la tabla.
 * Primero, solicita al backend que actualice sus datos desde la fuente externa.
 * Una vez completado, renderiza la tabla de cotizaciones con la información más reciente.
 * @async
 * @function actualizarYRenderizar
 * @throws {Error} Si alguna de las operaciones (actualización o renderizado) falla.
 */
async function actualizarYRenderizar() {
    console.log("Iniciando ciclo de actualización de cotizaciones...");
    try {
        await triggerActualizacionDatos();
        await renderTabla();
        console.log("Tabla de cotizaciones actualizada exitosamente.");
    } catch (error) {
        console.error("Falló el ciclo de actualización de la tabla de cotizaciones:", error);
    }
}

/**
 * @description Listener que se ejecuta cuando el DOM está completamente cargado.
 * Verifica si la tabla de cotizaciones existe en la página actual y, si es así,
 * inicia el ciclo de actualización inmediata y periódica.
 * @event DOMContentLoaded
 */
document.addEventListener('DOMContentLoaded', () => {
    // Asegurarse de que el script solo se ejecute en la página correcta.
    if (document.getElementById('tabla-datos')) {
        console.log("Página de cotizaciones detectada. Iniciando actualizaciones.");
        
        // Ejecuta la actualización inmediatamente al cargar la página.
        actualizarYRenderizar();
        
        // Establece el intervalo para futuras actualizaciones automáticas.
        setInterval(actualizarYRenderizar, UPDATE_INTERVAL_MS);
    }
});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/tradingPage.js ===
==================================================

// frontend/static/js/pages/tradingPage.js

import { DOMElements } from '../components/domElements.js';
import { UIState } from '../components/uiState.js';
import { UIUpdater } from '../components/uiUpdater.js';
import { FormLogic } from '../components/formLogic.js';
import { initializeChart, updateChartData } from '../components/chartRenderer.js';
import {
    fetchCotizaciones,
    fetchEstadoBilletera,
    fetchHistorial,
    fetchVelas,
    fetchOrdenesAbiertas,
    cancelarOrden
} from '../services/apiService.js';
import { AppState } from '../services/appState.js';
import { saveTradingState, loadTradingState } from '../services/statePersistence.js';

function createOrdenAbiertaRowHTML(orden) {
    const fechaCreacion = new Date(orden.timestamp_creacion).toLocaleString('es-AR', { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' });
    const tipoOrdenClase = orden.accion === 'comprar' ? 'text-success' : 'text-danger';
    const cantidad = orden.cantidad_cripto_principal; 
    const tickerCantidad = orden.accion === 'vender' ? orden.moneda_origen : orden.moneda_destino;
    return `<tr><td class="text-start ps-3 small">${fechaCreacion}</td><td class="fw-bold">${orden.par}</td><td>${orden.tipo_orden.charAt(0).toUpperCase() + orden.tipo_orden.slice(1)}</td><td class="${tipoOrdenClase}">${orden.accion.charAt(0).toUpperCase() + orden.accion.slice(1)}</td><td>$${parseFloat(orden.precio_disparo).toFixed(4)}</td><td>${parseFloat(cantidad).toFixed(6)} ${tickerCantidad}</td><td><button class="btn btn-sm btn-outline-danger btn-cancelar-orden" data-id-orden="${orden.id_orden}">Cancelar</button></td></tr>`;
}

document.addEventListener('DOMContentLoaded', () => {
    let currentTicker;
    let currentInterval;
    let isChartLoading = false;

    function handleTipoOrdenChange() {
        const tipoOrden = $('input[name="tipo-orden"]:checked').val();
        const campoPrecioDisparo = $('#campo-precio-disparo');
        const inputPrecioDisparo = $('#precio_disparo');
        const labelPrecioDisparo = $('#label-precio-disparo');
    

        const campoPrecioLimite = $('#campo-precio-limite');
        const inputPrecioLimite = $('#precio_limite');
    

        campoPrecioDisparo.hide();
        campoPrecioLimite.hide();
        inputPrecioDisparo.prop('required', false);
        inputPrecioLimite.prop('required', false);
    
        if (tipoOrden === 'limit') {
            labelPrecioDisparo.text('Precio Límite'); // Lo llamamos "Precio Límite"
            campoPrecioDisparo.show();
            inputPrecioDisparo.prop('required', true);
    
        } else if (tipoOrden === 'stop-limit') { // Cambiado de 'stop-loss'
            labelPrecioDisparo.text('Precio Stop'); // Ahora este es el "Precio Stop"
            campoPrecioDisparo.show();
            campoPrecioLimite.show(); // Mostramos el segundo campo
            inputPrecioDisparo.prop('required', true);
            inputPrecioLimite.prop('required', true); // Ambos son requeridos
        }
        
        // Para 'market', no se hace nada, ambos campos permanecen ocultos.
        UIUpdater.actualizarLabelMonto();
    }

    // El resto del archivo no necesita cambios significativos
    function actualizarFormularioUI() {
        const esCompra = UIState.esModoCompra();
        const allCryptos = AppState.getAllCryptos();
        const ownedCoins = AppState.getOwnedCoins();
        DOMElements.selectorPrincipal.off('change');
        if (esCompra) {
            const listaParaComprar = allCryptos.filter((c) => c.ticker !== 'USDT');
            FormLogic.popularSelector(DOMElements.selectorPrincipal, listaParaComprar);
        } else {
            const ownedCoinsToSell = ownedCoins.filter(c => c.ticker !== 'USDT');
            FormLogic.popularSelector(DOMElements.selectorPrincipal, ownedCoinsToSell, 'No tienes monedas para vender');
        }
        DOMElements.selectorPrincipal.val(currentTicker);
        DOMElements.selectorPrincipal.on('change', handleSelectorPrincipalChange);
        FormLogic.actualizarOpcionesDeSelectores();
        const tickerParaBalance = esCompra ? UIState.getTickerPago() : UIState.getTickerPrincipal();
        UIUpdater.mostrarSaldo(tickerParaBalance);
        UIUpdater.actualizarLabelMonto();
        UIUpdater.actualizarLabelsModoIngreso();
    }

    function handleSelectorPrincipalChange() {
        const nuevoTicker = UIState.getTickerPrincipal();
        if (!nuevoTicker || nuevoTicker === currentTicker) return;
        currentTicker = nuevoTicker;
        actualizarFormularioUI();
        actualizarGrafico(currentTicker, currentInterval);
        saveTradingState(currentTicker, currentInterval);
    }

    function setTradeMode(mode) {
        DOMElements.inputAccion.val(mode);
        UIUpdater.actualizarBotones();
        UIUpdater.actualizarVisibilidadCampos();
        actualizarFormularioUI();
    }
    
    async function actualizarGrafico(ticker, interval) {
        if (!ticker || isChartLoading) { return; }
        isChartLoading = true;
        try {
            const nuevosDatosVelas = await fetchVelas(ticker, interval);
            updateChartData(nuevosDatosVelas);
        } catch (error) {
            console.error(`Error al actualizar el gráfico para ${ticker}/${interval}:`, error);
            updateChartData([]);
        } finally {
            isChartLoading = false;
        }
    }
    
    function validarInputNumerico(event, maxDecimales = 8) {
        const input = event.target;
        let value = input.value;
        value = value.replace(/[^0-9.]/g, '').replace(/(\..*)\./g, '$1');
        const parts = value.split('.');
        if (parts[1] && parts[1].length > maxDecimales) {
            value = parts[0] + '.' + parts[1].substring(0, maxDecimales);
        }
        if (input.value !== value) {
            input.value = value;
        }
    }
    
    function setupEventListeners() {
        DOMElements.botonComprar.on('click', () => setTradeMode('comprar'));
        DOMElements.botonVender.on('click', () => setTradeMode('vender'));
        DOMElements.selectorPrincipal.on('change', handleSelectorPrincipalChange);
        
        DOMElements.selectorPagarCon.on('change', () => {
            UIUpdater.mostrarSaldo(UIState.getTickerPago());
            UIUpdater.actualizarLabelMonto();
            UIUpdater.actualizarLabelsModoIngreso();
        });
        
        DOMElements.selectorRecibirEn.on('change', () => {
            UIUpdater.actualizarLabelMonto();
            UIUpdater.actualizarLabelsModoIngreso();
        });
        
        $('#timeframe-selector').on('click', '.timeframe-btn', function () {
            currentInterval = $(this).data('interval');
            $(this).addClass('active').siblings().removeClass('active');
            actualizarGrafico(currentTicker, currentInterval);
            saveTradingState(currentTicker, currentInterval);
        });

        $('input[name="tipo-orden"]').on('change', handleTipoOrdenChange);
        DOMElements.radioModoIngreso.on('change', UIUpdater.actualizarLabelMonto);
        
        DOMElements.inputMonto.on('input', (e) => validarInputNumerico(e, 8));
        $('#precio_disparo').on('input', (e) => validarInputNumerico(e, 8));

        $('#tabla-ordenes-abiertas').on('click', '.btn-cancelar-orden', function() {
            const orderId = $(this).data('id-orden');
            Swal.fire({
                title: '¿Estás seguro?', text: "No podrás revertir esta acción.",
                icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33',
                cancelButtonColor: '#3085d6', confirmButtonText: 'Sí, ¡cancelar orden!',
                cancelButtonText: 'No', background: '#212529', color: '#f8f9fa'
            }).then(async (result) => {
                if (result.isConfirmed) {
                    try {
                        const respuesta = await cancelarOrden(orderId);
                        Toast.fire({ icon: 'success', html: respuesta.mensaje });
                        $(this).closest('tr').fadeOut(400, function() { $(this).remove(); if ($('#tabla-ordenes-abiertas tr').length === 0) {
                            const tablaBody = $('#tabla-ordenes-abiertas');
                            tablaBody.html('<tr><td colspan="7" class="text-center text-muted py-3">No hay órdenes abiertas.</td></tr>');
                        }});
                    } catch (error) {
                        Swal.fire({ icon: 'error', title: 'Error', text: 'No se pudo cancelar la orden.', background: '#212529', color: '#f8f9fa' });
                    }
                }
            });
        });
    }

    async function initialize() {
        console.log('Inicializando página de trading...');
        const urlParams = new URLSearchParams(window.location.search);
        const tickerDesdeUrl = urlParams.get('ticker');
        const savedState = loadTradingState();
        currentTicker = tickerDesdeUrl || savedState?.ticker || 'BTC';
        currentInterval = savedState?.interval || '1d';
        if (tickerDesdeUrl) saveTradingState(currentTicker, currentInterval);
        
        try {
            const [cotizaciones, estadoBilletera, historial, ordenesAbiertas] = await Promise.all([
                fetchCotizaciones(), fetchEstadoBilletera(), fetchHistorial(), fetchOrdenesAbiertas()
            ]);

            AppState.setAllCryptos(cotizaciones);
            AppState.setOwnedCoins(estadoBilletera);

            UIUpdater.renderHistorial(historial);
            const tablaOrdenesBody = $('#tabla-ordenes-abiertas');
            if (ordenesAbiertas.length === 0) {
                tablaOrdenesBody.html('<tr><td colspan="7" class="text-center text-muted py-3">No hay órdenes abiertas.</td></tr>');
            } else {
                tablaOrdenesBody.html(ordenesAbiertas.map(createOrdenAbiertaRowHTML).join(''));
            }

            const datosVelas = await fetchVelas(currentTicker, currentInterval);
            initializeChart(datosVelas);
            
            [DOMElements.selectorPrincipal, DOMElements.selectorPagarCon, DOMElements.selectorRecibirEn].forEach((sel) => {
                sel.select2({ width: '100%', dropdownCssClass: 'text-dark', theme: 'bootstrap-5' });
            });

            setupEventListeners();
            setTradeMode('comprar');
            handleTipoOrdenChange();

            $('#timeframe-selector .timeframe-btn').removeClass('active').filter(`[data-interval="${currentInterval}"]`).addClass('active');

            console.log('Página de trading inicializada correctamente.');
        } catch (error) {
            console.error('Error fatal durante la inicialización:', error);
            Swal.fire({
                icon: 'error', title: 'Error de Conexión',
                text: 'No se pudieron cargar los datos esenciales. Por favor, recarga la página.',
                background: '#212529', color: '#f8f9fa'
            });
        }
    }

    initialize();
});

==================================================
=== ARCHIVO: ./frontend/static/js/services/apiService.js ===
==================================================

// frontend/static/js/services/apiService.js

/**
 * ### REFACTORIZADO ###
 * Realiza una solicitud `fetch` y maneja respuestas de éxito y de error estructuradas.
 */
async function _fetchData(url, options = {}, errorMessage = 'Error en la solicitud a la API') {
    try {
        const response = await fetch(url, options);

        if (!response.ok) {
            // Si la respuesta no es OK, intentamos leer el cuerpo del error.
            const errorData = await response.json().catch(() => null); // Si el cuerpo no es JSON, devuelve null.
            const message = errorData?.mensaje || response.statusText; // Usa el mensaje del backend o el texto de estado HTTP.
            
            // Creamos un error que contiene los datos estructurados.
            const error = new Error(message);
            error.datos = errorData; // Adjuntamos todos los datos del error.
            error.status = response.status;
            throw error;
        }

        return await response.json();
    } catch (error) {
        console.error(`Error en la llamada a la API [${url}]:`, error);
        throw error; // Re-lanzamos el error para que el código que llama pueda manejarlo.
    }
}

// El resto de las funciones (fetchCotizaciones, fetchEstadoBilletera, etc.) NO CAMBIAN.
// Siguen usando _fetchData, que ahora es más potente.

export const fetchCotizaciones = () => 
    _fetchData('/api/cotizaciones', {}, 'No se pudieron cargar las cotizaciones');

export const fetchEstadoBilletera = () => 
    _fetchData('/api/billetera/estado-completo', {}, 'No se pudo cargar el estado de la billetera');

export const fetchHistorial = () => 
    _fetchData('/api/historial', {}, 'No se pudo cargar el historial de transacciones');

export const fetchVelas = (ticker, interval) => 
    _fetchData(`/api/velas/${ticker}/${interval}`, {}, `No se pudieron cargar los datos de velas para ${ticker} (${interval})`);

export const triggerActualizacionDatos = () => 
    _fetchData('/api/actualizar', {}, 'La solicitud para actualizar los datos falló');

export const fetchComisiones = () => 
    _fetchData('/api/comisiones', {}, 'No se pudo cargar el historial de comisiones');

export const fetchOrdenesAbiertas = () =>
    _fetchData('/api/ordenes-abiertas', {}, 'No se pudo cargar la lista de órdenes abiertas');

export const cancelarOrden = (idOrden) => 
    _fetchData(`/api/orden/cancelar/${idOrden}`, {
        method: 'POST'
    }, 'No se pudo cancelar la orden');

==================================================
=== ARCHIVO: ./frontend/static/js/services/appState.js ===
==================================================

/**
 * @module services/appState
 * @description Centraliza el estado de la aplicación para evitar el uso de variables globales.
 * Proporciona métodos seguros para leer y escribir en el estado.
 */

const state = {
    allCryptos: [],
    ownedCoins: []
};

export const AppState = {
    /**
     * Establece la lista completa de cotizaciones.
     * @param {Array<object>} cryptos - La lista de criptomonedas.
     */
    setAllCryptos: (cryptos) => {
        state.allCryptos = cryptos || [];
    },

    /**
     * Establece la lista de monedas que el usuario posee.
     * @param {Array<object>} coins - La lista de monedas en la billetera.
     */
    setOwnedCoins: (coins) => {
        state.ownedCoins = coins || [];
    },

    /**
     * Obtiene la lista completa de cotizaciones.
     * @returns {Array<object>}
     */
    getAllCryptos: () => state.allCryptos,

    /**
     * Obtiene la lista de monedas que el usuario posee.
     * @returns {Array<object>}
     */
    getOwnedCoins: () => state.ownedCoins,

    /**
     * Busca una moneda específica que el usuario posee por su ticker.
     * @param {string} ticker - El ticker de la moneda.
     * @returns {object | undefined} El objeto de la moneda o undefined si no se encuentra.
     */
    getOwnedCoinByTicker: (ticker) => {
        return state.ownedCoins.find(coin => coin.ticker === ticker);
    },

    /**
     * Busca el precio de una criptomoneda específica por su ticker.
     * @param {string} ticker - El ticker de la moneda.
     * @returns {number | null} El precio de la moneda o null si no se encuentra.
     */
    getPriceByTicker: (ticker) => {
        const crypto = state.allCryptos.find(c => c.ticker === ticker);
        // La propiedad 'precio_usd' viene del backend como un string, lo convertimos a número.
        return crypto ? parseFloat(crypto.precio_usd) : null;
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/services/statePersistence.js ===
==================================================

/**
 * @module services/statePersistence
 * @description Gestiona el guardado y la carga del estado de la aplicación
 * en el Almacenamiento Local (LocalStorage) del navegador.
 */

// Usamos una clave constante para evitar errores de tipeo.
const TRADING_STATE_KEY = 'tradingViewState';

/**
 * Guarda el estado actual de la vista de trading (ticker e intervalo).
 * @param {string} ticker - El ticker de la criptomoneda actual.
 * @param {string} interval - El intervalo de tiempo actual.
 */
export function saveTradingState(ticker, interval) {
    if (!ticker || !interval) {
        console.warn("Intento de guardar estado de trading inválido.");
        return;
    }
    const state = { ticker, interval };
    try {
        // Los objetos deben ser convertidos a string (JSON) para guardarse en LocalStorage.
        localStorage.setItem(TRADING_STATE_KEY, JSON.stringify(state));
    } catch (error) {
        console.error("Error al guardar el estado en LocalStorage:", error);
    }
}

/**
 * Carga el estado de la vista de trading desde LocalStorage.
 * @returns {{ticker: string, interval: string} | null} El estado guardado o null si no se encuentra nada.
 */
export function loadTradingState() {
    try {
        const savedStateJSON = localStorage.getItem(TRADING_STATE_KEY);
        if (savedStateJSON) {
            // Si encontramos datos, los convertimos de nuevo a un objeto JavaScript.
            return JSON.parse(savedStateJSON);
        }
        return null; // No hay estado guardado.
    } catch (error) {
        console.error("Error al cargar el estado desde LocalStorage:", error);
        return null;
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/utils/sweetalert-init.js ===
==================================================

/**
 * @file sweetalert-init.js
 * @description Inicializa y configura globalmente la librería SweetAlert2.
 * Define un objeto 'Toast' personalizado para notificaciones no intrusivas.
 */

// Se define 'Toast' en el ámbito global para que sea accesible
// desde otros scripts, como los flashes de Flask en el HTML.
const Toast = Swal.mixin({
    toast: true,
    position: 'top-end',
    showConfirmButton: false,
    timer: 8000,
    customClass: {
        popup: 'custom-toast-position'
    },
    timerProgressBar: true,
    didOpen: (toast) => {
        toast.addEventListener('mouseenter', Swal.stopTimer);
        toast.addEventListener('mouseleave', Swal.resumeTimer);
    },
    background: '#343a40', // Fondo oscuro
    color: '#f8f9fa'       // Texto claro
});


==================================================
=== ARCHIVO: ./frontend/templates/_flashes.html ===
==================================================

<!-- frontend/templates/_flashes.html -->
<!-- ### REFACTORIZADO ### - Ahora es un componente inteligente que construye el HTML. -->

{% with messages = get_flashed_messages(with_categories=true) %}
{% if messages %}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        /**
         * Construye el contenido HTML para la notificación Toast a partir de los datos
         * estructurados que envía el backend.
         * @param {object} data - El objeto de datos parseado desde el JSON.
         * @returns {string} El HTML para el cuerpo de la notificación.
         */
        function buildFlashMessageHTML(data) {
            // Estilo común para el cuerpo del mensaje
            const baseStyle = 'text-align: left; font-size: 0.9rem;';
            const hr = "<hr style='margin: 4px 0; border-color: #555;'>";

            if (data.tipo === 'mercado') {
                const d = data.detalles;
                return `
                    <div style="${baseStyle}">
                        <span>Recibiste: <strong style='color: #1FB371;'>${d.recibiste.cantidad} ${d.recibiste.ticker}</strong></span><br>
                        <span>Pagaste: <strong style='color: #FFA500;'>${d.pagaste.cantidad} ${d.pagaste.ticker}</strong></span><br>
                        <span style='font-size: 0.8rem; color: #999;'>Comisión: ${d.comision.cantidad} ${d.comision.ticker}</span>
                    </div>
                `;
            } else if (data.tipo === 'limit' || data.tipo === 'stop-loss') {
                const d = data.detalles;
                return `
                    <div style="${baseStyle}">
                        <span>Acción: <strong>${d.accion}</strong></span><br>
                        <span>Precio Disparo: <strong>${d.precio_disparo}</strong></span><br>
                        <span style='font-size: 0.8rem; color: #999;'>Los fondos han sido reservados.</span>
                    </div>
                `;
            }
            return 'Detalles no disponibles.'; // Fallback
        }

        const flashedMessages = {{ messages|tojson|safe }};

        if (typeof Toast !== 'undefined') {
            flashedMessages.forEach(([category, message]) => {
                const iconType = category === 'danger' ? 'error' : 'success';
                let title, htmlContent;

                if (category === 'success') {
                    try {
                        // El mensaje de éxito es un JSON, lo parseamos
                        const data = JSON.parse(message);
                        title = data.titulo || 'Operación Procesada';
                        htmlContent = buildFlashMessageHTML(data);
                    } catch (e) {
                        // Si falla el parseo, lo mostramos como texto plano
                        console.error("Error al parsear el mensaje flash JSON:", e);
                        title = 'Operación Exitosa';
                        htmlContent = message;
                    }
                } else {
                    // El mensaje de error es un string simple
                    title = 'Error en la operación';
                    htmlContent = message;
                }
                
                Toast.fire({
                    icon: iconType,
                    title: title,
                    html: htmlContent
                });
            });
        } else {
            console.error("SweetAlert Toast no está definido.");
        }
    });
</script>
{% endif %}
{% endwith %}

==================================================
=== ARCHIVO: ./frontend/templates/billetera.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Billetera</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <!-- Los estilos pueden ser los mismos de trading o unos específicos para billetera -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="bg-dark text-white">
    <!-- ========== BARRA DE NAVEGACIÓN ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white active"
                            href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes de error (si se necesita) -->
    <div id="error-container" class="container-fluid mt-3"></div>

    <!-- ========== CONTENIDO PRINCIPAL ========== -->
    <main class="container my-4">
        <div class="text-center">
            <h2 class="text-warning mb-4">Mi Billetera</h2>
        </div>

        <!-- Switch para ocultar saldos pequeños (polvo) -->
        <div class="d-flex justify-content-end mb-3">
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="ocultar-polvo-switch">
                <label class="form-check-label text-white-50" for="ocultar-polvo-switch">Ocultar saldos pequeños</label>
            </div>
        </div>

        <!-- Tabla de Activos en la Billetera -->
        <table class="table table-dark table-striped align-middle"> <!-- Quitamos table-bordered -->
            <thead>
                <!-- Añadimos clases de alineación a las cabeceras -->
                <tr>
                    <th class="text-start ps-3">Activo</th>
                    <th class="text-end pe-3">Total</th>
                    <th class="text-end pe-3">Disponible</th>
                    <th class="text-end pe-3">En Órdenes</th>
                    <th class="text-end pe-3">Precio Actual</th>
                    <th class="text-end pe-3">Valor Total (USD)</th>
                    <th class="text-end pe-3">G/P (USD)</th>
                    <th class="text-end pe-3">G/P (%)</th>
                    <th class="text-end pe-3">% Billetera</th>
                </tr>
            </thead>
            <tbody id="tabla-billetera">
                <!-- El colspan sigue siendo 9, así que no cambia -->
                <tr>
                    <td colspan="9" class="text-center text-muted py-4">Cargando billetera...</td>
                </tr>
            </tbody>
        </table>

        <!-- Historial de Comisiones -->
        <div class="text-center mt-5">
            <h4 class="text-warning mb-4">Historial de Comisiones</h4>
        </div>

        <div class="table-responsive mt-4">
            <table class="table table-dark table-striped align-middle text-center">
                <thead class="table-secondary">
                    <tr class="table-dark">
                        <th>Fecha</th>
                        <th>Moneda (Fee)</th>
                        <th>Cantidad Cobrada</th>
                        <th>Valor (USD)</th>
                    </tr>
                </thead>
                <tbody id="tabla-comisiones">
                    <!-- El contenido será renderizado aquí por billeteraPage.js -->
                    <tr>
                        <td colspan="4" class="text-center text-muted py-4">Cargando historial de comisiones...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </main>

    <!-- ========== SCRIPTS ========== -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/billeteraPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/index.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BlocX</title>
	<link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
	<link rel="stylesheet" href="{{ url_for('static', filename='css/styles_index.css') }}">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
</head>

<body class="bg-dark text-white">


	<nav class="navbar navbar-expand-lg bg-black shadow">
		<div class="container-fluid">
			<a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
				<img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
				<span>BlocX</span>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
				<span class="navbar-toggler-icon bg-light"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarNav">
				<ul class="navbar-nav ms-auto">
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Contenedor para mensajes de error -->
	<div id="error-container" class="container-fluid mt-3"></div>

	<!-- Contenedor principal -->
	<main class="container-fluid mt-4">
		<div class="row">
			<div class="col-12">
				<div class="p-2 shadow text-center">
					<h3 class="text-warning">Cotizaciones</h3>
					<table class="table table-dark table-striped mt-4">
						<thead>
							<tr>
								<th class="text-start px-3">#</th>
								<th class="text-start px-3">Nombre</th>
								<th class="text-start px-3">Precio</th>
								<th class="text-end px-3">1h</th>
								<th class="text-end px-3">24h</th>
								<th class="text-end px-3">7d</th>
								<th class="text-end px-3">Cap. Mercado</th>
								<th class="text-end px-3">Volumen</th>
								<th class="text-end px-3">Suministro</th>
							</tr>
						</thead>
						<tbody id="tabla-datos" class="align-middle">
							<!-- Aquí se insertarán las filas con JS -->
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</main>

	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
	<script type="module" src="{{ url_for('static', filename='js/pages/indexPage.js') }}"></script>

</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/trading.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Trading</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/select2-bootstrap-5-theme@1.3.0/dist/select2-bootstrap-5-theme.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
</head>

<body class="bg-dark text-white">

    <!-- ========== BARRA DE NAVEGACIÓN ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes flash de Flask (ahora en un archivo parcial) -->
    {% include '_flashes.html' %}

    <!-- ========== CONTENIDO PRINCIPAL ========== -->
    <div class="container mt-4">
        <div class="row">
            <div class="col-md-7">
                <h3 class="text-light">Gráfico velas</h3>

                <div class="btn-group btn-group-sm mb-2" role="group" id="timeframe-selector">
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="5m">5m</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn"
                        data-interval="15m">15m</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="1h">1h</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="4h">4h</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn active"
                        data-interval="1d">1D</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="1w">1S</button>
                </div>

                <div class="form-check form-switch mb-2 d-inline-block ms-3">
                    <input class="form-check-input" type="checkbox" id="toggleVolume" checked>
                    <label class="form-check-label text-light" for="toggleVolume">Mostrar volumen</label>
                </div>

                <div class="py-3" style="position: relative;">
                    <div id="chart-error-overlay" class="chart-overlay" style="display: none;">
                        <span>No hay datos de gráfico disponibles para este par y temporalidad.</span>
                    </div>
                    <div id="chart"></div>
                </div>
            </div>

            <form class="col-md-5 p-3" id="formulario-trading" method="POST"
                action="{{ url_for('trading.procesar_trading_form') }}">
                <h2 class="text-warning">Trading</h2>
                <div class="row g-2 mb-3">
                    <div class="col-6">
                        <label for="cripto" class="form-label">Criptomoneda</label>
                        <select class="form-select" id="cripto" name="ticker" required></select>
                    </div>
                    <div class="col-6">
                        <div id="campo-pagar-con" style="display: none;">
                            <label for="moneda-pago" class="form-label">Pagar con</label>
                            <select class="form-select" id="moneda-pago" name="moneda-pago"></select>
                        </div>
                        <div id="campo-recibir-en" style="display: none;">
                            <label for="moneda-recibir" class="form-label">Recibir en</label>
                            <select class="form-select" id="moneda-recibir" name="moneda-recibir"></select>
                        </div>
                    </div>
                </div>
                <div class="btn-group mb-3 w-100" role="group" id="toggle-trade-type">
                    <input type="hidden" name="accion" id="accion" value="comprar">
                    <button type="button" class="btn w-50 btn-success active boton-comprar"
                        data-action="comprar">Comprar</button>
                    <button type="button" class="btn w-50 btn-outline-secondary boton-vender"
                        data-action="vender">Vender</button>
                </div>
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Tipo de orden</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-mercado" value="market"
                            autocomplete="off" checked>
                        <label class="btn btn-outline-primary rounded-start-pill" for="tipo-mercado">Mercado</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-limite" value="limit"
                            autocomplete="off">
                        <label class="btn btn-outline-primary" for="tipo-limite">Límite</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-stop-limit" value="stop-limit"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="tipo-stop-limit">Stop-Limit</label>
                    </div>
                </div>

                <!-- CAMPO NUEVO: Precio de Disparo -->
                <div class="mb-3" id="campo-precio-disparo" style="display: none;">
                    <label for="precio_disparo" class="form-label" id="label-precio-disparo">Precio Límite</label>
                    <input type="text" class="form-control" id="precio_disparo" placeholder="0.00" name="precio_disparo"
                        inputmode="decimal">
                </div>

                <div class="mb-3" id="campo-precio-limite" style="display: none;">
                    <label for="precio_limite" class="form-label">Precio Límite</label>
                    <input type="text" class="form-control" id="precio_limite" placeholder="0.00" name="precio_limite"
                        inputmode="decimal">
                </div>

                <div class="mb-3" id="campo-modo-ingreso">
                    <label class="form-label d-block mb-2">Ingresar por</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-monto" value="monto"
                            autocomplete="off" checked>
                        <label class="btn btn-outline-primary rounded-start-pill" for="modo-monto"
                            id="label-modo-monto">Cantidad (Cripto)</label>
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-total" value="total"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="modo-total"
                            id="label-modo-total">Total (USDT)</label>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="monto" class="form-label" id="label-monto">Cantidad</label>
                    <input type="text" class="form-control" id="monto" name="monto" placeholder="0.00" required
                        inputmode="decimal">
                </div>
                <div class="mb-3">


                </div>
                <div class="mb-3 text-end text-secondary">
                    <small>Disponible: <span id="saldo-disponible">--</span></small>
                </div>
                <button type="submit" class="btn w-100 btn-success boton-confirmar"
                    id="boton-confirmar">CONFIRMAR</button>
            </form>
        </div>

        <!-- SECCIÓN NUEVA: Órdenes Abiertas -->
        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">Órdenes Abiertas</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha Creación</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Acción</th>
                                <th>Precio Disparo</th>
                                <th>Cantidad</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-ordenes-abiertas">
                            <!-- El contenido será renderizado por JS -->
                            <tr>
                                <td colspan="7" class="text-center text-muted py-3">Cargando órdenes abiertas...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">Historial de transacciones</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Cantidad</th>
                                <th>Valor Total</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-historial">
                            <tr>
                                <td colspan="5" class="text-center text-muted py-3">Cargando historial...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== SECCIÓN SCRIPTS ===== -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.all.min.js"></script>
    <script src="{{ url_for('static', filename='js/utils/sweetalert-init.js') }}"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/tradingPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./pytest.ini ===
==================================================

[pytest]
python_files = test_*.py
python_classes = Test*
python_functions = test_*
testpaths = tests


==================================================
=== ARCHIVO: ./README.md ===
==================================================

# Simulador Exchange - **BlokX**

Este proyecto educativo fue desarrollado en el marco de la materia "Algoritmos y Estructuras de Datos I" de UADE, bajo la supervisión de la profesora Julia Monasterio.  
Su objetivo es aplicar los conocimientos de la cátedra simulando el funcionamiento básico de un exchange de criptomonedas.  
El sistema permite a los usuarios operar con saldo ficticio utilizando datos reales de cotización obtenidos de CoinGecko y Binance.

## 🎯 Objetivos del proyecto

- Familiarizar a los usuarios con el entorno de un exchange de criptomonedas.
- Simular operaciones de compra y venta mediante distintos tipos de órdenes: Market, Limit y Stop-Loss.
- Calcular y visualizar ganancias, pérdidas y balances del portafolio.
- Almacenar toda la información de manera local utilizando archivos `.json`.
- Comprender la interacción entre frontend y backend mediante una arquitectura moderna (HTML, CSS, Flask y Python).

## ⚙️ Funcionalidades

### Panel general de cotizaciones
- Visualización del top de criptomonedas con:
  - Nombre, ticker, precio, market cap, volumen, supply.
  - Variación en 1h, 24h y 7 días.
- Actualización automática de precios cada 15 segundos.

### Panel de trading
En este panel se verán tres secciones diferentes que contemplan lo necesario para ejecutar las ordenes de compra/venta.

#### Gráfico de velas japonesas
- Grafico en el cual se va a poder visualizar los diferentes pares de criptos usando Lightweight Charts (Libreria de JavaScript), en diferentes time frames: 1m, 5m, 15m, 1h, 4hs, 1d y 1w.

#### Órdenes
- Compra y venta de activos con órdenes:
  - Market
  - Limit
  - Stop-loss
- Comisión fija del 0.5% por transacción.
- Validaciones de saldo y tenencias disponibles.

#### Historial
- Registro de todas las operaciones realizadas.
- Incluye tipo de orden, precio, cantidad, fecha y fee aplicado.
  
### Billetera
- Visualización de tenencias actuales:
  - Cantidad, precio promedio, valor actual, ganancia/pérdida por activo.
- Balance total del portafolio en USDT.

## 🧠 Cómo funciona el sistema

El sistema está diseñado bajo una arquitectura desacoplada que separa claramente las responsabilidades del backend y del frontend:

- **Backend (Python/Flask)**: Actúa como una API pura de JSON. Sus responsabilidades son:
    - **`rutas/`**: Define los endpoints de la API (`/api/...`) que exponen los datos y la lógica de negocio en formato JSON. También sirve el contenedor HTML inicial de cada página.
    - **`servicios/`**: Contiene toda la lógica de negocio (cálculos de billetera, procesamiento de órdenes, formato de datos) y prepara los datos para ser enviados como JSON.
    - **`acceso_datos/`**: Gestiona la lectura y escritura de los archivos `.json` que actúan como base de datos.
    - **`utils/`**: Proporciona funciones de utilidad, como formateadores de datos que se aplican en el backend.

- **Frontend (JavaScript)**: Es un cliente dinámico que consume la API del backend.
    - **Autónomo**: Cada página carga su propio HTML y luego utiliza JavaScript para buscar todos los datos que necesita de los endpoints `/api/...`.
    - **Renderizado en el cliente**: Todo el renderizado y la manipulación del DOM (actualización de tablas, saldos, gráficos) se realiza en el navegador, creando una experiencia de usuario fluida y rápida sin recargas de página.
    - **Estructura modular en `js/`**:
        - **`pages/`**: Contiene la lógica de inicialización y orquestación para cada página principal (ej. `tradingPage.js`).
        - **`components/`**: Módulos encargados de actualizar partes específicas de la interfaz (ej. `uiUpdater.js`, `tablaCotizacionesUI.js`).
        - **`services/`**: Gestiona la comunicación con la API del backend.

### Flujo desacoplado

1.  El usuario navega a una URL (ej. `/trading`).
2.  Flask sirve un archivo HTML mínimo (`trading.html`) que actúa como un esqueleto.
3.  El archivo JavaScript asociado a esa página (`tradingPage.js`) se ejecuta.
4.  El script de JS realiza llamadas a los endpoints de la API del backend (`/api/cotizaciones`, `/api/historial`, etc.) para obtener los datos en formato JSON.
5.  Una vez recibidos los datos, JavaScript actualiza dinámicamente el DOM para mostrar la información al usuario.

## 🗃️ Estructura del proyecto

```
simulador_exchange/
├── backend/
│   ├── app.py                      # Servidor Flask y punto de entrada
│   ├── config.py                   # Configuración del sistema y constantes globales
│   ├── rutas/                      # Blueprints que definen las vistas y API endpoints
│   │   ├── __init__.py
│   │   ├── home.py
│   │   ├── trading_vista.py
│   │   ├── billetera_vista.py
│   │   └── api_cotizaciones_vista.py
│   ├── servicios/                  # Lógica de negocio de cada módulo
│   │   ├── api_cotizaciones.py
│   │   ├── estado_billetera.py
│   │   └── velas_logica.py
│   ├── acceso_datos/               # Acceso y manipulación de archivos .json
│   │   ├── datos_billetera.py
│   │   ├── datos_cotizaciones.py
│   │   └── datos_historial.py
│   └── utils/                      # Utilidades auxiliares
│       └── formatters.py
│
├── frontend/
│   ├── templates/                  # Plantillas HTML (contenedores iniciales)
│   │   ├── index.html
│   │   ├── billetera.html
│   │   └── trading.html
│   └── static/                     # Archivos estáticos
│       ├── css/
│       │   ├── styles_index.css
│       │   └── styles_trading.css
│       ├── img/
│       │   └── logo_BlocX.png
│       └── js/                     # Lógica del cliente
│           ├── components/         # Módulos para actualizar la UI
│           ├── pages/              # Scripts de orquestación por página
│           └── services/           # Servicios de comunicación con la API
│
├── datos/                          # Archivos de persistencia
│   ├── billetera.json
│   ├── datos_cotizaciones.json
│   ├── datos_velas.json
│   └── historial_operaciones.json
│
├── requirements.txt
├── .gitignore
└── README.md
```

## 🚀 Cómo ejecutar el proyecto

### 1. Crear entorno virtual (recomendado)
```bash
python3 -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

### 2. Instalar dependencias
```bash
pip install -r requirements.txt
```

### 3. Iniciar la app
```bash
python3 app.py
```

Y luego acceder desde el navegador a:  
```
http://localhost:5000
```

## 📦 Tecnologías utilizadas

- Python 3.13
- Flask
- HTML, CSS, JavaScript
- Lightweight Charts (TradingView)

## 📌 Notas

- Todos los datos se almacenan localmente en formato JSON.
- No se requiere conexión a bases de datos externas.
- El sistema está pensado para ser didáctico y extensible.

---

**Grupo 12**  
Fausto Lovera — Patricio Menta — Andrei Veis


==================================================
=== ARCHIVO: ./requirements.txt ===
==================================================

Flask==3.1.0
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
requests==2.32.3
Werkzeug==3.1.3
python-dotenv==1.0.1



==================================================
=== ARCHIVO: ./tests/__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./tests/test_estado_billetera.py ===
==================================================

import pytest
from decimal import Decimal

# Importamos las funciones a probar
from backend.servicios.estado_billetera import _calcular_metricas_activo, estado_actual_completo

# --- Fixtures: Datos de prueba reutilizables ---

@pytest.fixture
def datos_compra_btc():
    """Fixture que proporciona datos de compra para Bitcoin."""
    return {
        "total_invertido": Decimal("45000"),
        "cantidad_comprada": Decimal("1.5")
    }

@pytest.fixture
def mock_billetera_data():
    """Fixture con datos simulados de la billetera."""
    return [
        {"ticker": "BTC", "cantidad": "1.5"},
        {"ticker": "ETH", "cantidad": "2.0"}
    ]

@pytest.fixture
def mock_historial_data():
    """Fixture con datos simulados del historial de transacciones."""
    return [
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "0.5"}, "valor_usd": "15000"},
        {"tipo": "compra", "destino": {"ticker": "ETH", "cantidad": "2.0"}, "valor_usd": "20000"}
    ]

@pytest.fixture
def mock_cotizaciones_data():
    """Fixture con datos simulados de cotizaciones."""
    return {
        "BTC": Decimal("40000"),
        "ETH": Decimal("1500")
    }


# --- Tests para las funciones ---

def test_calcular_metricas_activo(datos_compra_btc):
    """Prueba la función de cálculo de métricas para un activo."""
    # Arrange: Preparación de datos
    ticker = "BTC"
    cantidad_actual = Decimal("1.5")
    precio_actual = Decimal("40000")
    
    # Act: Ejecución de la función
    resultado = _calcular_metricas_activo(ticker, cantidad_actual, precio_actual, datos_compra_btc)

    # Assert: Verificación de resultados con `assert`
    assert resultado["ticker"] == "BTC"
    assert resultado["cantidad"] == cantidad_actual
    assert resultado["precio_actual"] == precio_actual
    assert resultado["valor_usdt"] == cantidad_actual * precio_actual
    assert resultado["precio_promedio_compra"] == Decimal("30000")
    assert resultado["costo_base_actual"] == cantidad_actual * Decimal("30000")
    assert resultado["ganancia_perdida"] == (cantidad_actual * precio_actual) - (cantidad_actual * Decimal("30000"))

def test_estado_actual_completo(monkeypatch, mock_billetera_data, mock_historial_data, mock_cotizaciones_data):
    """
    Prueba la función orquestadora `estado_actual_completo` mockeando
    sus dependencias de acceso a datos.
    """
    # Arrange: Configuración de los mocks usando monkeypatch
    monkeypatch.setattr('backend.acceso_datos.datos_billetera.cargar_billetera', lambda: mock_billetera_data)
    monkeypatch.setattr('backend.acceso_datos.datos_historial.cargar_historial', lambda: mock_historial_data)
    monkeypatch.setattr('backend.acceso_datos.datos_cotizaciones.cargar_datos_cotizaciones', lambda: mock_cotizaciones_data)

    # Act: Ejecución de la función
    resultado = estado_actual_completo()

    # Assert: Verificación de resultados
    assert isinstance(resultado, dict)
    assert "BTC" in resultado
    assert "ETH" in resultado
    
    # Verificar cálculos para BTC
    btc = resultado["BTC"]
    assert btc["ticker"] == "BTC"
    assert btc["cantidad"] == Decimal("1.5")
    assert btc["precio_actual"] == Decimal("40000")
    
    # Verificar cálculos para ETH
    eth = resultado["ETH"]
    assert eth["ticker"] == "ETH"
    assert eth["cantidad"] == Decimal("2.0")
    assert eth["precio_actual"] == Decimal("1500")

==================================================
=== ARCHIVO: ./tests/test_trading_logica.py ===
==================================================

import pytest
from decimal import Decimal, getcontext
from typing import Tuple

# Aseguramos la precisión para los cálculos con Decimal, es una buena práctica
getcontext().prec = 28

# Importamos la función que vamos a testear (con el guion bajo)
from backend.servicios.trading_logica import _calcular_detalles_swap


# --- Tests para Casos de Éxito ---

def test_compra_ingresando_monto_cripto():
    """
    Prueba una compra donde se especifica la cantidad de cripto a RECIBIR.
    Ejemplo: Quiero comprar exactamente 0.02 BTC.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='comprar',
        modo_ingreso='monto',  # El usuario ingresa la cantidad de cripto
        monto_form=Decimal('0.02'),
        precio_origen_usdt=Decimal('1'),      # Precio de USDT
        precio_destino_usdt=Decimal('50000')  # Precio de BTC
    )
    
    assert exito is True
    assert detalles == {
        'origen': Decimal('1000.0'),  # Costará 1000 USDT
        'destino': Decimal('0.02'),   # Para recibir 0.02 BTC
        'valor_usd': Decimal('1000.0')
    }

def test_compra_ingresando_total_fiat():
    """
    Prueba una compra donde se especifica la cantidad de fiat a GASTAR.
    Ejemplo: Quiero gastar exactamente 1000 USDT en BTC.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='comprar',
        modo_ingreso='total',  # El usuario ingresa la cantidad de fiat
        monto_form=Decimal('1000'),
        precio_origen_usdt=Decimal('1'),      # Precio de USDT
        precio_destino_usdt=Decimal('50000')  # Precio de BTC
    )
    
    assert exito is True
    assert detalles == {
        'origen': Decimal('1000'),    # Gastaré 1000 USDT
        'destino': Decimal('0.02'),   # Y recibiré 0.02 BTC
        'valor_usd': Decimal('1000')
    }

def test_venta_ingresando_monto_cripto():
    """
    Prueba una venta donde el usuario especifica la cantidad de cripto a VENDER.
    Ejemplo: Quiero vender exactamente 0.1 BTC.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='vender',
        modo_ingreso='monto',  # En ventas, siempre se ingresa la cantidad de cripto
        monto_form=Decimal('0.1'),
        precio_origen_usdt=Decimal('50000'),  # Precio de BTC
        precio_destino_usdt=Decimal('1')      # Precio de USDT
    )
    
    assert exito is True
    assert detalles == {
        'origen': Decimal('0.1'),     # Venderé 0.1 BTC
        'destino': Decimal('5000'),   # Y recibiré 5000 USDT
        'valor_usd': Decimal('5000')
    }

# --- Tests para Casos Límite y Errores ---

def test_calculo_con_monto_cero():
    """
    Prueba que un monto de entrada cero resulte en un swap de valor cero.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='comprar',
        modo_ingreso='total',
        monto_form=Decimal('0'),
        precio_origen_usdt=Decimal('1'),
        precio_destino_usdt=Decimal('50000')
    )
    
    assert exito is True
    assert detalles == {
        'origen': Decimal('0'),
        'destino': Decimal('0'),
        'valor_usd': Decimal('0')
    }

def test_calculo_con_precio_destino_cero():
    """
    Prueba que si el precio de destino es cero, no se puede recibir nada.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='comprar',
        modo_ingreso='total',
        monto_form=Decimal('1000'),
        precio_origen_usdt=Decimal('1'),
        precio_destino_usdt=Decimal('0')  # Precio de destino es 0
    )
    
    assert exito is True
    # Si el precio de destino es 0, el valor total no puede convertirse en nada.
    # La implementación actual puede dar un ZeroDivisionError aquí, esto es un buen test para descubrirlo.
    # Asumiendo que se maneja, el destino debería ser 0.
    # NOTA: Este test podría fallar con ZeroDivisionError si no hay un try-except en la función.
    # Si la función no lo maneja, el test debería ser para esperar ese error.
    # Por ahora, asumimos que tu función es robusta. Si no, ¡este test te lo dirá!
    assert detalles['destino'] == Decimal('0')


def test_falla_al_vender_en_modo_total():
    """
    Prueba que la función falle si se intenta vender en modo 'total'.
    """
    exito, resultado = _calcular_detalles_swap(
        accion='vender',
        modo_ingreso='total',
        monto_form=Decimal('100'),
        precio_origen_usdt=Decimal('50000'),
        precio_destino_usdt=Decimal('1')
    )
    
    assert exito is False
    assert isinstance(resultado, str)
    assert "Al vender, debe ingresar la cantidad" in resultado

def test_falla_con_accion_desconocida():
    """
    Prueba que la función falle si la acción no es 'comprar' ni 'vender'.
    """
    exito, resultado = _calcular_detalles_swap(
        accion='intercambiar',
        modo_ingreso='monto',
        monto_form=Decimal('1'),
        precio_origen_usdt=Decimal('1'),
        precio_destino_usdt=Decimal('1')
    )
    
    assert exito is False
    assert "Acción de trading desconocida" in resultado

==================================================
=== ARCHIVO: ./tests/test_velas_logica.py ===
==================================================

import pytest
import json
import io  # Usaremos io.StringIO para simular archivos de texto de forma más limpia
from decimal import Decimal
from backend.servicios.velas_logica import guardar_datos_cotizaciones, cargar_datos_cotizaciones

# --- Test para guardar_datos_cotizaciones ---

def test_guardar_datos_cotizaciones(monkeypatch):
    """
    Prueba que `guardar_datos_cotizaciones` intente crear el directorio
    y escribir los datos correctos en el archivo.
    """
    # 1. Datos de muestra que se pasarán a la función
    datos_a_guardar = [
        {'ticker': 'BTC', 'nombre': 'Bitcoin', 'precio_usd': Decimal('50000')}
    ]
    
    # 2. Variables para capturar las llamadas a los mocks
    # Usaremos listas para poder modificarlas desde dentro de las funciones mock
    ruta_makedirs_llamada = []
    datos_escritos = []

    # 3. Mocks de las funciones del sistema de archivos
    def mock_makedirs(path, exist_ok=False):
        # Capturamos la ruta con la que se llamó a makedirs
        ruta_makedirs_llamada.append(path)
        assert exist_ok is True

    def mock_open_para_escritura(file, mode):
        # Verificamos que se intente abrir el archivo en modo escritura ('w')
        assert 'w' in mode
        # Simulamos un objeto archivo que captura lo que se escribe
        class MockFileWriter:
            def write(self, data):
                datos_escritos.append(data)
            def __enter__(self):
                return self
            def __exit__(self, type, value, traceback):
                pass
        return MockFileWriter()

    # 4. Aplicamos los mocks
    monkeypatch.setattr('os.makedirs', mock_makedirs)
    # Usamos 'builtins.open' para mockear la función open() global
    monkeypatch.setattr('builtins.open', mock_open_para_escritura)

    # 5. Ejecutamos la función a probar
    guardar_datos_cotizaciones(datos_a_guardar)
    
    # 6. Verificamos los resultados
    # Comprobamos que se intentó crear la carpeta 'datos'
    assert ruta_makedirs_llamada and 'datos' in str(ruta_makedirs_llamada[0])
    
    # Comprobamos que lo que se escribió en el archivo es el JSON correcto
    # Convertimos el string JSON escrito de vuelta a un objeto Python para compararlo
    assert len(datos_escritos) == 1
    datos_guardados = json.loads(datos_escritos[0])
    # Como JSON no tiene tipo Decimal, lo comparamos como string
    assert datos_guardados[0]['precio_usd'] == '50000'
    assert datos_guardados[0]['ticker'] == 'BTC'


# --- Tests para cargar_datos_cotizaciones ---

def test_cargar_datos_cotizaciones_cuando_archivo_existe(monkeypatch):
    """
    Prueba que `cargar_datos_cotizaciones` lea y procese correctamente
    un archivo JSON cuando este existe.
    """
    # 1. Datos que simularemos que están en el archivo
    contenido_json_mock = json.dumps([
        {'ticker': 'BTC', 'nombre': 'Bitcoin', 'precio_usd': '50000.0'}
    ])
    
    # 2. Mocks
    # Simulamos que el archivo SÍ existe
    monkeypatch.setattr('os.path.exists', lambda path: True)
    
    # Simulamos la apertura del archivo, devolviendo nuestro contenido mock
    # io.StringIO es perfecto para simular un archivo de texto en memoria
    monkeypatch.setattr('builtins.open', lambda file, mode: io.StringIO(contenido_json_mock))
    
    # 3. Ejecutamos la función
    resultado = cargar_datos_cotizaciones()
    
    # 4. Verificamos los resultados
    assert len(resultado) == 1
    assert resultado[0]['ticker'] == 'BTC'
    assert resultado[0]['nombre'] == 'Bitcoin'
    # La función debe convertir el string del JSON a Decimal
    assert resultado[0]['precio_usd'] == Decimal('50000.0')

def test_cargar_datos_cotizaciones_cuando_archivo_no_existe(monkeypatch):
    """
    Prueba que `cargar_datos_cotizaciones` devuelva una lista vacía
    si el archivo de datos no existe.
    """
    # 1. Mock: Simulamos que el archivo NO existe
    monkeypatch.setattr('os.path.exists', lambda path: False)
    
    # 2. Ejecutamos la función
    resultado = cargar_datos_cotizaciones()
    
    # 3. Verificamos el resultado
    assert resultado == []

==================================================
=== FIN DEL REPORTE ===
==================================================
