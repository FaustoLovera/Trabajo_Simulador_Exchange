==================================================
=== REPORTE DE CÓDIGO CONSOLIDADO ===
Proyecto: Trabajo_Simulador_Exchange
Ruta: /Users/andreiveis/UADE/2do cuatrimestre/05_Algoritmos y Estructura de datos I/Trabajo_Simulador_Exchange
Generado el: Sat Jun 21 18:02:22 -03 2025
==================================================

--- INFORMACIÓN DEL REPOSITORIO GIT ---
Rama actual: dev
Último commit: 53e6765 - trading.html está roto el JS. (andreiveisuade, 3 minutes ago)
---

--- ESTRUCTURA DEL DIRECTORIO ---
.
├── .gitignore
├── backend
│   ├── __init__.py
│   ├── acceso_datos
│   │   ├── datos_billetera.py
│   │   ├── datos_cotizaciones.py
│   │   └── datos_historial.py
│   ├── app.py
│   ├── rutas
│   │   ├── __init__.py
│   │   ├── api_externa.py
│   │   ├── billetera_vista.py
│   │   ├── home.py
│   │   └── trading_vista.py
│   ├── servicios
│   │   ├── __init__.py
│   │   ├── api_cotizaciones.py
│   │   ├── estado_billetera.py
│   │   ├── trading_logica.py
│   │   └── velas_logica.py
│   ├── utilidades
│   └── utils
│       └── formatters.py
├── config.py
├── frontend
│   ├── static
│   │   ├── css
│   │   ├── img
│   │   └── js
│   └── templates
│       ├── billetera.html
│       ├── index.html
│       └── trading.html
├── README.md
└── requirements.txt

13 directories, 23 files
---

==================================================
=== ARCHIVO: ./.gitignore ===
==================================================

# ARCHIVOS PROPIOS NUESTROS
/datos/datos_cotizaciones.json
/datos/datos_velas.json
/datos/billetera.json
/datos/historial_operaciones.json


# Python
__pycache__/
backend/__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.env
.venv
env/
venv/
ENV/
.pytest_cache/
.coverage
coverage.xml
*.cover
.hypothesis/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
__MACOSX/

# IDEs and editors
.idea/
.vscode/
*.swp
*.swo
.project
.classpath
*.sublime-workspace
*.sublime-project

# Frontend
node_modules/
/dist
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env.local
.env.*.local
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
*.sqlite
*.sqlite3
*.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Backup files
*.bak
*.backup
*~

# Environment variables
.env
.env.*
!.env.example

# System Files
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
datos/billetera.json
datos/datos_cotizaciones.json
datos/datos_velas.json
*.pyc
# D2 files
*.d2
diagrama.png


==================================================
=== ARCHIVO: ./backend/__init__.py ===
==================================================

from flask import Flask
from config import FLASK_SECRET_KEY
from backend.rutas import registrar_rutas

def crear_app():
    """
    Crea y configura la instancia de la aplicación Flask.
    Este es el patrón de 'Application Factory'.
    """
    app = Flask(
        __name__,
        static_folder="../frontend/static",
        template_folder="../frontend/templates",
    )

    # Configura la clave secreta, necesaria para mensajes flash
    app.secret_key = FLASK_SECRET_KEY

    # Registra todos los blueprints (rutas) de la aplicación
    registrar_rutas(app)

    return app

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_billetera.py ===
==================================================

import json
import os
from decimal import Decimal, InvalidOperation
from config import BILLETERA_PATH, BALANCE_INICIAL_USDT


def cargar_billetera():
    """
    Carga la billetera desde el archivo JSON de forma segura.
    Si el archivo no existe, está vacío o corrupto, crea una billetera inicial.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    if not os.path.exists(BILLETERA_PATH) or os.path.getsize(BILLETERA_PATH) == 0:
        billetera_inicial = {"USDT": Decimal(BALANCE_INICIAL_USDT)}
        guardar_billetera(billetera_inicial)
        return billetera_inicial

    try:
        with open(BILLETERA_PATH, "r", encoding="utf-8") as f:
            datos_cargados = json.load(f)
            # Convierte todos los valores a Decimal, manejando posibles errores
            billetera = {}
            for ticker, cantidad_str in datos_cargados.items():
                try:
                    billetera[ticker] = Decimal(str(cantidad_str))
                except InvalidOperation:
                    print(
                        f"Advertencia: Valor inválido para {ticker} en billetera.json. Se usará 0."
                    )
                    billetera[ticker] = Decimal("0")
            return billetera
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: Archivo '{BILLETERA_PATH}' corrupto. Se reiniciará la billetera."
        )
        billetera_inicial = {"USDT": Decimal(BALANCE_INICIAL_USDT)}
        guardar_billetera(billetera_inicial)
        return billetera_inicial


def guardar_billetera(billetera):
    """
    Guarda el estado de la billetera en el archivo JSON.
    Convierte los valores Decimal a string para preservar la precisión.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    # Prepara la billetera para ser guardada, convirtiendo Decimal a string
    billetera_serializable = {
        ticker: str(cantidad) for ticker, cantidad in billetera.items()
    }

    with open(BILLETERA_PATH, "w", encoding="utf-8") as f:
        json.dump(billetera_serializable, f, indent=4)


==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_cotizaciones.py ===
==================================================

import json
import os
from decimal import Decimal
from config import COTIZACIONES_PATH

precios_cache = {}

def cargar_datos_cotizaciones():
    """
    Función interna y segura para cargar todas las cotizaciones del archivo JSON.
    Maneja archivos inexistentes o corruptos.
    """
    if not os.path.exists(COTIZACIONES_PATH) or os.path.getsize(COTIZACIONES_PATH) == 0:
        return []

    try:
        with open(COTIZACIONES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return []

def recargar_cache_precios():
    """
    Actualiza el diccionario de caché de precios en memoria desde el archivo JSON.
    Debe ser llamada después de que los datos de cotizaciones se actualizan.
    """
    global precios_cache
    print("🔄 Recargando caché de precios...")
    lista_criptos = cargar_datos_cotizaciones()
    
    precios_cache = {
        cripto.get("ticker", "").upper(): Decimal(str(cripto.get("precio_usd", "0")))
        for cripto in lista_criptos
    }
    print("✅ Caché de precios actualizado.")


def obtener_precio(ticker):
    """
    Obtiene el precio de un ticker específico desde el caché en memoria.
    Si el caché está vacío, lo carga por primera vez.
    """
    if not precios_cache:
        recargar_cache_precios()
    
    return precios_cache.get(ticker.upper())

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_historial.py ===
==================================================

import json
import os
from datetime import datetime
from decimal import Decimal
from config import HISTORIAL_PATH


def cargar_historial():
    """
    Carga el historial de transacciones desde el archivo JSON.
    Si el archivo no existe, está vacío o corrupto, devuelve una lista vacía.
    """
    if not os.path.exists(HISTORIAL_PATH) or os.path.getsize(HISTORIAL_PATH) == 0:
        return []

    try:
        with open(HISTORIAL_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: No se pudo leer o el archivo '{HISTORIAL_PATH}' está corrupto."
        )
        return []


def guardar_en_historial(
    tipo_operacion,
    moneda_origen,
    cantidad_origen,
    moneda_destino,
    cantidad_destino,
    valor_usd,
):
    """
    Guarda una nueva operación en el historial de transacciones.
    """
    # Asegurarse de que el directorio de datos exista
    os.makedirs(os.path.dirname(HISTORIAL_PATH), exist_ok=True)

    historial = cargar_historial()

    # Crear el diccionario para la nueva operación
    operacion = {
        "id": len(historial) + 1,
        "timestamp": datetime.now().isoformat(),
        "tipo": tipo_operacion,
        "origen": {"ticker": moneda_origen, "cantidad": str(cantidad_origen)},
        "destino": {"ticker": moneda_destino, "cantidad": str(cantidad_destino)},
        "valor_usd": str(valor_usd.quantize(Decimal("0.01"))),
    }

    # Añadir la nueva operación al principio de la lista
    historial.insert(0, operacion)

    # Escribir la lista completa de nuevo en el archivo
    with open(HISTORIAL_PATH, "w", encoding="utf-8") as f:
        json.dump(historial, f, indent=4)


==================================================
=== ARCHIVO: ./backend/app.py ===
==================================================

from . import crear_app

app = crear_app()

if __name__ == "__main__":
    app.run(debug=True)

==================================================
=== ARCHIVO: ./backend/rutas/__init__.py ===
==================================================

from .home import bp as home_bp
from .trading_vista import bp as trading_bp
from .billetera_vista import bp as billetera_bp
from .api_externa import bp as api_ruta_bp


def registrar_rutas(app):
    app.register_blueprint(home_bp)
    app.register_blueprint(trading_bp)
    app.register_blueprint(billetera_bp)
    app.register_blueprint(api_ruta_bp)


==================================================
=== ARCHIVO: ./backend/rutas/api_externa.py ===
==================================================

from flask import Blueprint, jsonify, render_template
import os 
import json
from backend.servicios.api_cotizaciones import obtener_datos_criptos_coingecko, obtener_velas_binance
from backend.acceso_datos.datos_cotizaciones import cargar_datos_cotizaciones
from config import VELAS_PATH


bp = Blueprint("api_externa", __name__, url_prefix="/api")


@bp.route("/actualizar")
def actualizar():
    """Actualiza los datos de criptomonedas y velas desde las APIs externas."""
    # ---> AÑADE ESTA LÍNEA EXACTAMENTE AQUÍ <---
    print("--- PING: Endpoint /api/actualizar ALCANZADO ---") 
    
    datos_criptos = obtener_datos_criptos_coingecko()
    obtener_velas_binance()
    return jsonify({"estado": "ok", "cantidad_criptos": len(datos_criptos)})


@bp.route("/cotizaciones")
def get_cotizaciones():
    """Retorna la lista completa de cotizaciones en formato JSON."""
    return jsonify(cargar_datos_cotizaciones())


@bp.route("/velas")
def obtener_datos_velas():
    """Retorna los datos de velas desde un archivo JSON de forma segura."""
    try:
        if not os.path.exists(VELAS_PATH) or os.path.getsize(VELAS_PATH) == 0:
            return jsonify([])

        with open(VELAS_PATH, "r", encoding="utf-8") as archivo:
            datos = json.load(archivo)
        return jsonify(datos)
    except (IOError, json.JSONDecodeError) as e:
        print("❌ Error leyendo datos_velas.json:", e)
        return jsonify({"error": "No se pudo leer el archivo de velas"}), 500

==================================================
=== ARCHIVO: ./backend/rutas/billetera_vista.py ===
==================================================

from flask import Blueprint, render_template, jsonify
from backend.servicios.estado_billetera import estado_actual_completo, obtener_historial_formateado
from backend.acceso_datos.datos_historial import cargar_historial
from backend.acceso_datos.datos_billetera import cargar_billetera

bp = Blueprint("billetera", __name__)


@bp.route("/billetera")
def mostrar_billetera():
    """Renderiza la página principal de la billetera (el contenedor HTML)."""
    # Ya no pasamos datos porque JS los cargará.
    return render_template("billetera.html")


@bp.route("/api/billetera/estado-completo")
def get_estado_billetera_completo():
    """Devuelve el estado financiero detallado de la billetera en JSON."""
    datos = estado_actual_completo()
    # La conversión de Decimal a string ya se realiza en la capa de servicio.
    return jsonify(datos)


@bp.route("/api/historial")
def get_historial_transacciones():
    """Devuelve el historial completo y formateado de transacciones en JSON."""
    return jsonify(obtener_historial_formateado())

==================================================
=== ARCHIVO: ./backend/rutas/home.py ===
==================================================

from flask import Blueprint, render_template

bp = Blueprint("home", __name__)

@bp.route("/")
def index():
    """
    Sirve el esqueleto de la página principal. 
    La carga y actualización de datos se maneja en el frontend.
    """
    return render_template("index.html")

==================================================
=== ARCHIVO: ./backend/rutas/trading_vista.py ===
==================================================

# backend/rutas/trading_vista.py (VERSIÓN CON RUTAS SEPARADAS)

from flask import Blueprint, request, redirect, url_for, render_template, flash

from backend.servicios.trading_logica import procesar_operacion_trading

bp = Blueprint("trading", __name__)


# RUTA GET para MOSTRAR la página de trading
@bp.route("/trading", methods=["GET"])
def mostrar_trading_page():
    return render_template("trading.html")


# RUTA POST para PROCESAR la operación de trading
@bp.route("/trading/operar", methods=["POST"])
def procesar_trading_form():
    """Procesa los datos del formulario de trading."""
    
    print(">>> DATOS RECIBIDOS DEL FORMULARIO:", request.form)
    
    exito, mensaje = procesar_operacion_trading(request.form)
    flash(mensaje, "success" if exito else "danger")

    # Siempre redirige de vuelta a la página principal de trading
    return redirect(url_for("trading.mostrar_trading_page"))


==================================================
=== ARCHIVO: ./backend/servicios/__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./backend/servicios/api_cotizaciones.py ===
==================================================

from decimal import Decimal
import requests
from backend.servicios.velas_logica import guardar_datos_cotizaciones, guardar_datos_velas
from config import COINGECKO_URL, BINANCE_URL, CANTIDAD_CRIPTOMONEDAS, CANTIDAD_VELAS
from backend.utils.formatters import formato_numero_grande, formato_porcentaje, formato_valor_monetario

def obtener_datos_criptos_coingecko():
    """
    Obtiene información del mercado de criptomonedas desde la API pública de CoinGecko.
    Añade campos formateados para que la UI pueda renderizarlos directamente.
    """
    params = {
        "vs_currency": "usd",
        "order": "market_cap_desc",
        "per_page": CANTIDAD_CRIPTOMONEDAS,
        "page": 1,
        "sparkline": "false",
        "price_change_percentage": "1h,24h,7d",
    }

    try:
        respuesta = requests.get(COINGECKO_URL, params)
        respuesta.raise_for_status()  # Lanza una excepción para errores HTTP (4xx o 5xx)
    except requests.exceptions.RequestException as e:
        print(f"❌ Error al obtener datos de CoinGecko: {str(e)}")
        return []

    print(f"✅ Estado de la respuesta CoinGecko: {respuesta.status_code}")

    try:
        datos = respuesta.json()
        resultado = [
            {
                "id": i,
                "nombre": dato.get("name"),
                "ticker": dato.get('symbol', '').upper(),
                "logo": dato.get("image"),
                
                # Datos crudos
                "precio_usd": str(Decimal(str(dato.get("current_price", 0)))),
                "1h_%": str(Decimal(str(dato.get("price_change_percentage_1h_in_currency", 0)))),
                "24h_%": str(Decimal(str(dato.get("price_change_percentage_24h_in_currency", 0)))),
                "7d_%": str(Decimal(str(dato.get("price_change_percentage_7d_in_currency", 0)))),
                "market_cap": str(Decimal(str(dato.get("market_cap", 0)))),
                "volumen_24h": str(Decimal(str(dato.get("total_volume", 0)))),
                "circulating_supply": str(Decimal(str(dato.get("circulating_supply", 0)))),

                # Datos pre-formateados para la UI
                "precio_usd_formatted": formato_valor_monetario(Decimal(str(dato.get("current_price", 0))), decimales=2),
                "1h_%_formatted": formato_porcentaje(Decimal(str(dato.get("price_change_percentage_1h_in_currency", 0)))),
                "24h_%_formatted": formato_porcentaje(Decimal(str(dato.get("price_change_percentage_24h_in_currency", 0)))),
                "7d_%_formatted": formato_porcentaje(Decimal(str(dato.get("price_change_percentage_7d_in_currency", 0)))),
                "market_cap_formatted": formato_numero_grande(Decimal(str(dato.get("market_cap", 0)))),
                "volumen_24h_formatted": formato_numero_grande(Decimal(str(dato.get("total_volume", 0)))),
                "circulating_supply_formatted": f"{Decimal(str(dato.get('circulating_supply', 0))):,.0f} {dato.get('symbol', '').upper()}"
            }
            for i, dato in enumerate(datos, start=1)
        ]
    except (KeyError, TypeError, ValueError) as e:
        print(f"❌ Error al procesar los datos de CoinGecko: {str(e)}")
        return []

    print(f"💡 Total de criptos procesadas: {len(resultado)}")
    guardar_datos_cotizaciones(resultado)
    return resultado


def obtener_velas_binance():
    """
    Obtiene datos históricos de velas (Klines) diarias del par BTC/USDT.
    """
    params = {
        "symbol": "BTCUSDT",
        "interval": "1d",
        "limit": CANTIDAD_VELAS,
    }
    try:
        respuesta = requests.get(BINANCE_URL, params)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"❌ Error al obtener datos de Binance: {str(e)}")
        return []

    print(f"✅ Estado de la respuesta Binance: {respuesta.status_code}")

    datos = respuesta.json()
    resultado = [
        {
            "time": int(vela[0] / 1000),
            "open": str(Decimal(vela[1])),
            "high": str(Decimal(vela[2])),
            "low": str(Decimal(vela[3])),
            "close": str(Decimal(vela[4])),
            "volume": str(Decimal(vela[5])),
        }
        for vela in datos
    ]
    
    print(f"💡 Total de velas procesadas: {len(resultado)}")
    guardar_datos_velas(resultado)
    return resultado

==================================================
=== ARCHIVO: ./backend/servicios/estado_billetera.py ===
==================================================

from decimal import Decimal
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_historial import cargar_historial
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.utils.formatters import formato_valor_monetario, formato_cantidad_cripto, formato_porcentaje, formato_fecha_hora

def calcular_detalle_cripto(ticker, cantidad_actual, precios, historial):
    """
    Calcula el estado financiero de una criptomoneda en base a su cantidad actual,
    el precio de mercado y el historial de compras.
    """
    cantidad_actual = Decimal(str(cantidad_actual))
    precio_actual = precios.get(ticker, Decimal("0"))
    valor_usdt = (cantidad_actual * precio_actual)

    compras = [
        op for op in historial
        if op.get("tipo") == "compra" and op.get("destino", {}).get("ticker") == ticker
    ]

    cantidad_comprada = sum(Decimal(str(op.get("destino", {}).get("cantidad", "0"))) for op in compras)
    total_invertido = sum(Decimal(str(op.get("valor_usd", "0"))) for op in compras)

    division_por_cero_segura = lambda num, den: num / den if den != 0 else Decimal("0")

    precio_promedio = division_por_cero_segura(total_invertido, cantidad_comprada)
    invertido_actual = cantidad_actual * precio_promedio
    ganancia = valor_usdt - invertido_actual
    porcentaje_ganancia = division_por_cero_segura(ganancia, invertido_actual) * Decimal("100")

    return {
        "ticker": ticker,
        "cantidad": cantidad_actual,
        "valor_usdt": valor_usdt,
        "precio_actual": precio_actual,
        "precio_promedio": precio_promedio,
        "invertido": invertido_actual,
        "ganancia_perdida": ganancia,
        "porcentaje_ganancia": porcentaje_ganancia,
    }

def estado_actual_completo():
    """
    Calcula un resumen financiero completo del portafolio, incluyendo campos
    pre-formateados para la UI.
    """
    billetera = cargar_billetera()
    precios = {ticker: obtener_precio(ticker) or Decimal("0") for ticker in billetera.keys()}
    historial = cargar_historial()

    detalles = [
        calcular_detalle_cripto(ticker, cantidad, precios, historial)
        for ticker, cantidad in billetera.items()
    ]

    total_usdt = sum(d["valor_usdt"] for d in detalles)
    division_por_cero_segura = lambda num, den: num / den if den != 0 else Decimal("0")
    
    for detalle in detalles:
        porcentaje_billetera = division_por_cero_segura(detalle["valor_usdt"], total_usdt) * Decimal("100")
        
        # Añadir campos de datos crudos adicionales
        detalle["porcentaje"] = porcentaje_billetera
        detalle["es_polvo"] = detalle["valor_usdt"] < Decimal("0.001")
        
        # Añadir campos formateados para la UI
        if detalle["ticker"] == 'USDT':
            detalle["cantidad_formatted"] = formato_valor_monetario(detalle["cantidad"], simbolo="")
        else:
            detalle["cantidad_formatted"] = formato_cantidad_cripto(detalle["cantidad"])
        
        detalle["precio_actual_formatted"] = formato_valor_monetario(detalle["precio_actual"], decimales=4)
        detalle["valor_usdt_formatted"] = formato_valor_monetario(detalle["valor_usdt"])
        detalle["ganancia_perdida_formatted"] = formato_valor_monetario(detalle["ganancia_perdida"])
        detalle["porcentaje_ganancia_formatted"] = formato_porcentaje(detalle["porcentaje_ganancia"])
        detalle["porcentaje_formatted"] = formato_porcentaje(porcentaje_billetera)

        # Convertir todos los Decimal a string para serialización JSON segura
        for k, v in detalle.items():
            if isinstance(v, Decimal):
                detalle[k] = str(v)
    
    return detalles

def obtener_historial_formateado():
    """
    Carga el historial de transacciones y le añade campos formateados para la UI.
    """
    historial = cargar_historial()
    historial_formateado = []

    for item in historial:
        # Determinar detalles de la transacción
        if item.get('tipo') == 'compra':
            cantidad = Decimal(str(item.get('destino', {}).get('cantidad', '0')))
            par = f"{item.get('destino', {}).get('ticker', '?')}/{item.get('origen', {}).get('ticker', '?')}"
        else:  # Venta
            cantidad = Decimal(str(item.get('origen', {}).get('cantidad', '0')))
            par = f"{item.get('origen', {}).get('ticker', '?')}/{item.get('destino', {}).get('ticker', '?')}"

        item_formateado = item.copy()

        # Añadir campos formateados para la UI
        item_formateado['fecha_formatted'] = formato_fecha_hora(item.get('timestamp'))
        item_formateado['par_formatted'] = par
        item_formateado['tipo_formatted'] = item.get('tipo', '').capitalize()
        item_formateado['cantidad_formatted'] = formato_cantidad_cripto(cantidad)
        item_formateado['valor_total_formatted'] = formato_valor_monetario(Decimal(str(item.get('valor_usd', '0'))))

        # Convertir todos los Decimal a string para serialización JSON segura
        for k, v in item_formateado.items():
            if isinstance(v, Decimal):
                item_formateado[k] = str(v)
            elif isinstance(v, dict):
                v_copy = v.copy()
                for sub_k, sub_v in v_copy.items():
                    if isinstance(sub_v, Decimal):
                        v_copy[sub_k] = str(sub_v)
                item_formateado[k] = v_copy

        historial_formateado.append(item_formateado)

    return historial_formateado

==================================================
=== ARCHIVO: ./backend/servicios/trading_logica.py ===
==================================================

from decimal import Decimal, InvalidOperation
from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_historial import guardar_en_historial

# --- FUNCIÓN DE PROCESAMIENTO DEL FORMULARIO ---

def procesar_operacion_trading(formulario):
    """
    TRADUCTOR: Recibe el formulario, lo valida y lo convierte en una llamada
    a la lógica de negocio principal (`realizar_swap`).
    """
    try:
        ticker_principal = formulario["ticker"].upper()
        accion = formulario["accion"]
        monto_form = Decimal(formulario["monto"])
        modo_ingreso = formulario["modo-ingreso"]
    except (KeyError, InvalidOperation, TypeError):
        return False, "❌ Error en los datos del formulario."

    if monto_form <= 0:
        return False, "❌ El monto debe ser un número positivo."

    # Determina las monedas de la operación basándose en la acción
    if accion == "comprar":
        moneda_origen = formulario.get("moneda-pago", "USDT").upper()
        moneda_destino = ticker_principal
    elif accion == "vender":
        moneda_origen = ticker_principal
        moneda_destino = formulario.get("moneda-recibir", "USDT").upper()
    else:
        return False, "❌ Acción no válida."

    if moneda_origen == moneda_destino:
        return False, "❌ La moneda de origen y destino no pueden ser la misma."

    # Llama a la lógica principal con los datos ya limpios y preparados
    return realizar_swap(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion)


# --- FUNCIONES AUXILIARES INTERNAS (LÓGICA DE NEGOCIO) ---

def _calcular_detalles_swap(accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt):
    """
    Calcula las cantidades de origen, destino y el valor total en USD del swap.
    Esta es una función interna y pura que solo realiza cálculos.

    Returns:
        tuple: (True, {'origen': cant, 'destino': cant, 'valor_usd': val}) o (False, "error").
    """
    # Validación de entrada específica para esta lógica
    if accion == 'vender' and modo_ingreso == 'total':
        return False, "❌ Al vender, debe ingresar la cantidad en modo 'Monto' (Cripto)."

    if accion not in ['comprar', 'vender']:
        return False, "❌ Acción de trading desconocida."

    # Lógica de cálculo
    if accion == 'comprar':
        if modo_ingreso == 'monto':  # Usuario ingresa la cantidad de CRIPTO a recibir
            cantidad_destino = monto_form
            valor_total_usd = cantidad_destino * precio_destino_usdt
            cantidad_origen = valor_total_usd / precio_origen_usdt
        else:  # 'total', usuario ingresa la cantidad de FIAT a gastar
            cantidad_origen = monto_form
            valor_total_usd = cantidad_origen * precio_origen_usdt
            cantidad_destino = valor_total_usd / precio_destino_usdt
    else:  # accion == 'vender'
        cantidad_origen = monto_form
        valor_total_usd = cantidad_origen * precio_origen_usdt
        cantidad_destino = valor_total_usd / precio_destino_usdt

    detalles = {
        "origen": cantidad_origen,
        "destino": cantidad_destino,
        "valor_usd": valor_total_usd
    }
    return True, detalles


def _validar_saldo_suficiente(billetera, moneda_origen, cantidad_requerida):
    """Verifica si hay suficiente saldo en la billetera para la operación."""
    saldo_disponible = billetera.get(moneda_origen, Decimal("0"))
    if cantidad_requerida > saldo_disponible:
        mensaje_error = f"❌ Saldo insuficiente. Tienes {saldo_disponible:.8f} {moneda_origen}."
        return False, mensaje_error
    return True, None


def _actualizar_billetera_y_guardar(billetera, moneda_origen, cantidad_origen, moneda_destino, cantidad_destino):
    """Resta la moneda de origen, suma la de destino y guarda el estado final."""
    billetera[moneda_origen] -= cantidad_origen
    
    # Si el saldo es muy pequeño ("polvo"), se elimina la moneda de la billetera
    if billetera[moneda_origen] <= Decimal("1e-8"):
        billetera.pop(moneda_origen, None)

    billetera[moneda_destino] = billetera.get(moneda_destino, Decimal("0")) + cantidad_destino
    
    guardar_billetera(billetera)


def _registrar_operacion_historial(moneda_origen, cantidad_origen, moneda_destino, cantidad_destino, valor_usd):
    """Determina el tipo de operación y la guarda en el historial."""
    if moneda_origen == "USDT":
        tipo_operacion = "compra"
    elif moneda_destino == "USDT":
        tipo_operacion = "venta"
    else:
        tipo_operacion = "intercambio"
        
    guardar_en_historial(
        tipo_operacion,
        moneda_origen,
        cantidad_origen.quantize(Decimal("0.00000001")),
        moneda_destino,
        cantidad_destino.quantize(Decimal("0.00000001")),
        valor_usd,
    )


# --- FUNCIÓN ORQUESTADORA PRINCIPAL ---

def realizar_swap(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion):
    """
    Orquesta la operación de swap completa: obtiene precios, calcula, valida y ejecuta.
    """
    # 1. Obtener precios
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)

    if precio_origen_usdt is None or precio_destino_usdt is None or precio_destino_usdt.is_zero():
        return False, "❌ No se pudo obtener la cotización para realizar el swap."

    # 2. Calcular los detalles del swap
    exito_calculo, resultado = _calcular_detalles_swap(
        accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt
    )
    if not exito_calculo:
        return False, resultado  # resultado aquí es el mensaje de error

    cantidad_origen = resultado["origen"]
    cantidad_destino = resultado["destino"]
    valor_total_usd = resultado["valor_usd"]

    # 3. Cargar billetera y validar saldo
    billetera = cargar_billetera()
    exito_validacion, mensaje_error = _validar_saldo_suficiente(billetera, moneda_origen, cantidad_origen)
    if not exito_validacion:
        return False, mensaje_error

    # 4. Ejecutar la operación (si todo es válido hasta ahora)
    _actualizar_billetera_y_guardar(billetera, moneda_origen, cantidad_origen, moneda_destino, cantidad_destino)
    
    # 5. Registrar en el historial
    _registrar_operacion_historial(moneda_origen, cantidad_origen, moneda_destino, cantidad_destino, valor_total_usd)

    # 6. Devolver mensaje de éxito
    mensaje_exito = f"✅ Swap exitoso: {cantidad_origen:.8f} {moneda_origen} → {cantidad_destino:.8f} {moneda_destino}."
    return True, mensaje_exito

==================================================
=== ARCHIVO: ./backend/servicios/velas_logica.py ===
==================================================

import json
import os
from decimal import Decimal
from config import COTIZACIONES_PATH, VELAS_PATH


def guardar_datos_cotizaciones(data):
    os.makedirs(os.path.dirname(COTIZACIONES_PATH), exist_ok=True)
    print("💾 Guardando datos en datos_cotizaciones.json...")
    print(f"Cantidad de criptos a guardar: {len(data)}")
    print("📁 Guardando en:", os.path.abspath(COTIZACIONES_PATH))

    try:
        with open(COTIZACIONES_PATH, "w") as archivo:
            json.dump(
                data,
                archivo,
                indent=4,
                default=lambda o: float(o) if isinstance(o, Decimal) else o,
            )
        print("✅ Datos guardados correctamente")
    except (IOError, TypeError) as e:
        print("❌ Error al guardar el archivo:", e)


def cargar_datos_cotizaciones():
    if not os.path.exists(COTIZACIONES_PATH):
        return []
    with open(COTIZACIONES_PATH, "r") as archivo:
        return json.load(archivo)


def guardar_datos_velas(data):
    os.makedirs(os.path.dirname(VELAS_PATH), exist_ok=True)
    print("💾 Guardando datos en datos_velas.json...")
    print(f"Cantidad de velas a guardar: {len(data)}")
    print("📁 Guardando en:", os.path.abspath(VELAS_PATH))

    try:
        with open(VELAS_PATH, "w") as archivo:
            json.dump(
                data,
                archivo,
                indent=4,
                default=lambda o: float(o) if isinstance(o, Decimal) else o,
            )
        print("✅ Datos guardados correctamente")
    except (IOError, TypeError) as e:
        print("❌ Error al guardar el archivo:", e)


==================================================
=== ARCHIVO: ./backend/utils/formatters.py ===
==================================================

# backend/utils/formatters.py
from datetime import datetime
from decimal import Decimal

def formato_numero_grande(valor, simbolo="$"):
    """Formatea números grandes con abreviaturas y símbolo de moneda."""
    if not isinstance(valor, (int, float, Decimal)):
        return "-"
    num = Decimal(valor)
    
    if num >= 1_000_000_000_000:
        return f"{simbolo}{(num / Decimal('1e12')).quantize(Decimal('0.01'))}T"
    if num >= 1_000_000_000:
        return f"{simbolo}{(num / Decimal('1e9')).quantize(Decimal('0.01'))}B"
    if num >= 1_000_000:
        return f"{simbolo}{(num / Decimal('1e6')).quantize(Decimal('0.01'))}M"
    return f"{simbolo}{num:,.0f}"

def formato_porcentaje(valor):
    """Formatea un porcentaje con 2 decimales y el signo %."""
    if not isinstance(valor, (int, float, Decimal)):
        return "-%"
    return f"{Decimal(valor):.2f}%"

# ===> FUNCIÓN CORREGIDA <===
def formato_valor_monetario(valor, simbolo="$", decimales=2):
    """Formatea un valor como moneda con N decimales."""
    if not isinstance(valor, (int, float, Decimal)):
        return "-"
    # Usamos un f-string con una expresión para formatear dinámicamente los decimales
    return f"{simbolo}{Decimal(valor):,.{decimales}f}"

def formato_cantidad_cripto(valor, decimales=8):
    """Formatea una cantidad de cripto con N decimales."""
    if not isinstance(valor, (int, float, Decimal)):
        return "-"
    return f"{Decimal(valor):.{decimales}f}"

def formato_fecha_hora(timestamp):
    """Formatea un timestamp UNIX a un string de fecha y hora local."""
    if not isinstance(timestamp, (int, float)):
        return "--:--"
    try:
        # Convierte el timestamp a un objeto datetime
        dt_object = datetime.fromtimestamp(timestamp)
        # Formatea la fecha y la hora en un formato legible
        return dt_object.strftime("%d/%m/%Y %H:%M:%S")
    except (ValueError, TypeError):
        return "--:--"

==================================================
=== ARCHIVO: ./config.py ===
==================================================

import os
from decimal import getcontext, ROUND_HALF_DOWN

# Base del proyecto y carpeta de datos
PROYECTO_DIR = os.path.dirname(os.path.abspath(__file__))
BASE_DATA_DIR = os.path.join(PROYECTO_DIR, "datos")
os.makedirs(BASE_DATA_DIR, exist_ok=True)

# Rutas de archivos JSON
COTIZACIONES_PATH = os.path.join(BASE_DATA_DIR, "cotizaciones.json")
BILLETERA_PATH = os.path.join(BASE_DATA_DIR, "billetera.json")
HISTORIAL_PATH = os.path.join(BASE_DATA_DIR, "historial.json")
VELAS_PATH = os.path.join(BASE_DATA_DIR, "velas.json")

# Configuración general
BALANCE_INICIAL_USDT = "10000"
FLASK_SECRET_KEY = os.environ.get("FLASK_SECRET_KEY", "clave_por_defecto_insegura")

# URLs de APIs
COINGECKO_URL = "https://api.coingecko.com/api/v3/coins/markets"
BINANCE_URL = "https://api.binance.com/api/v3/klines"

# Parámetros de scraping
CANTIDAD_CRIPTOMONEDAS = 100
CANTIDAD_VELAS = 250

# Decimal global
getcontext().prec = 28
getcontext().rounding = ROUND_HALF_DOWN


==================================================
=== ARCHIVO: ./frontend/static/css/styles_index.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030;
    color: #f0c000;
}

.logo-cripto {
    margin-right: 1.5rem;
    vertical-align: middle;
}

.nombre-cripto {
    padding-left: 0.75rem;
    font-weight: bold;
    font-size: 1.05rem;
}

.logo-cripto {
    margin-right: 10px;
    vertical-align: middle;
}

.ticker-cripto {
    color: #aaaaaa;
    font-size: 0.85rem;
    margin-left: 4px;
}

table thead th {
    font-size: 0.85rem;
    font-weight: 500;
    text-transform: uppercase;
}

td,
th {
    white-space: nowrap;
}

/* PRECIO */
table td:nth-child(3),
table th:nth-child(3) {
    min-width: 100px;
    font-weight: bold;
}
table td:nth-child(4),
table th:nth-child(4),
table td:nth-child(5),
table th:nth-child(5),
table td:nth-child(6),
table th:nth-child(6) {
    min-width: 80px; /* 1H, 24H, 7D */
}
table td:nth-child(8),
table th:nth-child(8),
table td:nth-child(9),
table th:nth-child(9) {
    min-width: 100px; /* VOLUME, SUPPLY */
}

/* Limita el ancho de la columna Name (columna 2) */
table td:nth-child(2),
table th:nth-child(2) {
    max-width: 220px; /* probá ajustar este valor */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.positivo {
    color: var(--color-verde);
    font-weight: 500;
}

.negativo {
    color: var(--color-rojo);
    font-weight: 500;
}

.flecha-verde,
.flecha-roja {
    font-size: 0.7em; /* más pequeño que el texto base */
    vertical-align: middle;
    margin-right: 4px;
}

.flecha-verde {
    color: var(--color-verde);
    margin-right: 4px;
}

.flecha-roja {
    color: var(--color-rojo);
    margin-right: 4px;
}


==================================================
=== ARCHIVO: ./frontend/static/css/styles_trading.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
    /* --bs-dark-rgb: 30, 30, 30 !important;
    --bs-body-bg: 44, 44, 44 !important;
    --bs-border-width: 1px solid rgb(219, 71, 71) !important; */
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030 !important;
    color: #f0c000;
}

#chart {
    display: block;
    overflow: hidden;
    width: 100%;
    max-width: 100%;
}

.text-verde {
    color: var(--color-verde);
}

.text-rojo {
    color: var(--color-rojo);
}

/* FORMULARIO TRADING */

.form-control {
    background-color: 44, 44, 44 !important;
}

/* CAMBIO DE COLOR DEL PUNTO DEL SLIDER THUMB DINÁMICO */

/* Chrome/Safari */
input[type='range'].slider-compra::-webkit-slider-thumb {
    background-color: rgb(31, 191, 113) !important; /* verde */
}

input[type='range'].slider-venta::-webkit-slider-thumb {
    background-color: rgb(226, 33, 52) !important; /* rojo */
}

/* Firefox */
input[type='range'].slider-compra::-moz-range-thumb {
    background-color: rgb(31, 191, 113) !important;
}

input[type='range'].slider-venta::-moz-range-thumb {
    background-color: rgb(226, 33, 52) !important;
}


==================================================
=== ARCHIVO: ./frontend/static/js/components/chartRenderer.js ===
==================================================

// Manages the creation and updating of the candlestick chart.
export function initializeChart(data) {
    console.log('📈 Initializing candlestick chart...');
    const chartContainer = document.getElementById('chart');
    if (!chartContainer) {
        console.warn("Element #chart not found. Cannot render chart.");
        return;
    }

    if (!window.LightweightCharts) {
        console.error("LightweightCharts library is not loaded. Make sure it loads before this script.");
        return;
    }

    const chart = window.LightweightCharts.createChart(chartContainer, {
        width: chartContainer.clientWidth,
        height: 500,
        layout: { textColor: '#ccc', background: { type: 'solid', color: '#1E1E1E' } },
        grid: { vertLines: { color: '#2B2B2B' }, horzLines: { color: '#2B2B2B' } },
        priceScale: { borderColor: '#485c7b' },
        timeScale: { borderColor: '#485c7b' },
    });

    const candleSeries = chart.addCandlestickSeries({
        upColor: 'rgb(31, 191, 113)',
        downColor: 'rgb(226, 33, 52)',
        borderDownColor: 'rgb(226, 33, 52)',
        borderUpColor: 'rgb(31, 191, 113)',
        wickDownColor: '#838ca1',
        wickUpColor: '#838ca1',
    });

    const volumeSeries = chart.addHistogramSeries({
        priceFormat: { type: 'volume' },
        priceScaleId: '',
    });
    volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });

    if (data && data.length > 0) {
        const candleData = data.map(item => ({
            time: item.time, open: Number(item.open), high: Number(item.high), low: Number(item.low), close: Number(item.close)
        }));
        const volumeData = data.map(item => ({
            time: item.time, value: Number(item.volume), color: Number(item.close) > Number(item.open) ? 'rgba(31, 191, 113, 0.5)' : 'rgba(226, 33, 52, 0.5)'
        }));
        candleSeries.setData(candleData);
        volumeSeries.setData(volumeData);
    }
    
    const volumeCheckbox = document.getElementById('toggleVolume');
    if (volumeCheckbox) {
        volumeCheckbox.addEventListener('change', (e) => {
            volumeSeries.applyOptions({ visible: e.target.checked });
        });
    }

    chart.timeScale().fitContent();
    new ResizeObserver(() => chart.applyOptions({ width: chartContainer.clientWidth })).observe(chartContainer);
}


==================================================
=== ARCHIVO: ./frontend/static/js/components/domElements.js ===
==================================================

// Almacena referencias a los elementos del DOM para un acceso rápido y centralizado.
export const DOMElements = {
    form: $('#formulario-trading'),
    selectorPrincipal: $('#cripto'),
    selectorPagarCon: $('#moneda-pago'),
    selectorRecibirEn: $('#moneda-recibir'),
    botonComprar: $('.boton-comprar'),
    botonVender: $('.boton-vender'),
    botonConfirmar: $('.boton-confirmar'),
    inputAccion: $('#accion'),
    campoPagarCon: $('#campo-pagar-con'),
    campoRecibirEn: $('#campo-recibir-en'),
    spanSaldoDisponible: $('#saldo-disponible'),
    radioModoIngreso: $('input[name="modo-ingreso"]'),
    labelMonto: $('label[for="monto"]'),
    inputMonto: $('#monto'),
    sliderMonto: $('#slider-monto'),
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/formLogic.js ===
==================================================

// frontend/static/js/components/formLogic.js

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';

export const FormLogic = {
    /**
     * Llena un selector de Bootstrap con opciones y selecciona un valor por defecto.
     * @param {jQuery} selector - El elemento selector de jQuery.
     * @param {Array<Object>} lista - Lista de objetos para poblar el selector (cada objeto debe tener 'ticker' y 'nombre').
     * @param {string} valorPorDefecto - El valor a seleccionar por defecto.
     * @returns {string|null} El ticker seleccionado o null si la lista está vacía.
     */
    popularSelector(selector, lista, valorPorDefecto) {
        selector.empty();
        // CORRECCIÓN: Asegurarse de que se usan las propiedades correctas (ticker, nombre)
        lista.forEach(({ ticker, nombre }) => selector.append(new Option(`${nombre} (${ticker})`, ticker)));
        const valorFinal = (valorPorDefecto && lista.some(m => m.ticker === valorPorDefecto)) ? valorPorDefecto : (lista.length > 0 ? lista[0].ticker : null);
        if (valorFinal) {
            selector.val(valorFinal).trigger('change');
        }
        return valorFinal;
    },

    /**
     * Calcula el monto basado en el valor del slider y el saldo disponible.
     * Protegido contra el caso donde window.ownedCoins aún no está cargado.
     * @returns {number} El monto calculado.
     */
    calcularMontoSlider() {
        // Añade este log para verificar si la función se llama
        console.log("DEBUG: Se ha llamado a calcularMontoSlider()"); 

        // ----> CORRECCIÓN DEFENSIVA CLAVE <----
        // Si window.ownedCoins aún no se ha cargado desde la API, no hagas nada y devuelve 0.
        // Esto evita el crash durante la inicialización.
        if (!window.ownedCoins) {
             console.log("DEBUG: window.ownedCoins es undefined. Saliendo de calcularMontoSlider.");
             return 0;
        }
        
        const porcentaje = parseFloat(DOMElements.sliderMonto.val());
        const esCompra = UIState.esModoCompra();
        
        const tickerDeSaldo = esCompra ? UIState.getTickerPago() : UIState.getTickerPrincipal();
        
        // Ahora que sabemos que window.ownedCoins existe, podemos usarlo de forma segura.
        const moneda = window.ownedCoins.find(m => m.ticker === tickerDeSaldo);
        const saldoDisponible = moneda ? parseFloat(moneda.cantidad) : 0; // Usar .cantidad
        
        if (!tickerDeSaldo) return 0;

        return (saldoDisponible * porcentaje) / 100.0;
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/tablaCotizacionesUI.js ===
==================================================

// Controla la renderización y actualización de la tabla de cotizaciones.

import { fetchCotizaciones } from '../services/apiService.js';
import { UIUpdater } from './uiUpdater.js';

const cuerpoTabla = document.getElementById('tabla-datos');

function createFilaCotizacionHTML(cripto, index) {
    // Helper para no repetir la lógica de positivo/negativo
    const getPerfIndicator = (value) => {
        const isPositive = parseFloat(value) >= 0;
        return {
            className: isPositive ? 'positivo' : 'negativo',
            arrow: isPositive ? '▲' : '▼'
        };
    };

    const perf1h = getPerfIndicator(cripto['1h_%']);
    const perf24h = getPerfIndicator(cripto['24h_%']);
    const perf7d = getPerfIndicator(cripto['7d_%']);

    return `
        <tr>
            <td class="text-start px-3">${index}</td>
            <td class="text-start px-3">
                <img src="${cripto.logo}" width="20" class="logo-cripto" alt="${cripto.ticker} logo">
                <span class="nombre-cripto">${cripto.nombre}</span>
                <span class="ticker-cripto">(${cripto.ticker})</span>
            </td>
            <td class="text-start px-3 fw-bold">${cripto.precio_usd_formatted}</td>
            
            <td class="text-end px-3">
                <span class="${perf1h.className}">
                    <span class="flecha">${perf1h.arrow}</span>
                    ${cripto['1h_%_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${perf24h.className}">
                    <span class="flecha">${perf24h.arrow}</span>
                    ${cripto['24h_%_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${perf7d.className}">
                    <span class="flecha">${perf7d.arrow}</span>
                    ${cripto['7d_%_formatted']}
                </span>
            </td>
            
            <td class="text-end px-3">${cripto.market_cap_formatted}</td>
            <td class="text-end px-3">${cripto.volumen_24h_formatted}</td>
            <td class="text-end px-3">${cripto.circulating_supply_formatted}</td>
        </tr>
    `;
}

export async function renderTabla() {
    if (!cuerpoTabla) return;
    try {
        const cotizaciones = await fetchCotizaciones();
        if (!cotizaciones || cotizaciones.length === 0) {
            cuerpoTabla.innerHTML =
                '<tr><td colspan="9" class="text-center text-muted py-4">No hay datos disponibles.</td></tr>';
            return;
        }
        cuerpoTabla.innerHTML = cotizaciones.map((cripto, index) => createFilaCotizacionHTML(cripto, index + 1)).join('');
    } catch (error) {
        console.error('❌ Error al renderizar la tabla de cotizaciones:', error);
        UIUpdater.mostrarMensajeError('No se pudieron cargar las cotizaciones. La información puede estar desactualizada.');
        // Opcional: mostrar un estado de error en la propia tabla
        cuerpoTabla.innerHTML = '<tr><td colspan="9" class="text-center text-danger py-4">Error al cargar las cotizaciones.</td></tr>';
    }
}


==================================================
=== ARCHIVO: ./frontend/static/js/components/uiState.js ===
==================================================

// Gestiona el estado de la interfaz de usuario, como el modo de operación (compra/venta).
import { DOMElements } from './domElements.js';

export const UIState = {
    esModoCompra() {
        return DOMElements.inputAccion.val() === 'comprar';
    },
    getModoIngreso() {
        return DOMElements.radioModoIngreso.filter(':checked').val();
    },
    getTickerPrincipal() {
        return DOMElements.selectorPrincipal.val();
    },
    getTickerPago() {
        return DOMElements.selectorPagarCon.val();
    },
    getTickerRecibo() {
        return DOMElements.selectorRecibirEn.val();
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiUpdater.js ===
==================================================

// Contiene funciones para actualizar dinámicamente la interfaz de usuario.
import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';

export const UIUpdater = {
    actualizarBotones() {
        const esCompra = UIState.esModoCompra();
        DOMElements.botonConfirmar
            .text(esCompra ? 'COMPRAR' : 'VENDER')
            .toggleClass('btn-success', esCompra)
            .toggleClass('btn-danger', !esCompra);
        DOMElements.botonComprar
            .toggleClass('active btn-success', esCompra)
            .toggleClass('btn-outline-secondary', !esCompra);
        DOMElements.botonVender
            .toggleClass('active btn-danger', !esCompra)
            .toggleClass('btn-outline-secondary', esCompra);
    },

    actualizarVisibilidadCampos() {
        const esCompra = UIState.esModoCompra();
        DOMElements.campoPagarCon.toggle(esCompra);
        DOMElements.campoRecibirEn.toggle(!esCompra);
        DOMElements.selectorPagarCon.prop('disabled', !esCompra);
        DOMElements.selectorRecibirEn.prop('disabled', esCompra);
    },

    actualizarLabelMonto() {
        const esModoMonto = UIState.getModoIngreso() === 'monto';
        const esCompra = UIState.esModoCompra();
        let tickerRelevante = '';

        if (esCompra) {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerPago();
        } else {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerRecibo();
        }

        const etiqueta = esModoMonto ? 'Monto' : 'Total';
        DOMElements.labelMonto.text(`${etiqueta} (${tickerRelevante || '...'})`);
    },

    mostrarSaldo(ticker) {
        if (!ticker) {
            DOMElements.spanSaldoDisponible.text('--');
            return;
        }
        // Busca la moneda en el estado completo para obtener el saldo formateado.
        const moneda = window.monedasPropias.find(m => m.ticker === ticker);
        const saldoFormateado = moneda ? moneda.cantidad_formatted : '0.00000000';
        DOMElements.spanSaldoDisponible.text(`${saldoFormateado} ${ticker}`);
    },

    setInputMonto(valor) {
        DOMElements.inputMonto.val(valor);
    },

    resetSlider() {
        DOMElements.sliderMonto.val(0);
    },

    renderHistorial(historialData) {
        const tablaHistorial = $('#tabla-historial');
        if (!tablaHistorial.length) return;

        if (historialData.length === 0) {
            tablaHistorial.html('<tr><td colspan="5" class="text-center text-muted py-3">No hay transacciones en el historial.</td></tr>');
            return;
        }

        const historialHTML = historialData.map((item) => {
            const claseTipo = item.tipo === 'compra' ? 'text-success' : 'text-danger';

            return `
                <tr>
                    <td class="text-start ps-3">${item.fecha_formatted}</td>
                    <td class="fw-bold">${item.par_formatted}</td>
                    <td class="${claseTipo}">${item.tipo_formatted}</td>
                    <td>${item.cantidad_formatted}</td>
                    <td>${item.valor_total_formatted}</td>
                </tr>
            `;
        }).join('');

        tablaHistorial.html(historialHTML);
    },

    /**
     * Muestra un mensaje de error en un contenedor de alertas en la parte superior de la página.
     * @param {string} mensaje - El mensaje de error a mostrar.
     * @param {string} [containerSelector='#error-container'] - El selector del contenedor donde se mostrará el error.
     */
    mostrarMensajeError(mensaje, containerSelector = '#error-container') {
        const errorContainer = $(containerSelector);
        if (!errorContainer.length) {
            console.error(`Error container '${containerSelector}' not found.`);
            return;
        }

        const alertHTML = `
            <div class="alert alert-danger alert-dismissible fade show" role="alert">
                ${mensaje}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        `;

        // Limpia mensajes anteriores y añade el nuevo para evitar acumulación.
        errorContainer.html(alertHTML);
    },
};

==================================================
=== ARCHIVO: ./frontend/static/js/pages/billeteraPage.js ===
==================================================

// Orquesta la inicialización y la lógica principal de la página de la billetera.
import { fetchEstadoBilletera } from '../services/apiService.js';
import { UIUpdater } from '../components/uiUpdater.js';

/**
 * Crea una fila HTML para la tabla de la billetera a partir de un objeto de cripto.
 * @param {object} cripto - El objeto que contiene los datos de la cripto.
 * @returns {string} El string HTML para la fila <tr>.
 */
function createBilleteraRowHTML(cripto) {
    // La lógica de color se basa en el valor numérico crudo.
    const colorGanancia = parseFloat(cripto.ganancia_perdida) >= 0 ? 'positivo' : 'negativo';
    
    // Se usan directamente los campos _formatted que vienen del backend.
    return `
        <tr>
            <td class="text-center">${cripto.ticker} ${cripto.es_polvo ? '<span class="text-muted small">(polvo)</span>' : ''}</td>
            <td class="text-center">${cripto.cantidad_formatted}</td>
            <td class="text-center">${cripto.precio_actual_formatted}</td>
            <td class="text-center">${cripto.valor_usdt_formatted}</td>
            <td class="text-center ${colorGanancia}">${cripto.ganancia_perdida_formatted}</td>
            <td class="text-center ${colorGanancia}">${cripto.porcentaje_ganancia_formatted}</td>
            <td class="text-center">${cripto.porcentaje_formatted}</td>
        </tr>
    `;
}

/**
 * Renderiza la tabla completa de la billetera en el DOM.
 */
async function renderBilletera() {
    const cuerpoTabla = document.getElementById('tabla-billetera');
    if (!cuerpoTabla) {
        console.warn("Elemento #tabla-billetera no encontrado.");
        return;
    }

    console.log("🔄 Cargando datos de la billetera...");
    try {
        const datosBilletera = await fetchEstadoBilletera();

        if (datosBilletera.length === 0) {
            cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-muted py-4">Tu billetera está vacía.</td></tr>';
            return;
        }

        const tablaHTML = datosBilletera.map(createBilleteraRowHTML).join('');
        cuerpoTabla.innerHTML = tablaHTML;
        console.log("✅ Billetera renderizada correctamente.");
    } catch (error) {
        console.error('❌ Error al renderizar la billetera:', error);
        // Muestra el error en la consola, en la UI global y en la tabla misma.
        UIUpdater.mostrarMensajeError('No se pudieron cargar los datos de la billetera. Por favor, intenta recargar la página.');
        cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-danger py-4">Error al cargar los datos.</td></tr>';
    }
}

// Iniciar el proceso cuando el DOM esté listo.
document.addEventListener('DOMContentLoaded', () => {renderBilletera()});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/indexPage.js ===
==================================================

// frontend/static/js/pages/indexPage.js

import { triggerActualizacionDatos } from '../services/apiService.js';
import { renderTabla } from '../components/tablaCotizacionesUI.js';

const UPDATE_INTERVAL_MS = 15000; // 15 segundos

/**
 * Función unificada para actualizar datos y renderizar la tabla.
 */
async function actualizarYRenderizar() {
    console.log("🔄 Actualizando y renderizando cotizaciones...");
    try {
        // Primero, le pedimos al backend que se actualice desde la API externa.
        await triggerActualizacionDatos();
        // Luego, renderizamos la tabla con los datos frescos.
        await renderTabla();
        console.log("✅ Tabla de cotizaciones actualizada.");
    } catch (error) {
        console.error("❌ Falló el ciclo de actualización:", error);
        // Opcional: podrías mostrar un mensaje de error en la UI aquí.
    }
}

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('tabla-datos')) {
        console.log("🚀 Inicializando página de cotizaciones.");
        
        // 1. Ejecuta la actualización INMEDIATAMENTE al cargar la página.
        actualizarYRenderizar();
        
        // 2. Luego, establece el intervalo para futuras actualizaciones.
        setInterval(actualizarYRenderizar, UPDATE_INTERVAL_MS);
    }
});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/tradingPage.js ===
==================================================

// Orquesta la inicialización y la lógica principal de la página de trading.
import { DOMElements } from '../components/domElements.js';
import { UIState } from '../components/uiState.js';
import { UIUpdater } from '../components/uiUpdater.js';
import { FormLogic } from '../components/formLogic.js';
import { initializeChart } from '../components/chartRenderer.js';
import { fetchCotizaciones, fetchEstadoBilletera, fetchHistorial, fetchVelas } from '../services/apiService.js';

console.log("1. tradingPage.js - Script cargado e importaciones OK");

document.addEventListener('DOMContentLoaded', () => {
    console.log("2. tradingPage.js - DOMContentLoaded se disparó");

    // Variables globales para almacenar datos
    window.allCryptos = [];
    // Declaración explícita de window.ownedCoins
    window.ownedCoins = []; 

    /**
     * Actualiza la interfaz de usuario según el modo de trading (compra/venta).
     * @param {string} mode - El modo de operación ('comprar' o 'vender').
     */
    function setTradeMode(mode) {
        DOMElements.inputAccion.val(mode); 
        
        UIUpdater.actualizarBotones();
        UIUpdater.actualizarVisibilidadCampos();
        let tickerForBalance = '';
        if (UIState.esModoCompra()) {
            const cryptosWithoutUSDT = window.allCryptos.filter(c => c.ticker !== 'USDT');
            FormLogic.popularSelector(DOMElements.selectorPrincipal, cryptosWithoutUSDT, 'BTC');
            tickerForBalance = UIState.getTickerPago();
        } else {
            // Usamos window.ownedCoins aquí.
            // Si window.ownedCoins es null o undefined o vacío, puede causar problemas.
            // Añadimos una comprobación defensiva aquí.
            if (!window.ownedCoins || window.ownedCoins.length === 0) {
                console.warn("WARN: window.ownedCoins no está disponible o está vacío al intentar configurar el modo de venta.");
                // Podríamos intentar poblar con algo genérico o simplemente no hacer nada.
                // Por ahora, si no hay ownedCoins, no poblamos el selector principal.
                tickerForBalance = null; // O manejarlo de otra forma
            } else {
                const defaultTicker = window.ownedCoins[0].ticker; // Accede al primer elemento si existe
                tickerForBalance = FormLogic.popularSelector(DOMElements.selectorPrincipal, window.ownedCoins, defaultTicker);
            }
        }
        
        UIUpdater.mostrarSaldo(tickerForBalance);
        UIUpdater.actualizarLabelMonto();
        UIUpdater.resetSlider();
    }

    /**
     * Configura todos los event listeners para los elementos interactivos del formulario y el gráfico.
     */
    function setupEventListeners() {
        DOMElements.botonComprar.on('click', () => setTradeMode('comprar'));
        DOMElements.botonVender.on('click', () => setTradeMode('vender'));

        DOMElements.selectorPrincipal.on('change', () => {
            UIUpdater.actualizarLabelMonto();
            if (!UIState.esModoCompra()) {
                // Aquí también puede ser que window.ownedCoins no esté listo si el usuario cambia a venta muy rápido.
                // Pero la protección en setTradeMode debería mitigar esto.
                UIUpdater.mostrarSaldo(UIState.getTickerPrincipal());
            }
        });

        DOMElements.selectorPagarCon.on('change', () => {
            UIUpdater.actualizarLabelMonto();
            if (UIState.esModoCompra()) UIUpdater.mostrarSaldo(UIState.getTickerPago());
        });
        
        DOMElements.selectorRecibirEn.on('change', UIUpdater.actualizarLabelMonto);
        DOMElements.radioModoIngreso.on('change', UIUpdater.actualizarLabelMonto);

        DOMElements.sliderMonto.on('input', () => {
            const calculatedValue = FormLogic.calcularMontoSlider();
            UIUpdater.setInputMonto(calculatedValue.toFixed(8)); 
        });
    }

    async function initialize() {
        console.log("3. tradingPage.js - Entrando en initialize()");
        try {
            console.log("4. tradingPage.js - A punto de llamar a Promise.all");
            const [cotizaciones, estadoBilletera, historial, velas] = await Promise.all([
                fetchCotizaciones(),
                fetchEstadoBilletera(),
                fetchHistorial(),
                fetchVelas()
            ]);
            console.log("5. tradingPage.js - Promise.all completado con ÉXITO");
            
            window.allCryptos = cotizaciones;
            // CORRECCIÓN: Asegurarse de usar 'ownedCoins' y filtrar correctamente
            window.ownedCoins = estadoBilletera.filter(moneda => parseFloat(moneda.cantidad) > 0);
            console.log(`6. tradingPage.js - Variables globales pobladas: allCryptos=${window.allCryptos.length}, ownedCoins=${window.ownedCoins.length}`);

            UIUpdater.renderHistorial(historial);
            initializeChart(velas);
            console.log("7. tradingPage.js - Historial y gráfico renderizados");

            [DOMElements.selectorPrincipal, DOMElements.selectorPagarCon, DOMElements.selectorRecibirEn].forEach(sel => {
                sel.select2({ 
                    width: '100%', 
                    dropdownCssClass: 'text-dark', 
                    theme: 'bootstrap-5' 
                });
            });
            console.log("8. tradingPage.js - Select2 inicializado");

            // 5. Poblar los selectores con los datos ya cargados
            // Asegurarse de que window.ownedCoins está disponible ANTES de poblar el selector
            if (window.ownedCoins) {
                FormLogic.popularSelector(DOMElements.selectorPagarCon, window.ownedCoins, 'USDT');
            } else {
                console.warn("WARN: window.ownedCoins no está disponible al poblar selectorPagarCon.");
                // Poblar con un valor por defecto si ownedCoins no existe
                FormLogic.popularSelector(DOMElements.selectorPagarCon, [{ticker: 'USDT', nombre: 'USDT'}], 'USDT');
            }
            // Siempre poblar el selector Recibir en con allCryptos
            if (window.allCryptos) {
                FormLogic.popularSelector(DOMElements.selectorRecibirEn, window.allCryptos, 'USDT');
            } else {
                console.warn("WARN: window.allCryptos no está disponible al poblar selectorRecibirEn.");
            }
            console.log("9. tradingPage.js - Selectores poblados");
            
            setupEventListeners();
            setTradeMode('comprar'); // Iniciar en modo compra por defecto
            console.log("10. tradingPage.js - Listeners y modo de trading configurados. ¡Inicialización COMPLETA!");

        } catch (error) {
            console.error('--- ERROR FATAL CAPTURADO EN INITIALIZE ---', error); 
            UIUpdater.mostrarMensajeError('No se pudieron cargar los datos esenciales para la página de trading. Por favor, recarga la página.');
        }
    }

    initialize();
});

==================================================
=== ARCHIVO: ./frontend/static/js/services/apiService.js ===
==================================================

// Centraliza todas las llamadas a la API del backend en un solo lugar.

/**
 * Función genérica para realizar solicitudes fetch a la API.
 * @param {string} url - La URL del endpoint de la API.
 * @param {object} options - Opciones para la solicitud fetch (ej. method, headers, body).
 * @param {string} errorMessage - Mensaje de error personalizado para la excepción.
 * @returns {Promise<any>} - La respuesta JSON de la API.
 * @private
 */
async function _fetchData(url, options = {}, errorMessage = 'Error en la solicitud a la API') {
    try {
        const response = await fetch(url, options);
        if (!response.ok) {
            throw new Error(`${errorMessage} (status: ${response.status})`);
        }
        return await response.json();
    } catch (error) {
        console.error(`❌ Error en la llamada a ${url}:`, error);
        // Re-lanzar el error permite que el código que llama lo maneje (ej. Promise.all).
        throw error;
    }
}

// --- Funciones exportadas para cada endpoint de la API ---

/**
 * Obtiene la lista completa de cotizaciones.
 */
export const fetchCotizaciones = () => 
    _fetchData('/api/cotizaciones', {}, 'No se pudo cargar las cotizaciones');

/**
 * Obtiene el estado completo y formateado de la billetera del usuario.
 */
export const fetchEstadoBilletera = () => 
    _fetchData('/api/billetera/estado-completo', {}, 'No se pudo cargar el estado de la billetera');

/**
 * Obtiene el historial de transacciones del usuario.
 */
export const fetchHistorial = () => 
    _fetchData('/api/historial', {}, 'No se pudo cargar el historial');

/**
 * Obtiene los datos de las velas (candlestick) para el gráfico.
 */
export const fetchVelas = () => 
    _fetchData('/api/velas', {}, 'No se pudo cargar los datos de velas');

/**
 * Solicita al backend que actualice los datos de las cotizaciones desde la fuente externa.
 */
export const triggerActualizacionDatos = () => 
    _fetchData('/api/actualizar', {}, 'La solicitud para actualizar datos falló');

==================================================
=== ARCHIVO: ./frontend/templates/billetera.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Billetera</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="bg-dark text-white">
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes de error -->
    <div id="error-container" class="container-fluid mt-3"></div>

    <main class="container my-4">
        <div class="text-center">
            <h2 class="text-warning mb-4">Billetera</h2>
        </div>

        <div class="table-responsive mt-4">
            <table class="table table-dark table-bordered align-middle text-center">
                <thead class="table-secondary">
                    <tr class="table-dark">
                        <th>Nombre</th>
                        <th>Cantidad</th>
                        <th>Precio Actual</th>
                        <th>Valor USD</th>
                        <th>G&P (USD)</th>
                        <th>G&P (%)</th>
                        <th>% Billetera</th>
                    </tr>
                </thead>
                <tbody id="tabla-billetera">
                    <!-- El contenido será renderizado aquí por billeteraPage.js -->
                    <tr>
                        <td colspan="7" class="text-center text-muted py-4">Cargando billetera...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </main>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/billeteraPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/index.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BlocX</title>
	<link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
	<link rel="stylesheet" href="{{ url_for('static', filename='css/styles_index.css') }}">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
</head>

<body class="bg-dark text-white">


	<nav class="navbar navbar-expand-lg bg-black shadow">
		<div class="container-fluid">
			<a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
				<img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
				<span>BlocX</span>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
				<span class="navbar-toggler-icon bg-light"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarNav">
				<ul class="navbar-nav ms-auto">
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Contenedor para mensajes de error -->
	<div id="error-container" class="container-fluid mt-3"></div>

	<!-- Contenedor principal -->
	<main class="container-fluid mt-4">
		<div class="row">
			<div class="col-12">
				<div class="p-2 shadow text-center">
					<h3 class="text-warning">Cotizaciones</h3>
					<table class="table table-dark table-striped mt-4">
						<thead>
							<tr>
								<th class="text-start px-3">#</th>
								<th class="text-start px-3">Nombre</th>
								<th class="text-start px-3">Precio</th>
								<th class="text-end px-3">1h</th>
								<th class="text-end px-3">24h</th>
								<th class="text-end px-3">7d</th>
								<th class="text-end px-3">Cap. Mercado</th>
								<th class="text-end px-3">Volumen</th>
								<th class="text-end px-3">Suministro</th>
							</tr>
						</thead>
						<tbody id="tabla-datos" class="align-middle">
							<!-- Aquí se insertarán las filas con JS -->
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</main>

	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
	<script type="module" src="{{ url_for('static', filename='js/pages/indexPage.js') }}"></script>

</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/trading.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Trading</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
</head>

<body class="bg-dark text-white">

    <!-- ========== BARRA DE NAVEGACIÓN (sin cambios) ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes de error -->
    <div id="error-container" class="container-fluid mt-3"></div>

    <!-- ========== CONTENIDO PRINCIPAL (sin cambios) ========== -->
    <div class="container mt-5">
        <div class="row">
            <div class="col-md-7">
                <h3 class="text-light">Gráfico velas</h3>
                <div class="form-check form-switch mb-2">
                    <input class="form-check-input" type="checkbox" id="toggleVolume" checked>
                    <label class="form-check-label text-light" for="toggleVolume">Mostrar volumen</label>
                </div>
                <div class="py-3">
                    <div id="chart"></div>
                </div>
            </div>

            <form class="col-md-5 p-3" id="formulario-trading" method="POST"
                action="{{ url_for('trading.procesar_trading_form') }}">
                <h2 class="text-warning">Trading</h2>
                <div class="row g-2 mb-3">
                    <div class="col-6">
                        <label for="cripto" class="form-label">Criptomoneda</label>
                        <select class="form-select" id="cripto" name="ticker" required></select>
                    </div>
                    <div class="col-6">
                        <div id="campo-pagar-con" style="display: none;">
                            <label for="moneda-pago" class="form-label">Pagar con</label>
                            <select class="form-select" id="moneda-pago" name="moneda-pago"></select>
                        </div>
                        <div id="campo-recibir-en" style="display: none;">
                            <label for="moneda-recibir" class="form-label">Recibir en</label>
                            <select class="form-select" id="moneda-recibir" name="moneda-recibir"></select>
                        </div>
                    </div>
                </div>
                <div class="btn-group mb-3 w-100" role="group" id="toggle-trade-type">
                    <input type="hidden" name="accion" id="accion" value="comprar">
                    <button type="button" class="btn w-50 btn-success active boton-comprar"
                        data-action="comprar">Comprar</button>
                    <button type="button" class="btn w-50 btn-outline-secondary boton-vender"
                        data-action="vender">Vender</button>
                </div>
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Tipo de orden</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-mercado" value="mercado"
                            autocomplete="off" checked required>
                        <label class="btn btn-outline-primary rounded-start-pill" for="tipo-mercado">Mercado</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-limite" value="limite"
                            autocomplete="off">
                        <label class="btn btn-outline-primary" for="tipo-limite">Límite</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-stop-limit" value="stop-limit"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="tipo-stop-limit">Stop-Limit</label>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Ingresar por</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-monto" value="monto"
                            autocomplete="off" checked required>
                        <label class="btn btn-outline-primary rounded-start-pill" for="modo-monto">Monto
                            (Cripto)</label>
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-total" value="total"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="modo-total">Total (USD)</label>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="monto" class="form-label">Monto</label>
                    <input type="number" class="form-control" id="monto" placeholder="0.00" name="monto" required
                        min="0.00000001" step="any">
                </div>
                <div class="mb-3">
                    <input type="range" class="form-range" min="0" max="100" step="1" id="slider-monto" value="0"
                        name="slider">
                    <div class="d-flex justify-content-between text-white-50 small">
                        <span>0%</span><span>25%</span><span>50%</span><span>75%</span><span>100%</span>
                    </div>
                </div>
                <div class="mb-3 text-end text-secondary">
                    <small>Disponible: <span id="saldo-disponible">--</span></small>
                </div>
                <button type="submit" class="btn w-100 btn-success boton-confirmar"
                    id="boton-confirmar">CONFIRMAR</button>
            </form>
        </div>

        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">Historial de transacciones</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Cantidad</th>
                                <th>Valor Total</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-historial">
                            <tr>
                                <td colspan="5" class="text-center text-muted py-3">Cargando historial...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/tradingPage.js') }}"></script>

</body>

</html>

==================================================
=== ARCHIVO: ./README.md ===
==================================================

# Simulador Exchange - **BlokX**

Este proyecto educativo fue desarrollado en el marco de la materia "Algoritmos y Estructuras de Datos I" de UADE, bajo la supervisión de la profesora Julia Monasterio.  
Su objetivo es aplicar los conocimientos de la cátedra simulando el funcionamiento básico de un exchange de criptomonedas.  
El sistema permite a los usuarios operar con saldo ficticio utilizando datos reales de cotización obtenidos de CoinGecko y Binance.

## 🎯 Objetivos del proyecto

- Familiarizar a los usuarios con el entorno de un exchange de criptomonedas.
- Simular operaciones de compra y venta mediante distintos tipos de órdenes: Market, Limit y Stop-Loss.
- Calcular y visualizar ganancias, pérdidas y balances del portafolio.
- Almacenar toda la información de manera local utilizando archivos `.json`.
- Comprender la interacción entre frontend y backend mediante una arquitectura moderna (HTML, CSS, Flask y Python).

## ⚙️ Funcionalidades

### Panel general de cotizaciones
- Visualización del top de criptomonedas con:
  - Nombre, ticker, precio, market cap, volumen, supply.
  - Variación en 1h, 24h y 7 días.
- Actualización automática de precios cada 15 segundos.

### Panel de trading
En este panel se verán tres secciones diferentes que contemplan lo necesario para ejecutar las ordenes de compra/venta.

#### Gráfico de velas japonesas
- Grafico en el cual se va a poder visualizar los diferentes pares de criptos usando Lightweight Charts (Libreria de JavaScript), en diferentes time frames: 1m, 5m, 15m, 1h, 4hs, 1d y 1w.

#### Órdenes
- Compra y venta de activos con órdenes:
  - Market
  - Limit
  - Stop-loss
- Comisión fija del 0.5% por transacción.
- Validaciones de saldo y tenencias disponibles.

#### Historial
- Registro de todas las operaciones realizadas.
- Incluye tipo de orden, precio, cantidad, fecha y fee aplicado.
  
### Billetera
- Visualización de tenencias actuales:
  - Cantidad, precio promedio, valor actual, ganancia/pérdida por activo.
- Balance total del portafolio en USDT.

## 🧠 Cómo funciona el sistema

El sistema está diseñado bajo una arquitectura desacoplada que separa claramente las responsabilidades del backend y del frontend:

- **Backend (Python/Flask)**: Actúa como una API pura de JSON. Sus responsabilidades son:
    - **`rutas/`**: Define los endpoints de la API (`/api/...`) que exponen los datos y la lógica de negocio en formato JSON. También sirve el contenedor HTML inicial de cada página.
    - **`servicios/`**: Contiene toda la lógica de negocio (cálculos de billetera, procesamiento de órdenes, formato de datos) y prepara los datos para ser enviados como JSON.
    - **`acceso_datos/`**: Gestiona la lectura y escritura de los archivos `.json` que actúan como base de datos.
    - **`utils/`**: Proporciona funciones de utilidad, como formateadores de datos que se aplican en el backend.

- **Frontend (JavaScript)**: Es un cliente dinámico que consume la API del backend.
    - **Autónomo**: Cada página carga su propio HTML y luego utiliza JavaScript para buscar todos los datos que necesita de los endpoints `/api/...`.
    - **Renderizado en el cliente**: Todo el renderizado y la manipulación del DOM (actualización de tablas, saldos, gráficos) se realiza en el navegador, creando una experiencia de usuario fluida y rápida sin recargas de página.
    - **Estructura modular en `js/`**:
        - **`pages/`**: Contiene la lógica de inicialización y orquestación para cada página principal (ej. `tradingPage.js`).
        - **`components/`**: Módulos encargados de actualizar partes específicas de la interfaz (ej. `uiUpdater.js`, `tablaCotizacionesUI.js`).
        - **`services/`**: Gestiona la comunicación con la API del backend.

### Flujo desacoplado

1.  El usuario navega a una URL (ej. `/trading`).
2.  Flask sirve un archivo HTML mínimo (`trading.html`) que actúa como un esqueleto.
3.  El archivo JavaScript asociado a esa página (`tradingPage.js`) se ejecuta.
4.  El script de JS realiza llamadas a los endpoints de la API del backend (`/api/cotizaciones`, `/api/historial`, etc.) para obtener los datos en formato JSON.
5.  Una vez recibidos los datos, JavaScript actualiza dinámicamente el DOM para mostrar la información al usuario.

## 🗃️ Estructura del proyecto

```
simulador_exchange/
├── backend/
│   ├── app.py                      # Servidor Flask y punto de entrada
│   ├── config.py                   # Configuración del sistema y constantes globales
│   ├── rutas/                      # Blueprints que definen las vistas y API endpoints
│   │   ├── __init__.py
│   │   ├── home.py
│   │   ├── trading_vista.py
│   │   ├── billetera_vista.py
│   │   └── api_cotizaciones_vista.py
│   ├── servicios/                  # Lógica de negocio de cada módulo
│   │   ├── api_cotizaciones.py
│   │   ├── estado_billetera.py
│   │   └── velas_logica.py
│   ├── acceso_datos/               # Acceso y manipulación de archivos .json
│   │   ├── datos_billetera.py
│   │   ├── datos_cotizaciones.py
│   │   └── datos_historial.py
│   └── utils/                      # Utilidades auxiliares
│       └── formatters.py
│
├── frontend/
│   ├── templates/                  # Plantillas HTML (contenedores iniciales)
│   │   ├── index.html
│   │   ├── billetera.html
│   │   └── trading.html
│   └── static/                     # Archivos estáticos
│       ├── css/
│       │   ├── styles_index.css
│       │   └── styles_trading.css
│       ├── img/
│       │   └── logo_BlocX.png
│       └── js/                     # Lógica del cliente
│           ├── components/         # Módulos para actualizar la UI
│           ├── pages/              # Scripts de orquestación por página
│           └── services/           # Servicios de comunicación con la API
│
├── datos/                          # Archivos de persistencia
│   ├── billetera.json
│   ├── datos_cotizaciones.json
│   ├── datos_velas.json
│   └── historial_operaciones.json
│
├── requirements.txt
├── .gitignore
└── README.md
```

## 🚀 Cómo ejecutar el proyecto

### 1. Crear entorno virtual (recomendado)
```bash
python3 -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

### 2. Instalar dependencias
```bash
pip install -r requirements.txt
```

### 3. Iniciar la app
```bash
python3 app.py
```

Y luego acceder desde el navegador a:  
```
http://localhost:5000
```

## 📦 Tecnologías utilizadas

- Python 3.13
- Flask
- HTML, CSS, JavaScript
- Lightweight Charts (TradingView)

## 📌 Notas

- Todos los datos se almacenan localmente en formato JSON.
- No se requiere conexión a bases de datos externas.
- El sistema está pensado para ser didáctico y extensible.

---

**Grupo 12**  
Fausto Lovera — Patricio Menta — Andrei Veis


==================================================
=== ARCHIVO: ./requirements.txt ===
==================================================

Flask==3.1.0
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
requests==2.32.3
Werkzeug==3.1.3



==================================================
=== FIN DEL REPORTE ===
==================================================
