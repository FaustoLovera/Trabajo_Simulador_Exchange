==================================================
=== REPORTE DE C√ìDIGO CONSOLIDADO ===
Proyecto: Trabajo_Simulador_Exchange
Ruta: /Users/andreiveis/UADE/2do cuatrimestre/05_Algoritmos y Estructura de datos I/Trabajo_Simulador_Exchange
Generado el: Mon Jun 23 10:46:22 -03 2025
==================================================

--- INFORMACI√ìN DEL REPOSITORIO GIT ---
Rama actual: dev
√öltimo commit: d39c7a7 - Documentacion: Agregado de DOCSTRINGS y comentarios. (andreiveisuade, 2 days ago)
---

--- ESTRUCTURA DEL DIRECTORIO ---
.
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ backend
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ acceso_datos
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ datos_billetera.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ datos_cotizaciones.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datos_historial.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ rutas
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api_externa.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ billetera_vista.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ home.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ trading_vista.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ servicios
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api_cotizaciones.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ estado_billetera.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ trading_logica.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ velas_logica.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ formatters.py
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ documentacion.md
‚îú‚îÄ‚îÄ frontend
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ static
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ css
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ img
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ templates
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ billetera.html
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ index.html
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ trading.html
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ requirements.txt

12 directories, 24 files
---

==================================================
=== ARCHIVO: ./.gitignore ===
==================================================

# ARCHIVOS PROPIOS NUESTROS
/datos/datos_cotizaciones.json
/datos/datos_velas.json
/datos/billetera.json
/datos/historial_operaciones.json


# Python
__pycache__/
backend/__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.env
.venv
env/
venv/
ENV/
.pytest_cache/
.coverage
coverage.xml
*.cover
.hypothesis/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
__MACOSX/

# IDEs and editors
.idea/
.vscode/
*.swp
*.swo
.project
.classpath
*.sublime-workspace
*.sublime-project

# Frontend
node_modules/
/dist
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env.local
.env.*.local
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
*.sqlite
*.sqlite3
*.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Backup files
*.bak
*.backup
*~

# Environment variables
.env
.env.*
!.env.example

# System Files
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
datos/billetera.json
datos/datos_cotizaciones.json
datos/datos_velas.json
*.pyc
# D2 files
*.d2
diagrama.png


==================================================
=== ARCHIVO: ./backend/__init__.py ===
==================================================

"""
Paquete principal del backend de la aplicaci√≥n.

Este archivo `__init__.py` no solo marca el directorio `backend` como un paquete de
Python, sino que tambi√©n contiene la "Application Factory" `crear_app`.
Este patr√≥n es una buena pr√°ctica en Flask que permite crear m√∫ltiples instancias
de la aplicaci√≥n con diferentes configuraciones, facilitando las pruebas y la
escalabilidad.
"""

from flask import Flask
from config import FLASK_SECRET_KEY
from backend.rutas import registrar_rutas

def crear_app() -> Flask:
    """
    Crea, configura y devuelve una instancia de la aplicaci√≥n Flask.

    Esta funci√≥n sigue el patr√≥n de dise√±o "Application Factory". Se encarga de:
    1. Crear la instancia de la aplicaci√≥n Flask.
    2. Configurar la ubicaci√≥n de las carpetas de plantillas y archivos est√°ticos.
    3. Establecer la clave secreta para la gesti√≥n de sesiones y mensajes flash.
    4. Registrar todos los blueprints (conjuntos de rutas) de la aplicaci√≥n.

    Returns:
        Flask: La instancia de la aplicaci√≥n Flask configurada y lista para usarse.
    """
    app = Flask(
        __name__,
        static_folder="../frontend/static",
        template_folder="../frontend/templates",
    )

    app.secret_key = FLASK_SECRET_KEY

    registrar_rutas(app)

    return app

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_billetera.py ===
==================================================

import json
import os
from decimal import Decimal, InvalidOperation
from config import BILLETERA_PATH, BALANCE_INICIAL_USDT


def cargar_billetera():
    """
    Carga la billetera de criptomonedas desde un archivo JSON.

    Esta funci√≥n se encarga de leer el archivo `billetera.json`. Si el archivo no existe,
    est√° vac√≠o o contiene datos corruptos, se crea una nueva billetera con un saldo
    inicial de USDT, definido por `BALANCE_INICIAL_USDT`.

    Maneja de forma segura la conversi√≥n de los saldos de texto a objetos Decimal
    para mantener la precisi√≥n en los c√°lculos financieros.

    Returns:
        dict[str, Decimal]: Un diccionario que representa la billetera.
                            Las claves son los tickers de las criptomonedas (ej. "USDT", "BTC")
                            y los valores son las cantidades como objetos Decimal.

    Example:
        >>> # Suponiendo que el archivo de billetera no existe o est√° vac√≠o.
        >>> billetera = cargar_billetera()
        >>> print(billetera)
        {'USDT': Decimal('10000')}
    """
    # Asegura que el directorio de la billetera exista.
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    # Si el archivo no existe o est√° vac√≠o, crea una billetera inicial.
    if not os.path.exists(BILLETERA_PATH) or os.path.getsize(BILLETERA_PATH) == 0:
        billetera_inicial = {"USDT": Decimal(BALANCE_INICIAL_USDT)}
        guardar_billetera(billetera_inicial)
        return billetera_inicial

    try:
        with open(BILLETERA_PATH, "r", encoding="utf-8") as f:
            datos_cargados = json.load(f)

            billetera = {}
            # Convierte todos los valores a Decimal para mantener la precisi√≥n.
            for ticker, cantidad_str in datos_cargados.items():
                try:
                    billetera[ticker] = Decimal(str(cantidad_str))
                except InvalidOperation:
                    # Si un valor no es un n√∫mero v√°lido, se informa y se establece en 0.
                    print(
                        f"Advertencia: Valor inv√°lido para {ticker} en billetera.json. Se usar√° 0."
                    )
                    billetera[ticker] = Decimal("0")
            return billetera
    except (json.JSONDecodeError, FileNotFoundError):
        # Si el archivo est√° corrupto o no se encuentra (aunque ya se verific√≥),
        # se reinicia la billetera para evitar errores en la aplicaci√≥n.
        print(
            f"Advertencia: Archivo '{BILLETERA_PATH}' corrupto o no encontrado. Se reiniciar√° la billetera."
        )
        billetera_inicial = {"USDT": Decimal(BALANCE_INICIAL_USDT)}
        guardar_billetera(billetera_inicial)
        return billetera_inicial


def guardar_billetera(billetera):
    """
    Guarda el estado actual de la billetera en un archivo JSON.

    Esta funci√≥n toma un diccionario que representa la billetera y lo serializa
    a formato JSON, guard√°ndolo en la ruta especificada por `BILLETERA_PATH`.
    Los valores de tipo Decimal se convierten a string para evitar la p√©rdida de
    precisi√≥n durante la serializaci√≥n.

    Args:
        billetera (dict[str, Decimal]): El diccionario de la billetera a guardar.
                                         Las claves son los tickers (ej. "BTC") y los valores
                                         son las cantidades en formato Decimal.

    Example:
        >>> mi_billetera = {'USDT': Decimal('5000.00'), 'BTC': Decimal('0.1')}
        >>> guardar_billetera(mi_billetera)
        # Esto crear√° o sobrescribir√° billetera.json con:
        # {
        #     "USDT": "5000.00",
        #     "BTC": "0.1"
        # }
    """
    # Asegura que el directorio de la billetera exista antes de guardar.
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    # Convierte los valores Decimal a string para una serializaci√≥n JSON segura y precisa.
    billetera_serializable = {
        ticker: str(cantidad) for ticker, cantidad in billetera.items()
    }

    with open(BILLETERA_PATH, "w", encoding="utf-8") as f:
        json.dump(billetera_serializable, f, indent=4)


==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_cotizaciones.py ===
==================================================

import json
import os
from decimal import Decimal
from config import COTIZACIONES_PATH

# Cach√© en memoria para almacenar los precios de las criptomonedas.
# Esto evita leer el archivo JSON en cada consulta, mejorando el rendimiento.
precios_cache = {}

def cargar_datos_cotizaciones():
    """
    Carga la lista de cotizaciones desde el archivo JSON de forma segura.

    Esta funci√≥n lee el archivo definido en `COTIZACIONES_PATH`. Si el archivo
    no existe, est√° vac√≠o o su contenido JSON es inv√°lido, devuelve una lista vac√≠a
    para evitar errores en el resto de la aplicaci√≥n.

    Returns:
        list[dict]: Una lista de diccionarios, donde cada diccionario representa
                    una criptomoneda con sus datos (ej. ticker, precio_usd).
                    Retorna una lista vac√≠a si la carga falla.

    Example:
        >>> # Suponiendo que cotizaciones.json contiene: 
        >>> # [{'ticker': 'BTC', 'precio_usd': '65000.00'}]
        >>> datos = cargar_datos_cotizaciones()
        >>> print(datos)
        [{'ticker': 'BTC', 'precio_usd': '65000.00'}]
    """
    if not os.path.exists(COTIZACIONES_PATH) or os.path.getsize(COTIZACIONES_PATH) == 0:
        return []

    try:
        with open(COTIZACIONES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        # Si hay un error de decodificaci√≥n o el archivo no se encuentra, 
        # se retorna una lista vac√≠a para manejar el error de forma controlada.
        return []

def recargar_cache_precios():
    """
    Actualiza el cach√© de precios en memoria (`precios_cache`) a partir del archivo JSON.

    Esta funci√≥n debe ser llamada cada vez que los datos de cotizaciones en el
    archivo `cotizaciones.json` son actualizados. Lee los datos y los carga en el
    diccionario `precios_cache` para un acceso r√°pido y eficiente.

    Side Effects:
        Modifica la variable global `precios_cache`.
    """
    global precios_cache
    print("üîÑ Recargando cach√© de precios...")
    lista_criptos = cargar_datos_cotizaciones()
    
    # Crea un diccionario con el ticker en may√∫sculas como clave y el precio como Decimal.
    precios_cache = {
        cripto.get("ticker", "").upper(): Decimal(str(cripto.get("precio_usd", "0")))
        for cripto in lista_criptos
    }
    print("‚úÖ Cach√© de precios actualizado.")


def obtener_precio(ticker):
    """
    Obtiene el precio de una criptomoneda espec√≠fica desde el cach√© en memoria.

    Si el cach√© de precios est√° vac√≠o, llama a `recargar_cache_precios()` para cargarlo.
    La b√∫squeda del ticker no distingue entre may√∫sculas y min√∫sculas.

    Args:
        ticker (str): El ticker de la criptomoneda a consultar (ej. "BTC", "eth").

    Returns:
        Decimal | None: El precio de la criptomoneda como un objeto Decimal si se encuentra.
                        Retorna `None` si el ticker no existe en el cach√©.

    Example:
        >>> # Suponiendo que el cach√© ha sido cargado con {'BTC': Decimal('65000.00')}
        >>> precio_btc = obtener_precio("btc")
        >>> print(precio_btc)
        Decimal('65000.00')
        
        >>> precio_luna = obtener_precio("LUNA")
        >>> print(precio_luna)
        None
    """
    # Si el cach√© est√° vac√≠o, se carga por primera vez.
    if not precios_cache:
        recargar_cache_precios()
    
    # Devuelve el precio del ticker (en may√∫sculas) o None si no se encuentra.
    return precios_cache.get(ticker.upper())

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_historial.py ===
==================================================

import json
import os
from datetime import datetime
from decimal import Decimal
from config import HISTORIAL_PATH


def cargar_historial():
    """
    Carga el historial de transacciones desde el archivo JSON.

    Lee el archivo especificado en `HISTORIAL_PATH`. Si el archivo no existe,
    est√° vac√≠o o contiene JSON mal formado, devuelve una lista vac√≠a para
    prevenir errores en la aplicaci√≥n.

    Returns:
        list[dict]: Una lista de diccionarios, donde cada uno representa una
                    transacci√≥n guardada. Devuelve una lista vac√≠a si la
                    carga falla.

    Example:
        >>> historial = cargar_historial()
        >>> print(historial)
        [{'id': 1, 'timestamp': '...', 'tipo': 'compra', ...}]
    """
    if not os.path.exists(HISTORIAL_PATH) or os.path.getsize(HISTORIAL_PATH) == 0:
        return []

    try:
        with open(HISTORIAL_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: No se pudo leer o el archivo '{HISTORIAL_PATH}' est√° corrupto."
        )
        return []


def guardar_en_historial(
    tipo_operacion: str,
    moneda_origen: str,
    cantidad_origen: Decimal,
    moneda_destino: str,
    cantidad_destino: Decimal,
    valor_usd: Decimal,
):
    """
    Guarda una nueva operaci√≥n en el historial de transacciones.

    Carga el historial existente, crea un nuevo registro de operaci√≥n y lo
    a√±ade al principio de la lista. Finalmente, guarda la lista actualizada
    en el archivo JSON.

    Args:
        tipo_operacion (str): El tipo de operaci√≥n (ej. "compra", "venta").
        moneda_origen (str): Ticker de la moneda de origen (ej. "USDT").
        cantidad_origen (Decimal): La cantidad de la moneda de origen.
        moneda_destino (str): Ticker de la moneda de destino (ej. "BTC").
        cantidad_destino (Decimal): La cantidad de la moneda de destino.
        valor_usd (Decimal): El valor total de la transacci√≥n en USD.

    Example:
        >>> guardar_en_historial(
                "compra", "USDT", Decimal("100"), "BTC", Decimal("0.0015"), Decimal("100")
            )
        # Esto a√±adir√° una nueva entrada al archivo historial.json
    """
    # Asegura que el directorio del historial exista.
    os.makedirs(os.path.dirname(HISTORIAL_PATH), exist_ok=True)

    historial = cargar_historial()

    # Crea el diccionario para la nueva operaci√≥n.
    # Las cantidades Decimal se convierten a string para preservar la precisi√≥n.
    operacion = {
        "id": len(historial) + 1,
        "timestamp": datetime.now().isoformat(),
        "tipo": tipo_operacion,
        "origen": {"ticker": moneda_origen, "cantidad": str(cantidad_origen)},
        "destino": {"ticker": moneda_destino, "cantidad": str(cantidad_destino)},
        "valor_usd": str(valor_usd.quantize(Decimal("0.01"))),
    }

    # A√±ade la nueva operaci√≥n al principio de la lista para mostrarla primero.
    historial.insert(0, operacion)

    # Guarda la lista completa de nuevo en el archivo.
    with open(HISTORIAL_PATH, "w", encoding="utf-8") as f:
        json.dump(historial, f, indent=4)


==================================================
=== ARCHIVO: ./backend/app.py ===
==================================================

"""
Punto de entrada para ejecutar la aplicaci√≥n Flask en modo de desarrollo.

Este script importa la 'Application Factory' (`crear_app`), la utiliza para
crear una instancia de la aplicaci√≥n y, si se ejecuta directamente, inicia
el servidor de desarrollo de Flask.

Para iniciar la aplicaci√≥n, ejecuta el siguiente comando desde el directorio ra√≠z
del proyecto:
    python -m backend.app
"""

from flask import Flask
from . import crear_app

# Se crea la instancia global de la aplicaci√≥n llamando a la factory.
app: Flask = crear_app()

# El siguiente bloque se ejecuta solo si el script es llamado directamente
# por el int√©rprete de Python (por ejemplo, `python -m backend.app`).
if __name__ == "__main__":
    # Inicia el servidor de desarrollo de Flask.
    # `debug=True` activa el modo de depuraci√≥n, que proporciona un depurador
    # interactivo y recarga autom√°ticamente el servidor al detectar cambios.
    app.run(debug=True)

==================================================
=== ARCHIVO: ./backend/rutas/__init__.py ===
==================================================

"""
Inicializa el paquete de rutas y registra todos los Blueprints de la aplicaci√≥n.

Este archivo importa los Blueprints definidos en los diferentes m√≥dulos de vistas
(home, trading, billetera, etc.) y proporciona una funci√≥n centralizada `registrar_rutas`
para vincularlos a la instancia principal de la aplicaci√≥n Flask.
"""

from .home import bp as home_bp
from .trading_vista import bp as trading_bp
from .billetera_vista import bp as billetera_bp
from .api_externa import bp as api_ruta_bp


def registrar_rutas(app):
    """
    Registra todos los Blueprints de la aplicaci√≥n en la instancia de Flask.

    Args:
        app (Flask): La instancia principal de la aplicaci√≥n Flask a la que se
                     registrar√°n los Blueprints.

    Side Effects:
        Modifica el objeto `app` registrando las rutas definidas en los Blueprints.
    """
    app.register_blueprint(home_bp)
    app.register_blueprint(trading_bp)
    app.register_blueprint(billetera_bp)
    app.register_blueprint(api_ruta_bp)


==================================================
=== ARCHIVO: ./backend/rutas/api_externa.py ===
==================================================

"""
Define los endpoints de la API externa de la aplicaci√≥n.

Este m√≥dulo contiene las rutas que exponen datos del mercado de criptomonedas,
como cotizaciones y datos de velas (candlestick), para ser consumidos por el frontend
u otros clientes.
"""

from flask import Blueprint, jsonify
from backend.servicios.api_cotizaciones import obtener_datos_criptos_coingecko, obtener_velas_de_api
from backend.acceso_datos.datos_cotizaciones import cargar_datos_cotizaciones

bp = Blueprint("api_externa", __name__, url_prefix="/api")


@bp.route("/actualizar")
def actualizar():
    """
    Endpoint para forzar la actualizaci√≥n de los datos de cotizaciones desde CoinGecko.

    Al ser llamado, este endpoint invoca al servicio que obtiene los precios m√°s
    recientes de las criptomonedas y los guarda localmente.

    Returns:
        Response: Un objeto JSON que confirma el estado de la operaci√≥n.
            Ejemplo: `{"estado": "ok", "cantidad_criptos": 100}`
    """
    print("--- PING: Endpoint /api/actualizar ALCANZADO ---")
    datos_criptos = obtener_datos_criptos_coingecko()
    return jsonify({"estado": "ok", "cantidad_criptos": len(datos_criptos)})


@bp.route("/cotizaciones")
def get_cotizaciones():
    """
    Retorna la lista completa de cotizaciones almacenadas localmente.

    Returns:
        Response: Un objeto JSON que contiene una lista de todas las criptomonedas
                  y sus datos de cotizaci√≥n.
                  Ejemplo: `[{"ticker": "BTC", "precio_usd": "65000.00", ...}]`
    """
    return jsonify(cargar_datos_cotizaciones())


@bp.route("/velas/<string:ticker>/<string:interval>")
def obtener_datos_velas_por_ticker(ticker: str, interval: str):
    """
    Obtiene los datos de velas (candlestick) para un par y un intervalo espec√≠ficos.

    Esta ruta din√°mica consulta a una API externa para obtener los datos hist√≥ricos
    de precios (OHLCV) necesarios para graficar las velas.

    Args:
        ticker (str): El s√≠mbolo del par a consultar (ej. "BTCUSDT").
        interval (str): El intervalo de tiempo para las velas (ej. "1h", "4h", "1d").

    Returns:
        Response: Un objeto JSON con una lista de listas, donde cada sublista
                  representa una vela. En caso de error, retorna una lista vac√≠a.
                  Ejemplo: `[[1622505600000, "49000.00", ...], ...]`
    """
    try:
        datos = obtener_velas_de_api(ticker, interval)
        return jsonify(datos)
    except Exception as e:
        print(f"‚ùå Error en la ruta de velas para {ticker}/{interval}: {e}")
        return jsonify([])

==================================================
=== ARCHIVO: ./backend/rutas/billetera_vista.py ===
==================================================

"""
Define las rutas relacionadas con la visualizaci√≥n de la billetera y el historial.

Este m√≥dulo contiene los endpoints para renderizar la p√°gina de la billetera
y para proporcionar datos financieros (estado actual y transacciones pasadas)
 a trav√©s de una API REST al frontend.
"""

from flask import Blueprint, render_template, jsonify
from backend.servicios.estado_billetera import estado_actual_completo, obtener_historial_formateado

bp = Blueprint("billetera", __name__)


@bp.route("/billetera")
def mostrar_billetera():
    """
    Renderiza la p√°gina principal de la billetera.

    Esta ruta sirve el archivo `billetera.html`, que act√∫a como el contenedor
    principal para la interfaz de la billetera. Los datos se cargan de forma
    as√≠ncrona a trav√©s de llamadas a la API desde JavaScript.

    Returns:
        Response: El contenido HTML renderizado de la p√°gina de la billetera.
    """
    return render_template("billetera.html")


@bp.route("/api/billetera/estado-completo")
def get_estado_billetera_completo():
    """
    Endpoint de API que devuelve el estado financiero completo de la billetera.

    Proporciona un resumen detallado que incluye el balance de cada criptomoneda,
    su valor en USD, el total general, y el rendimiento.

    Returns:
        Response: Un objeto JSON con el estado completo de la billetera.
            Ejemplo: `{"total_usd": "10500.50", "rendimiento": "5.00", ...}`
    """
    datos = estado_actual_completo()
    return jsonify(datos)


@bp.route("/api/historial")
def get_historial_transacciones():
    """
    Endpoint de API que devuelve el historial completo de transacciones.

    Retorna una lista de todas las operaciones de compra y venta realizadas,
    formateadas para su visualizaci√≥n en el frontend.

    Returns:
        Response: Un objeto JSON que contiene una lista de transacciones.
            Ejemplo: `[{"id": 1, "fecha": "21/06/2025", "tipo": "compra", ...}]`
    """
    return jsonify(obtener_historial_formateado())

==================================================
=== ARCHIVO: ./backend/rutas/home.py ===
==================================================

"""
Define la ruta principal (landing page) de la aplicaci√≥n.

Este m√≥dulo es responsable de servir la p√°gina de inicio (index.html),
que act√∫a como el punto de entrada para los usuarios.
"""

from flask import Blueprint, render_template

bp = Blueprint("home", __name__)


@bp.route("/")
def index():
    """
    Renderiza la p√°gina de inicio de la aplicaci√≥n.

    Esta ruta sirve el archivo `index.html`, que es el esqueleto principal
    de la interfaz. El contenido din√°mico, como las cotizaciones, se carga
    posteriormente de forma as√≠ncrona mediante JavaScript.

    Returns:
        Response: El contenido HTML renderizado de la p√°gina de inicio.
    """
    return render_template("index.html")

==================================================
=== ARCHIVO: ./backend/rutas/trading_vista.py ===
==================================================

"""
Define las rutas para la funcionalidad de trading.

Este m√≥dulo gestiona la visualizaci√≥n de la p√°gina de trading y el procesamiento
de las operaciones de compra y venta de criptomonedas enviadas por el usuario.
"""

from flask import Blueprint, request, redirect, url_for, render_template, flash
from backend.servicios.trading_logica import procesar_operacion_trading

bp = Blueprint("trading", __name__)


@bp.route("/trading", methods=["GET"])
def mostrar_trading_page():
    """
    Renderiza la p√°gina de trading.

    Esta ruta maneja las solicitudes GET para mostrar la interfaz de trading,
    sirviendo el archivo `trading.html`.

    Returns:
        Response: El contenido HTML renderizado de la p√°gina de trading.
    """
    return render_template("trading.html")


@bp.route("/trading/operar", methods=["POST"])
def procesar_trading_form():
    """
    Procesa los datos del formulario de una operaci√≥n de trading (compra/venta).

    Recibe los datos del formulario enviado desde la p√°gina de trading, los pasa
    al servicio de l√≥gica de trading para su procesamiento y muestra un mensaje
    (flash) al usuario con el resultado. Finalmente, redirige de vuelta a la
    p√°gina de trading.

    Side Effects:
        - Llama a `procesar_operacion_trading` para modificar el estado de la billetera.
        - Crea un mensaje flash para notificar al usuario.
        - Redirige al usuario a la p√°gina de trading.

    Returns:
        Response: Una redirecci√≥n a la p√°gina de trading.
    """
    print(">>> DATOS RECIBIDOS DEL FORMULARIO:", request.form)

    exito, mensaje = procesar_operacion_trading(request.form)
    flash(mensaje, "success" if exito else "danger")

    # Siempre redirige de vuelta a la p√°gina principal de trading.
    return redirect(url_for("trading.mostrar_trading_page"))


==================================================
=== ARCHIVO: ./backend/servicios/__init__.py ===
==================================================

"""
El paquete 'servicios' contiene la l√≥gica de negocio de la aplicaci√≥n.

Este m√≥dulo separa las operaciones complejas, los c√°lculos y las interacciones
con APIs externas de las capas de acceso a datos y de las vistas (rutas).
Su objetivo es mantener el c√≥digo organizado, reutilizable y f√°cil de mantener.
"""

==================================================
=== ARCHIVO: ./backend/servicios/api_cotizaciones.py ===
==================================================

"""
Servicio para interactuar con APIs externas de criptomonedas.

Este m√≥dulo centraliza las llamadas a las APIs de CoinGecko (para cotizaciones
generales del mercado) y Binance (para datos de velas/k-lines). Se encarga de
realizar las peticiones, procesar los datos y guardarlos localmente.
"""

from decimal import Decimal
import requests
from backend.servicios.velas_logica import guardar_datos_cotizaciones
from config import COINGECKO_URL, BINANCE_URL, CANTIDAD_CRIPTOMONEDAS, CANTIDAD_VELAS
from backend.utils.formatters import formato_numero_grande, formato_porcentaje, formato_valor_monetario

def obtener_datos_criptos_coingecko() -> list[dict]:
    """
    Obtiene y procesa datos de mercado desde la API de CoinGecko.

    Realiza una petici√≥n para obtener una lista de las principales criptomonedas,
    procesa la respuesta JSON, enriquece los datos con campos formateados para la UI,
    y finalmente guarda las cotizaciones en un archivo local.

    Returns:
        list[dict]: Una lista de diccionarios, donde cada uno representa una
                    criptomoneda con datos brutos y formateados. Retorna una
                    lista vac√≠a si ocurre un error.

    Side Effects:
        - Guarda los datos de cotizaciones en un archivo JSON local a trav√©s de
          `guardar_datos_cotizaciones()`.
        - Imprime logs en la consola sobre el estado de la petici√≥n.

    Example of a returned item:
        {
            'id': 1, 'nombre': 'Bitcoin', 'ticker': 'BTC', 'precio_usd': '65000.10',
            'precio_usd_formatted': '$65,000.10', 'market_cap_formatted': '$1.28T', ...
        }
    """
    params = {
        "vs_currency": "usd",
        "order": "market_cap_desc",
        "per_page": CANTIDAD_CRIPTOMONEDAS,
        "page": 1,
        "sparkline": "false",
        "price_change_percentage": "1h,24h,7d",
    }

    try:
        respuesta = requests.get(COINGECKO_URL, params, timeout=10)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Error al obtener datos de CoinGecko: {str(e)}")
        return []

    print(f"‚úÖ Estado de la respuesta CoinGecko: {respuesta.status_code}")

    try:
        datos = respuesta.json()
        resultado = []
        for i, dato in enumerate(datos, start=1):
            # Procesa cada criptomoneda de forma segura
            resultado.append({
                "id": i,
                "nombre": dato.get("name"),
                "ticker": dato.get('symbol', '').upper(),
                "logo": dato.get("image"),
                
                # Datos crudos convertidos a string para consistencia
                "precio_usd": str(Decimal(str(dato.get("current_price", 0)))),
                "1h_%": str(Decimal(str(dato.get("price_change_percentage_1h_in_currency", 0)))),
                "24h_%": str(Decimal(str(dato.get("price_change_percentage_24h_in_currency", 0)))),
                "7d_%": str(Decimal(str(dato.get("price_change_percentage_7d_in_currency", 0)))),
                "market_cap": str(Decimal(str(dato.get("market_cap", 0)))),
                "volumen_24h": str(Decimal(str(dato.get("total_volume", 0)))),
                "circulating_supply": str(Decimal(str(dato.get("circulating_supply", 0)))),

                # Datos pre-formateados para la UI
                "precio_usd_formatted": formato_valor_monetario(Decimal(str(dato.get("current_price", 0)))),
                "1h_%_formatted": formato_porcentaje(Decimal(str(dato.get("price_change_percentage_1h_in_currency", 0)))),
                "24h_%_formatted": formato_porcentaje(Decimal(str(dato.get("price_change_percentage_24h_in_currency", 0)))),
                "7d_%_formatted": formato_porcentaje(Decimal(str(dato.get("price_change_percentage_7d_in_currency", 0)))),
                "market_cap_formatted": formato_numero_grande(Decimal(str(dato.get("market_cap", 0)))),
                "volumen_24h_formatted": formato_numero_grande(Decimal(str(dato.get("total_volume", 0)))),
                "circulating_supply_formatted": f"{Decimal(str(dato.get('circulating_supply', 0))):,.0f} {dato.get('symbol', '').upper()}"
            })
    except (KeyError, TypeError, ValueError, json.JSONDecodeError) as e:
        print(f"‚ùå Error al procesar los datos de CoinGecko: {str(e)}")
        return []

    print(f"üí° Total de criptos procesadas: {len(resultado)}")
    guardar_datos_cotizaciones(resultado)
    return resultado


def obtener_velas_de_api(ticker: str, interval: str) -> list[dict]:
    """
    Obtiene datos hist√≥ricos de velas (K-lines) desde la API de Binance.

    Args:
        ticker (str): El ticker de la criptomoneda (ej. "BTC").
        interval (str): El intervalo de tiempo para las velas (ej. "1h", "4h", "1d").

    Returns:
        list[dict]: Una lista de diccionarios, donde cada uno representa una vela
                    con datos OHLCV (Open, High, Low, Close, Volume). Retorna
                    una lista vac√≠a si ocurre un error.

    Example of a returned item:
        {
            'time': 1622505600, 'open': '49000.00', 'high': '49500.00',
            'low': '48800.00', 'close': '49300.00', 'volume': '1234.56'
        }
    """
    # La API de Binance espera el par completo (ej. 'BTCUSDT')
    params = {
        "symbol": f"{ticker.upper()}USDT",
        "interval": interval,
        "limit": CANTIDAD_VELAS,
    }
    try:
        respuesta = requests.get(BINANCE_URL, params, timeout=10)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Error al obtener datos de Binance para {ticker} ({interval}): {str(e)}")
        return []

    print(f"‚úÖ Estado de la respuesta Binance para {ticker} ({interval}): {respuesta.status_code}")

    try:
        datos = respuesta.json()
        if not isinstance(datos, list):
            print(f"‚ö†Ô∏è Respuesta inesperada de Binance para {ticker} ({interval}): {datos}")
            return []
        
        # Transforma la lista de listas de Binance a una lista de diccionarios
        resultado = [
            {
                "time": int(vela[0] / 1000), "open": str(Decimal(vela[1])),
                "high": str(Decimal(vela[2])), "low": str(Decimal(vela[3])),
                "close": str(Decimal(vela[4])), "volume": str(Decimal(vela[5])),
            }
            for vela in datos
        ]
        return resultado
    except (json.JSONDecodeError, IndexError, TypeError) as e:
        print(f"‚ùå Error al procesar los datos de velas de Binance para {ticker}: {e}")
        return []

==================================================
=== ARCHIVO: ./backend/servicios/estado_billetera.py ===
==================================================

"""
Servicio para calcular y formatear el estado de la billetera y el historial.

Este m√≥dulo centraliza la l√≥gica de negocio para procesar los datos crudos de la
billetera, el historial de transacciones y las cotizaciones. Genera una vista
completa y enriquecida con c√°lculos financieros (ganancias/p√©rdidas, precios
promedio) y campos formateados listos para ser consumidos por el frontend.
"""

from decimal import Decimal
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_historial import cargar_historial
from backend.acceso_datos.datos_cotizaciones import obtener_precio, cargar_datos_cotizaciones
from backend.utils.formatters import formato_valor_monetario, formato_cantidad_cripto, formato_porcentaje, formato_fecha_hora

def calcular_detalle_cripto(ticker: str, cantidad_actual: str | Decimal, precios: dict, historial: list[dict], info_cripto: dict) -> dict:
    """
    Calcula m√©tricas financieras detalladas para una √∫nica criptomoneda en la billetera.

    Args:
        ticker (str): El ticker de la criptomoneda (ej. "BTC").
        cantidad_actual (str | Decimal): La cantidad de la criptomoneda en posesi√≥n.
        precios (dict): Un diccionario con los precios actuales de todas las criptos.
        historial (list[dict]): El historial completo de transacciones.
        info_cripto (dict): Un diccionario con informaci√≥n b√°sica de la cripto (nombre, logo).

    Returns:
        dict: Un diccionario con los datos calculados, incluyendo valor actual,
              precio promedio de compra, inversi√≥n total y ganancias/p√©rdidas.
    """
    cantidad_actual = Decimal(str(cantidad_actual))
    precio_actual = precios.get(ticker, Decimal("0"))
    valor_usdt = cantidad_actual * precio_actual

    # Filtra solo las compras de la criptomoneda actual para calcular el costo base
    compras = [
        op for op in historial
        if op.get("tipo") == "compra" and op.get("destino", {}).get("ticker") == ticker
    ]

    cantidad_comprada = sum(Decimal(str(op.get("destino", {}).get("cantidad", "0"))) for op in compras)
    total_invertido = sum(Decimal(str(op.get("valor_usd", "0"))) for op in compras)

    # Funci√≥n local para evitar divisi√≥n por cero
    division_por_cero_segura = lambda num, den: num / den if den != 0 else Decimal("0")

    precio_promedio = division_por_cero_segura(total_invertido, cantidad_comprada)
    invertido_actual = cantidad_actual * precio_promedio
    ganancia = valor_usdt - invertido_actual
    porcentaje_ganancia = division_por_cero_segura(ganancia, invertido_actual) * Decimal("100")

    return {
        "ticker": ticker,
        "nombre": info_cripto.get('nombre', ticker),
        "cantidad": cantidad_actual,
        "valor_usdt": valor_usdt,
        "precio_actual": precio_actual,
        "precio_promedio": precio_promedio,
        "invertido": invertido_actual,
        "ganancia_perdida": ganancia,
        "porcentaje_ganancia": porcentaje_ganancia,
    }

def estado_actual_completo() -> list[dict]:
    """
    Genera un estado completo y formateado de todos los activos en la billetera.

    Carga la billetera, el historial y las cotizaciones. Para cada activo, calcula
    sus m√©tricas financieras, a√±ade campos formateados para la UI y determina su
    peso porcentual en la billetera. Finalmente, convierte todos los valores
    Decimal a string para asegurar la serializaci√≥n JSON.

    Returns:
        list[dict]: Una lista de diccionarios, cada uno representando un activo
                    con todos sus datos brutos, calculados y formateados.
    """
    billetera = cargar_billetera()
    historial = cargar_historial()
    todas_las_cotizaciones = cargar_datos_cotizaciones()
    info_map = {c.get('ticker'): c for c in todas_las_cotizaciones}
    precios = {ticker: obtener_precio(ticker) or Decimal("0") for ticker in billetera.keys()}

    detalles = []
    for ticker, cantidad in billetera.items():
        # USDT es un caso especial ya que no viene de la API de Coingecko
        if ticker == "USDT":
            info_cripto = {'nombre': 'Tether', 'ticker': 'USDT'}
        else:
            info_cripto = info_map.get(ticker, {'nombre': ticker})  # Fallback si no se encuentra

        detalle_calculado = calcular_detalle_cripto(ticker, cantidad, precios, historial, info_cripto)
        detalles.append(detalle_calculado)

    total_usdt = sum(d.get("valor_usdt", Decimal("0")) for d in detalles)
    division_por_cero_segura = lambda num, den: num / den if den != 0 else Decimal("0")

    # Segunda pasada para calcular porcentajes y a√±adir formato
    for detalle in detalles:
        porcentaje_billetera = division_por_cero_segura(detalle.get("valor_usdt", Decimal("0")), total_usdt) * Decimal("100")
        
        detalle["porcentaje"] = porcentaje_billetera
        detalle["es_polvo"] = detalle.get("valor_usdt", Decimal("0")) < Decimal("0.001")
        
        # Formateo condicional para USDT vs otras criptos
        if detalle["ticker"] == 'USDT':
            detalle["cantidad_formatted"] = formato_valor_monetario(detalle["cantidad"], simbolo="")
        else:
            detalle["cantidad_formatted"] = formato_cantidad_cripto(detalle["cantidad"])
        
        detalle["precio_actual_formatted"] = formato_valor_monetario(detalle.get("precio_actual", Decimal("0")), decimales=4)
        detalle["valor_usdt_formatted"] = formato_valor_monetario(detalle.get("valor_usdt", Decimal("0")))
        detalle["ganancia_perdida_formatted"] = formato_valor_monetario(detalle.get("ganancia_perdida", Decimal("0")))
        detalle["porcentaje_ganancia_formatted"] = formato_porcentaje(detalle.get("porcentaje_ganancia", Decimal("0")))
        detalle["porcentaje_formatted"] = formato_porcentaje(porcentaje_billetera)

        # Asegura que todos los valores Decimal se conviertan a string
        for k, v in detalle.items():
            if isinstance(v, Decimal):
                detalle[k] = str(v)
    
    return detalles

def obtener_historial_formateado() -> list[dict]:
    """
    Carga y formatea el historial de transacciones para su visualizaci√≥n.

    Para cada transacci√≥n, a√±ade campos formateados como la fecha, el par de
    monedas, y los valores monetarios, listos para ser mostrados en la UI.

    Returns:
        list[dict]: Una lista de transacciones, cada una como un diccionario
                    enriquecido con datos formateados.
    """
    historial = cargar_historial()
    historial_formateado = []

    for item in historial:
        item_formateado = item.copy()

        if item.get('tipo') == 'compra':
            cantidad = Decimal(str(item.get('destino', {}).get('cantidad', '0')))
            par = f"{item.get('destino', {}).get('ticker', '?')}/{item.get('origen', {}).get('ticker', '?')}"
        else:  # Venta
            cantidad = Decimal(str(item.get('origen', {}).get('cantidad', '0')))
            par = f"{item.get('origen', {}).get('ticker', '?')}/{item.get('destino', {}).get('ticker', '?')}"

        # A√±ade campos formateados para la UI
        item_formateado['fecha_formatted'] = formato_fecha_hora(item.get('timestamp'))
        item_formateado['par_formatted'] = par
        item_formateado['tipo_formatted'] = item.get('tipo', '').capitalize()
        item_formateado['cantidad_formatted'] = formato_cantidad_cripto(cantidad)
        item_formateado['valor_total_formatted'] = formato_valor_monetario(Decimal(str(item.get('valor_usd', '0'))))

        # Convierte todos los Decimal a string para serializaci√≥n JSON segura
        for k, v in item_formateado.items():
            if isinstance(v, Decimal):
                item_formateado[k] = str(v)
            elif isinstance(v, dict):
                # Procesa diccionarios anidados tambi√©n (ej. 'origen', 'destino')
                v_copy = v.copy()
                for sub_k, sub_v in v_copy.items():
                    if isinstance(sub_v, Decimal):
                        v_copy[sub_k] = str(sub_v)
                item_formateado[k] = v_copy

        historial_formateado.append(item_formateado)

    return historial_formateado

==================================================
=== ARCHIVO: ./backend/servicios/trading_logica.py ===
==================================================

"""
Servicio para la l√≥gica de negocio de operaciones de trading (swap).

Este m√≥dulo contiene toda la l√≥gica para procesar, validar y ejecutar un
intercambio de criptomonedas. Est√° dise√±ado para ser llamado desde la capa de
vistas (rutas), recibiendo datos de un formulario y orquestando los pasos
necesarios para completar la operaci√≥n.
"""

from decimal import Decimal, InvalidOperation
from typing import Tuple

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_historial import guardar_en_historial

def procesar_operacion_trading(formulario: dict) -> Tuple[bool, str]:
    """
    Valida y traduce los datos de un formulario de trading a una operaci√≥n de swap.

    Esta funci√≥n act√∫a como una capa de adaptaci√≥n entre la vista y la l√≥gica de
    negocio. Extrae, valida y convierte los datos del formulario antes de
    invocar a la funci√≥n principal `realizar_swap`.

    Args:
        formulario (dict): Un diccionario con los datos del formulario de trading.
                           Ej: {'ticker': 'BTC', 'accion': 'comprar', 'monto': '100', ...}

    Returns:
        Tuple[bool, str]: Una tupla con un booleano de √©xito y un mensaje para el usuario.
    """
    try:
        ticker_principal = formulario["ticker"].upper()
        accion = formulario["accion"]
        monto_form = Decimal(formulario["monto"])
        modo_ingreso = formulario["modo-ingreso"]
    except (KeyError, InvalidOperation, TypeError):
        return False, "‚ùå Error en los datos del formulario."

    if monto_form <= 0:
        return False, "‚ùå El monto debe ser un n√∫mero positivo."

    if accion == "comprar":
        moneda_origen = formulario.get("moneda-pago", "USDT").upper()
        moneda_destino = ticker_principal
    elif accion == "vender":
        moneda_origen = ticker_principal
        moneda_destino = formulario.get("moneda-recibir", "USDT").upper()
    else:
        return False, "‚ùå Acci√≥n no v√°lida."

    if moneda_origen == moneda_destino:
        return False, "‚ùå La moneda de origen y destino no pueden ser la misma."

    return realizar_swap(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion)

def _calcular_detalles_swap(accion: str, modo_ingreso: str, monto_form: Decimal, precio_origen_usdt: Decimal, precio_destino_usdt: Decimal) -> Tuple[bool, dict | str]:
    """
    Calcula las cantidades de origen, destino y el valor total en USD del swap.

    Es una funci√≥n interna y pura que solo realiza c√°lculos sin efectos secundarios.

    Returns:
        Tuple[bool, dict | str]: `(True, {'origen': ..., 'destino': ..., 'valor_usd': ...})` en caso de √©xito,
                                 o `(False, "mensaje de error")` si falla.
    """
    if accion == 'vender' and modo_ingreso == 'total':
        return False, "‚ùå Al vender, debe ingresar la cantidad en modo 'Monto' (Cripto)."

    if accion not in ['comprar', 'vender']:
        return False, "‚ùå Acci√≥n de trading desconocida."

    if accion == 'comprar':
        if modo_ingreso == 'monto':  # Usuario ingresa la cantidad de CRIPTO a recibir
            cantidad_destino = monto_form
            valor_total_usd = cantidad_destino * precio_destino_usdt
            cantidad_origen = valor_total_usd / precio_origen_usdt
        else:  # 'total', usuario ingresa la cantidad de FIAT a gastar
            cantidad_origen = monto_form
            valor_total_usd = cantidad_origen * precio_origen_usdt
            cantidad_destino = valor_total_usd / precio_destino_usdt
    else:  # accion == 'vender'
        cantidad_origen = monto_form
        valor_total_usd = cantidad_origen * precio_origen_usdt
        cantidad_destino = valor_total_usd / precio_destino_usdt

    return True, {
        "origen": cantidad_origen,
        "destino": cantidad_destino,
        "valor_usd": valor_total_usd
    }

def _validar_saldo_suficiente(billetera: dict, moneda_origen: str, cantidad_requerida: Decimal) -> Tuple[bool, str | None]:
    """Verifica si hay suficiente saldo en la billetera para la operaci√≥n."""
    saldo_disponible = billetera.get(moneda_origen, Decimal("0"))
    if cantidad_requerida > saldo_disponible:
        mensaje_error = f"‚ùå Saldo insuficiente. Tienes {saldo_disponible:.8f} {moneda_origen}."
        return False, mensaje_error
    return True, None

def _actualizar_billetera_y_guardar(billetera: dict, moneda_origen: str, cantidad_origen: Decimal, moneda_destino: str, cantidad_destino: Decimal):
    """
    Actualiza los saldos en la billetera y persiste los cambios.

    Resta la cantidad de la moneda de origen y suma la de destino. Si el saldo
    restante es insignificante ("polvo"), lo elimina. Finalmente, guarda el
    estado actualizado de la billetera.

    Side Effects:
        - Modifica el diccionario `billetera`.
        - Llama a `guardar_billetera` para escribir en el archivo.
    """
    billetera[moneda_origen] -= cantidad_origen
    
    # Si el saldo es muy peque√±o ("polvo"), se elimina la moneda de la billetera
    if billetera[moneda_origen] <= Decimal("1e-8"):
        billetera.pop(moneda_origen, None)

    billetera[moneda_destino] = billetera.get(moneda_destino, Decimal("0")) + cantidad_destino
    
    guardar_billetera(billetera)

def _registrar_operacion_historial(moneda_origen: str, cantidad_origen: Decimal, moneda_destino: str, cantidad_destino: Decimal, valor_usd: Decimal):
    """
    Determina el tipo de operaci√≥n y la guarda en el historial.

    Side Effects:
        - Llama a `guardar_en_historial` para escribir en el archivo.
    """
    if moneda_origen == "USDT":
        tipo_operacion = "compra"
    elif moneda_destino == "USDT":
        tipo_operacion = "venta"
    else:
        tipo_operacion = "intercambio"
        
    guardar_en_historial(
        tipo_operacion,
        moneda_origen,
        cantidad_origen.quantize(Decimal("0.00000001")),
        moneda_destino,
        cantidad_destino.quantize(Decimal("0.00000001")),
        valor_usd,
    )

def realizar_swap(moneda_origen: str, moneda_destino: str, monto_form: Decimal, modo_ingreso: str, accion: str) -> Tuple[bool, str]:
    """
    Orquesta la operaci√≥n de swap completa: obtiene precios, calcula, valida y ejecuta.

    Esta es la funci√≥n principal de la l√≥gica de negocio. Sigue una secuencia de
    pasos para asegurar que la operaci√≥n sea v√°lida y se complete correctamente.

    Returns:
        Tuple[bool, str]: Una tupla con un booleano de √©xito y un mensaje para el usuario.
    """
    # 1. Obtener precios actuales
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)

    if precio_origen_usdt is None or precio_destino_usdt is None or precio_destino_usdt.is_zero():
        return False, "‚ùå No se pudo obtener la cotizaci√≥n para realizar el swap."

    # 2. Calcular los detalles del swap
    exito_calculo, resultado = _calcular_detalles_swap(
        accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt
    )
    if not exito_calculo:
        return False, resultado  # resultado aqu√≠ es el mensaje de error

    cantidad_origen = resultado["origen"]
    cantidad_destino = resultado["destino"]
    valor_total_usd = resultado["valor_usd"]

    # 3. Cargar billetera y validar saldo
    billetera = cargar_billetera()
    exito_validacion, mensaje_error = _validar_saldo_suficiente(billetera, moneda_origen, cantidad_origen)
    if not exito_validacion:
        return False, mensaje_error

    # 4. Ejecutar la operaci√≥n (si todo es v√°lido hasta ahora)
    _actualizar_billetera_y_guardar(billetera, moneda_origen, cantidad_origen, moneda_destino, cantidad_destino)
    
    # 5. Registrar en el historial
    _registrar_operacion_historial(moneda_origen, cantidad_origen, moneda_destino, cantidad_destino, valor_total_usd)

    # 6. Devolver mensaje de √©xito
    mensaje_exito = f"‚úÖ Swap exitoso: {cantidad_origen:.8f} {moneda_origen} ‚Üí {cantidad_destino:.8f} {moneda_destino}."
    return True, mensaje_exito

==================================================
=== ARCHIVO: ./backend/servicios/velas_logica.py ===
==================================================

"""
Servicio para la persistencia de datos de mercado en archivos JSON.

Este m√≥dulo, aunque nombrado `velas_logica`, tiene la doble responsabilidad de
guardar y cargar tanto los datos de cotizaciones generales del mercado como los
datos espec√≠ficos de velas (k-lines).
"""

import json
import os
from decimal import Decimal
from typing import Any
from config import COTIZACIONES_PATH, VELAS_PATH


def guardar_datos_cotizaciones(data: list[dict[str, Any]]):
    """
    Guarda los datos de cotizaciones de criptomonedas en un archivo JSON.

    Asegura que el directorio de destino exista y maneja la serializaci√≥n
    de objetos Decimal a float para compatibilidad con JSON.

    Args:
        data (list[dict[str, Any]]): La lista de datos de cotizaciones a guardar.

    Side Effects:
        - Crea el directorio si no existe.
        - Escribe/sobrescribe el archivo `datos_cotizaciones.json`.
        - Imprime logs del proceso en la consola.
    """
    os.makedirs(os.path.dirname(COTIZACIONES_PATH), exist_ok=True)
    print("üíæ Guardando datos en datos_cotizaciones.json...")
    print(f"Cantidad de criptos a guardar: {len(data)}")
    print("üìÅ Guardando en:", os.path.abspath(COTIZACIONES_PATH))

    try:
        with open(COTIZACIONES_PATH, "w") as archivo:
            json.dump(
                data,
                archivo,
                indent=4,
                default=lambda o: float(o) if isinstance(o, Decimal) else o,
            )
        print("‚úÖ Datos guardados correctamente")
    except (IOError, TypeError) as e:
        print(f"‚ùå Error al guardar el archivo: {e}")


def cargar_datos_cotizaciones() -> list[dict[str, Any]]:
    """
    Carga los datos de cotizaciones desde el archivo JSON local.

    Returns:
        list[dict[str, Any]]: La lista de datos de cotizaciones. Retorna una lista
                              vac√≠a si el archivo no existe.
    """
    if not os.path.exists(COTIZACIONES_PATH):
        return []
    try:
        with open(COTIZACIONES_PATH, "r") as archivo:
            return json.load(archivo)
    except (IOError, json.JSONDecodeError) as e:
        print(f"‚ùå Error al cargar datos de cotizaciones: {e}")
        return []


def guardar_datos_velas(data: list[dict[str, Any]]):
    """
    Guarda los datos de velas (k-lines) de una criptomoneda en un archivo JSON.

    Args:
        data (list[dict[str, Any]]): La lista de datos de velas a guardar.

    Side Effects:
        - Crea el directorio si no existe.
        - Escribe/sobrescribe el archivo `datos_velas.json`.
        - Imprime logs del proceso en la consola.
    """
    os.makedirs(os.path.dirname(VELAS_PATH), exist_ok=True)
    print("üíæ Guardando datos en datos_velas.json...")
    print(f"Cantidad de velas a guardar: {len(data)}")
    print("üìÅ Guardando en:", os.path.abspath(VELAS_PATH))

    try:
        with open(VELAS_PATH, "w") as archivo:
            json.dump(
                data,
                archivo,
                indent=4,
                default=lambda o: float(o) if isinstance(o, Decimal) else o,
            )
        print("‚úÖ Datos guardados correctamente")
    except (IOError, TypeError) as e:
        print(f"‚ùå Error al guardar el archivo: {e}")


==================================================
=== ARCHIVO: ./backend/utils/formatters.py ===
==================================================

# backend/utils/formatters.py
"""
Utilidades de formateo para la presentaci√≥n de datos.

Este m√≥dulo proporciona un conjunto de funciones reutilizables para dar formato a
diversos tipos de datos (monetarios, porcentajes, fechas) de una manera
consistente y legible para el usuario final.
"""

from datetime import datetime
from decimal import Decimal
from typing import Union

# Alias de tipo para valores num√©ricos que pueden ser procesados.
Numeric = Union[int, float, Decimal]

def formato_numero_grande(valor: Numeric, simbolo: str = "$") -> str:
    """
    Formatea n√∫meros grandes con abreviaturas (M, B, T) y un s√≠mbolo.

    Args:
        valor (Numeric): El n√∫mero a formatear.
        simbolo (str, optional): S√≠mbolo a prefijar. Por defecto es "$".

    Returns:
        str: El n√∫mero formateado como string. Ej: "$1.25M", "$2.5B".
    """
    if not isinstance(valor, (int, float, Decimal)):
        return "-"
    num = Decimal(valor)

    if num >= 1_000_000_000_000:
        return f"{simbolo}{(num / Decimal('1e12')).quantize(Decimal('0.01'))}T"
    if num >= 1_000_000_000:
        return f"{simbolo}{(num / Decimal('1e9')).quantize(Decimal('0.01'))}B"
    if num >= 1_000_000:
        return f"{simbolo}{(num / Decimal('1e6')).quantize(Decimal('0.01'))}M"
    return f"{simbolo}{num:,.0f}"

def formato_porcentaje(valor: Numeric) -> str:
    """
    Formatea un n√∫mero como un porcentaje con dos decimales.

    Args:
        valor (Numeric): El n√∫mero a formatear.

    Returns:
        str: El n√∫mero como string de porcentaje. Ej: "25.45%".
    """
    if not isinstance(valor, (int, float, Decimal)):
        return "-%"
    return f"{Decimal(valor):.2f}%"

def formato_valor_monetario(valor: Numeric, simbolo: str = "$", decimales: int = 2) -> str:
    """
    Formatea un valor num√©rico como una cadena de texto monetaria.

    Args:
        valor (Numeric): El valor a formatear.
        simbolo (str, optional): S√≠mbolo de la moneda. Por defecto es "$".
        decimales (int, optional): N√∫mero de decimales a mostrar. Por defecto es 2.

    Returns:
        str: El valor formateado. Ej: "$1,234.56".
    """
    if not isinstance(valor, (int, float, Decimal)):
        return "-"
    return f"{simbolo}{Decimal(valor):,.{decimales}f}"

def formato_cantidad_cripto(valor: Numeric, decimales: int = 8) -> str:
    """
    Formatea una cantidad de criptomoneda con una precisi√≥n espec√≠fica.

    Args:
        valor (Numeric): La cantidad a formatear.
        decimales (int, optional): N√∫mero de decimales. Por defecto es 8.

    Returns:
        str: La cantidad formateada. Ej: "0.12345678".
    """
    if not isinstance(valor, (int, float, Decimal)):
        return "-"
    return f"{Decimal(valor):.{decimales}f}"

def formato_fecha_hora(timestamp: Union[int, float, str]) -> str:
    """
    Formatea un timestamp o un string ISO a una fecha y hora local.

    Maneja tanto timestamps num√©ricos (segundos desde la √©poca) como strings
    de fecha en formato ISO 8601.

    Args:
        timestamp (Union[int, float, str]): El timestamp o string a formatear.

    Returns:
        str: La fecha y hora formateada. Ej: "21 Jun 2024, 15:45".
    """
    if not timestamp:
        return "--:--"
    
    try:
        if isinstance(timestamp, (int, float)):
            # Si es un n√∫mero, lo trata como timestamp de Unix
            dt_object = datetime.fromtimestamp(timestamp)
        elif isinstance(timestamp, str):
            # Si es un string, intenta parsearlo como formato ISO
            # El formato recibido del backend es ISO 8601, ej: "2025-06-21T16:57:31.123456"
            dt_object = datetime.fromisoformat(timestamp)
        else:
            # Si no es ni n√∫mero ni string, no se puede formatear
            return "--:--"
            
        # Formatea la fecha y la hora en un formato legible (DD/MM/YYYY HH:MM:SS)
        return dt_object.strftime("%d/%m/%Y %H:%M:%S")
    except (ValueError, TypeError):
        # Captura cualquier error durante la conversi√≥n (ej. string mal formado)
        return "--:--"

==================================================
=== ARCHIVO: ./config.py ===
==================================================

import os
from decimal import getcontext, ROUND_HALF_DOWN

# Base del proyecto y carpeta de datos
PROYECTO_DIR = os.path.dirname(os.path.abspath(__file__))
BASE_DATA_DIR = os.path.join(PROYECTO_DIR, "datos")
os.makedirs(BASE_DATA_DIR, exist_ok=True)

# Rutas de archivos JSON
COTIZACIONES_PATH = os.path.join(BASE_DATA_DIR, "cotizaciones.json")
BILLETERA_PATH = os.path.join(BASE_DATA_DIR, "billetera.json")
HISTORIAL_PATH = os.path.join(BASE_DATA_DIR, "historial.json")
VELAS_PATH = os.path.join(BASE_DATA_DIR, "velas.json")

# Configuraci√≥n general
BALANCE_INICIAL_USDT = "10000"
FLASK_SECRET_KEY = os.environ.get("FLASK_SECRET_KEY", "clave_por_defecto_insegura")

# URLs de APIs
COINGECKO_URL = "https://api.coingecko.com/api/v3/coins/markets"
BINANCE_URL = "https://api.binance.com/api/v3/klines"

# Par√°metros de scraping
CANTIDAD_CRIPTOMONEDAS = 100
CANTIDAD_VELAS = 250

# Decimal global
getcontext().prec = 28
getcontext().rounding = ROUND_HALF_DOWN


==================================================
=== ARCHIVO: ./documentacion.md ===
==================================================

# **1. Diagrama de Arquitectura: El Mapa del Sistema**

El siguiente diagrama visualiza la estructura completa de la aplicaci√≥n, mostrando los componentes principales, sus interacciones y el flujo de informaci√≥n. Los n√∫meros indican la secuencia de una interacci√≥n t√≠pica, que se detalla en la secci√≥n siguiente.

```
      (1) Pide una p√°gina (GET /trading)
+-------------------------------------------------+
|               NAVEGADOR (Usuario)               |
| - Renderiza HTML, CSS y ejecuta JavaScript.     |
| - Env√≠a acciones del usuario (clics, forms).    |
+----------------------+--------------------------+
                       | (14) Muestra UI           ^ (3) Sirve HTML inicial
                       |      actualizada         |
                       v                           |
+----------------------+-------------------------------------------------------------------------------------------+
|                                                   FRONTEND (Cliente)                                             |
|                                         (Se ejecuta completamente en el navegador)                               |
|------------------------------------------------------------------------------------------------------------------|
|  HTML: /templates/*.html                                                                                         |
|  - Esqueleto inicial de la p√°gina, carga los scripts JS.                                                         |
|                                                                                                                  |
|  JS: /static/js/                                                                                                 |
|                                                                                                                  |
|  (4) Inicia l√≥gica de p√°gina                                   (12) Recibe datos y actualiza la UI               |
|      (DOMContentLoaded)                                              |                                           |
|            +                                                         |                                           |
|            |     +-----------------------------+                     v                                           |
|            +---> |      pages/*.js             | --(11) Llama a componentes--->+--------------------------------+|
|                  | (tradingPage.js, etc)       |                     |        |     components/*.js            | |
|                  | - Orquesta la p√°gina.       |                     |        | (uiUpdater, chartRenderer)     | |
|                  | - Llama a servicios.        |                     |        | - Manipulan el DOM.            | |
|                  | - Pasa datos a componentes. |                     |        | - Actualizan tablas, gr√°ficos. | |
|                  +--------------+--------------+                     |        +------------------^-------------+ |
|                                 |                                    |                           | (13)          |
|                                 | (5) Solicita datos a la API        |                           +---------------+
|                                 v                                    |                                           |
|                  +-----------------------------+                     | (10) Devuelve JSON                        |
|                  |    services/apiService.js   |---------------------+-------------------------------------------+
|                  | - Centraliza llamadas fetch().|                                                               |
|                  | - Habla con la API del Backend.|                                                              |
|                  +-----------------------------+                                                                 |
|                                 | (6) Petici√≥n HTTP (GET /api/billetera/estado-completo, POST /trading/operar)   |
+---------------------------------v--------------------------------------------------------------------------------+
                                  |
                                  | (2) Sirve HTML para la ruta inicial (GET /trading)
                                  | (7) Recibe petici√≥n a la API (GET /api/...)
                                  | (15) Procesa formulario (POST /trading/operar)
+---------------------------------v---------------------------------------------------------------------------------+
|                                                   BACKEND (Servidor)                                              |
|                                            (Aplicaci√≥n Flask - Python)                                          |
|-----------------------------------------------------------------------------------------------------------------|
| app.py -> __init__.py                                                                                           |
| - Inicia la app Flask y registra las rutas.                                                                     |
|                                                                                                                 |
| +-------------------------------------------------------------------------------------------------------------+ |
| |                                          RUTAS (Capa de Vistas)                                             | |
| | /rutas/*.py (billetera_vista.py, api_externa.py, etc)                                                       | |
| | - Definen los endpoints (URL).                                                                              | |
| | - Reciben peticiones HTTP del Frontend.                                                                     | |
| | - Llaman a la capa de Servicios para obtener/procesar datos.                                                | |
| | - Devuelven JSON (para /api/...) o HTML (para rutas base).                                                  | |
| +-------------------------------------------------------+-----------------------------------------------------+ |
|                                                         | (8, 16) Llama a la l√≥gica de negocio                  |
|                                                         v                                                       |
| +-------------------------------------------------------+-----------------------------------------------------+ |
| |                                        SERVICIOS (Capa de L√≥gica de Negocio)                                | |
| | /servicios/*.py (trading_logica.py, estado_billetera.py, etc)                                               | |
| | - Contiene el "cerebro" de la app.                                                                          | |
| | - Realiza c√°lculos (ganancias, swap), formatea datos, procesa operaciones.                                  | |
| | - Orquesta llamadas a la capa de Datos y a APIs externas.                                                   | |
| +---------------------+---------------------------------+-------------------------+---------------------------+ |
|                       | (9, 17) Pide/guarda datos crudos |                         | Llama a API externa       |
|                       v                                  v                         v                           v
| +---------------------+--------------------------------+    +----------------------+---------------------------+
| |        ACCESO A DATOS (Capa de Persistencia)         |    |            APIs EXTERNAS (Fuentes de Datos)     |
| | /acceso_datos/*.py (datos_billetera.py, etc)         |    | - CoinGecko (cotizaciones)                        |
| | - Lee y escribe en los archivos .json.               |    | - Binance (velas)                                 |
| | - Abstrae el manejo de archivos.                     |    |                                                   |
| +----------+------------------+------------------------+    +---------------------------------------------------+
|            |                  |                        |
|            | Lee/Escribe      | Lee/Escribe            | Lee/Escribe
|            v                  v                        v
| +----------+---------+  +-----+--------------+  +------+-------------------+
| |  billetera.json    |  | historial.json     |  | cotizaciones.json        |
| +--------------------+  +--------------------+  +--------------------------+
+-----------------------------------------------------------------------------------------------------------------+
```

## **2. El Flujo de Datos en Acci√≥n: Siguiendo los N√∫meros**

Este es el recorrido paso a paso de una interacci√≥n completa, desde la carga de la p√°gina hasta la ejecuci√≥n de una operaci√≥n.

#### **A. Flujo de Carga de una P√°gina (Ej: `/trading`)**

1.  **Petici√≥n Inicial del Usuario:** El usuario navega a `http://localhost:5000/trading`. El navegador env√≠a una petici√≥n `GET` al servidor.

2.  **El Backend Sirve el "Contenedor" HTML:** El servidor Flask recibe la petici√≥n. La capa de **Rutas** (`rutas/trading_vista.py`) la asocia con la funci√≥n `mostrar_trading_page()` y devuelve el archivo `trading.html`. Este HTML es solo un esqueleto, no contiene datos din√°micos.

3.  **El Navegador se Prepara:** El navegador recibe este HTML, lo analiza y comienza a cargar los recursos vinculados, como los archivos CSS y los scripts de JavaScript.

4.  **El Frontend Despierta:** Una vez que la estructura b√°sica del HTML est√° lista (`DOMContentLoaded`), el navegador ejecuta `tradingPage.js`. Aqu√≠ arranca toda la l√≥gica del lado del cliente.

5.  **El Frontend Solicita Datos:** `tradingPage.js` (la capa `pages`) act√∫a como el "director" de la p√°gina. Sabe que necesita datos (cotizaciones, estado de billetera, etc.) para funcionar. Para obtenerlos, llama a las funciones del m√≥dulo `services/apiService.js`.

6.  **Peticiones a la API del Backend:** `apiService.js` convierte esas llamadas en peticiones HTTP reales. Por ejemplo, realiza una petici√≥n `GET` a la URL `/api/billetera/estado-completo`. La clave aqu√≠ es el prefijo `/api/`, que el backend identifica como una solicitud de datos, no de una p√°gina completa.

7.  **La API del Backend Recibe la Solicitud:** Flask recibe esta nueva petici√≥n. La capa de **Rutas** la identifica como una llamada a la API y entiende que debe devolver datos, no HTML.

8.  **Delegaci√≥n a la L√≥gica de Negocio (Servicios):** La funci√≥n de la ruta (ej: `get_estado_billetera_completo()`) no realiza los c√°lculos. Delega esa responsabilidad llamando a la funci√≥n correspondiente en la capa de **Servicios** (ej: `estado_actual_completo()`).

9.  **Los Servicios Orquestan la Respuesta:** La funci√≥n del servicio es el cerebro. Llama a la capa de **Acceso a Datos** para leer la informaci√≥n cruda de los archivos `.json`, realiza los c√°lculos necesarios (ganancias, totales), formatea los datos y los empaqueta.

10. **El Backend Serializa y Devuelve Datos JSON:** El servicio devuelve el paquete de datos a la ruta. La ruta utiliza la funci√≥n `jsonify` de Flask para convertir la estructura de datos de Python en una cadena de texto en formato **JSON**, que es enviada como respuesta al navegador.

11. **El Frontend Recibe y Procesa el JSON:** De vuelta en el navegador, la promesa `fetch` en `apiService.js` se resuelve, entregando los datos JSON. `JSON.parse()` (a menudo manejado autom√°ticamente por `fetch`) convierte esta cadena de texto de nuevo en un objeto JavaScript utilizable.

12. **El Director Distribuye los Datos:** `tradingPage.js` recibe los objetos de datos y sabe qu√© componente de la UI necesita qu√© informaci√≥n.

13. **Los Especialistas de la UI entran en Acci√≥n:** El director pasa los datos a los m√≥dulos `components`. Por ejemplo, entrega los datos del historial a `UIUpdater.js` y los datos de velas a `chartRenderer.js`.

14. **Renderizado del Lado del Cliente:** Estos componentes manipulan el DOM. `UIUpdater` crea din√°micamente las filas `<tr>` para la tabla del historial, y `chartRenderer` dibuja el gr√°fico. El usuario ve c√≥mo la p√°gina "vac√≠a" cobra vida sin necesidad de recargarla. Este proceso se llama **Renderizado del Lado del Cliente (Client-Side Rendering)**.

#### **B. Flujo de una Operaci√≥n (Ej: Comprar BTC)**

15. **El Usuario Env√≠a el Formulario:** El usuario llena el formulario y hace clic en "CONFIRMAR". El navegador empaqueta los datos y env√≠a una petici√≥n `POST` a `/trading/operar`.

16. **La Ruta del Backend Procesa la Acci√≥n:** El backend recibe el `POST`. La ruta `procesar_trading_form()` extrae los datos y llama a la funci√≥n principal de la capa de **Servicios**: `procesar_operacion_trading()`.

17. **El Servicio Ejecuta el Cambio de Estado:** Aqu√≠ ocurren los cambios permanentes. `procesar_operacion_trading()` realiza la validaci√≥n cr√≠tica (saldo, montos v√°lidos), calcula los resultados del swap y, si todo es correcto, llama a la capa de **Acceso a Datos** para que **modifique** los archivos `billetera.json` y `historial.json`. Finalmente, devuelve un mensaje de √©xito o error.

## **3. Glosario T√©cnico y Piezas del Sistema**

#### **I. Conceptos de Arquitectura y Dise√±o**

*   **Arquitectura de Software:** Es el dise√±o fundamental de un sistema. Define los componentes principales, sus responsabilidades y c√≥mo interact√∫an entre s√≠. Una buena arquitectura hace que el sistema sea m√°s f√°cil de entender, mantener y ampliar.
*   **Arquitectura Desacoplada (Decoupled Architecture):** Un principio de dise√±o donde los componentes (frontend y backend) son independientes y se comunican a trav√©s de una interfaz bien definida (la API). El gran beneficio es que se puede cambiar o incluso reemplazar un componente (ej. crear una app m√≥vil que consuma el mismo backend) sin afectar al otro.
*   **Capa (Layer):** Una forma de organizar el c√≥digo en grupos l√≥gicos con responsabilidades espec√≠ficas. En este proyecto, el backend se divide en capas (Rutas, Servicios, Acceso a Datos), lo que promueve el principio de **Separaci√≥n de Intereses (Separation of Concerns)** y hace que el c√≥digo sea m√°s limpio.

#### **II. Comunicaci√≥n y Datos (Cliente-Servidor)**

*   **API (Application Programming Interface):** Un contrato que define c√≥mo dos piezas de software deben comunicarse. Establece un conjunto de reglas, endpoints y formatos de datos que el servidor expone para que los clientes puedan interactuar con √©l de manera predecible.
*   **API REST (Representational State Transfer):** Un estilo arquitect√≥nico para dise√±ar APIs que se basa en principios como:
    1.  **Operaciones sobre Recursos:** La API se centra en "recursos" (ej: `cotizaciones`, `billetera`).
    2.  **Uso de M√©todos HTTP:** Se utilizan los verbos est√°ndar (`GET` para obtener, `POST` para crear) para manipular estos recursos.
    3.  **Comunicaci√≥n sin Estado (Stateless):** Cada petici√≥n del cliente debe contener toda la informaci√≥n necesaria para ser entendida. El servidor no guarda ning√∫n contexto del cliente entre peticiones.
*   **Endpoint:** Una URL espec√≠fica en la API que expone un recurso o una acci√≥n. Por ejemplo, `/api/cotizaciones` y `/api/historial` son dos endpoints distintos.
*   **JSON (JavaScript Object Notation):** Un formato de texto ligero para el intercambio de datos. Es el "idioma" que hablan el frontend y el backend. Su estructura es f√°cilmente convertible a objetos de JavaScript, lo que lo hace ideal para aplicaciones web.

#### **III. Componentes y Tecnolog√≠as del Backend (Python/Flask)**

*   **Backend:** La parte de la aplicaci√≥n que se ejecuta en el servidor. Es responsable de la l√≥gica de negocio, la seguridad y la gesti√≥n de datos.
*   **Flask:** Un micro-framework de Python para construir aplicaciones web. Proporciona las herramientas esenciales para manejar rutas y peticiones HTTP, permitiendo una gran flexibilidad en la estructura del proyecto.
*   **Patr√≥n de F√°brica de Aplicaciones (Application Factory):** La pr√°ctica de crear la instancia de la aplicaci√≥n Flask dentro de una funci√≥n (`crear_app()`) en lugar de globalmente. Esto facilita las pruebas y la configuraci√≥n de m√∫ltiples instancias.
*   **Blueprint:** Un componente de Flask para organizar las rutas en grupos modulares. Permite que la aplicaci√≥n sea m√°s escalable y que las rutas relacionadas con una funcionalidad (ej. `trading`) est√©n juntas en un mismo archivo.
*   **Persistencia:** La capacidad de que los datos se conserven incluso despu√©s de que el programa se cierre. En este proyecto, se logra mediante la escritura de datos en archivos `.json` en el disco duro.
*   **`Decimal` (Tipo de Dato):** Un tipo num√©rico de alta precisi√≥n utilizado para c√°lculos financieros. A diferencia de los n√∫meros de punto flotante est√°ndar, `Decimal` evita peque√±os errores de redondeo que son inaceptables al manejar dinero.

#### **IV. Componentes y Tecnolog√≠as del Frontend (JavaScript)**

*   **Frontend:** La parte de la aplicaci√≥n que se ejecuta en el navegador del usuario y con la que este interact√∫a directamente.
*   **DOM (Document Object Model):** Una representaci√≥n en memoria de la estructura de un documento HTML. JavaScript utiliza el DOM para leer y modificar din√°micamente el contenido y la apariencia de la p√°gina.
*   **Manipulaci√≥n del DOM:** El proceso de usar JavaScript para cambiar el DOM, lo que resulta en actualizaciones visuales en la p√°gina sin necesidad de recargarla. Esta es la base del renderizado del lado del cliente.
*   **Manejo de Eventos (Event Handling):** La capacidad de JavaScript para responder a acciones del usuario (un `click` en un bot√≥n, un `change` en un selector). Un "escuchador de eventos" (`event listener`) espera a que ocurra un evento y ejecuta una funci√≥n en respuesta.
*   **C√≥digo As√≠ncrono (`async`/`await`):** En JavaScript, las operaciones de red (como las peticiones `fetch` a la API) son as√≠ncronas. Esto significa que el c√≥digo no espera a que la operaci√≥n termine, sino que contin√∫a ejecut√°ndose. `async/await` es una sintaxis moderna que permite escribir c√≥digo as√≠ncrono de una manera que parece s√≠ncrona, haci√©ndolo mucho m√°s f√°cil de leer y depurar.

## **4. Las Piezas del Engranaje: Descripci√≥n Detallada de Capas**

*   **Capa de Presentaci√≥n (Frontend):**
    *   **Prop√≥sito:** Crear la experiencia visual e interactiva del usuario. Es aut√≥noma y solo necesita conocer el "contrato" de la API del backend para funcionar.
    *   **Componentes Clave:**
        *   **`pages/*.js`:** Los orquestadores de cada p√°gina. Inician la carga de datos y coordinan la actualizaci√≥n de la UI.
        *   **`services/apiService.js`:** El punto √∫nico de comunicaci√≥n con el backend. Centraliza toda la l√≥gica de `fetch`.
        *   **`components/*.js`:** M√≥dulos reutilizables con responsabilidades √∫nicas (renderizar el gr√°fico, actualizar la tabla, etc.).

*   **Capa de Vistas/Rutas (Backend - `rutas/`):**
    *   **Prop√≥sito:** Actuar como el controlador de tr√°fico del backend. Es la puerta de entrada para todas las peticiones HTTP.
    *   **Funcionamiento:** Asocia las URLs (endpoints) con funciones de Python. No contiene l√≥gica de negocio; su trabajo es validar la petici√≥n (si es necesario) y delegar la tarea a la capa de servicios.

*   **Capa de L√≥gica de Negocio (Backend - `servicios/`):**
    *   **Prop√≥sito:** Es el cerebro de la aplicaci√≥n. Aqu√≠ residen todas las reglas, c√°lculos y procesos de negocio.
    *   **Funcionamiento:** Orquesta las operaciones complejas. Por ejemplo, para un `swap`, obtiene precios, valida el saldo, calcula las cantidades, invoca a la capa de datos para guardar los cambios y prepara una respuesta.

*   **Capa de Acceso a Datos (Backend - `acceso_datos/`):**
    *   **Prop√≥sito:** Abstraer y gestionar la interacci√≥n con la fuente de datos (en este caso, los archivos `.json`).
    *   **Funcionamiento:** Proporciona funciones simples y claras como `cargar_billetera()` o `guardar_en_historial()`. La capa de servicios no necesita saber c√≥mo o d√≥nde se guardan los datos, solo pide que se realicen las operaciones.

==================================================
=== ARCHIVO: ./frontend/static/css/styles_index.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030;
    color: #f0c000;
}

.logo-cripto {
    margin-right: 1.5rem;
    vertical-align: middle;
}

.nombre-cripto {
    padding-left: 0.75rem;
    font-weight: bold;
    font-size: 1.05rem;
}

.logo-cripto {
    margin-right: 10px;
    vertical-align: middle;
}

.ticker-cripto {
    color: #aaaaaa;
    font-size: 0.85rem;
    margin-left: 4px;
}

table thead th {
    font-size: 0.85rem;
    font-weight: 500;
    text-transform: uppercase;
}

td,
th {
    white-space: nowrap;
}

/* PRECIO */
table td:nth-child(3),
table th:nth-child(3) {
    min-width: 100px;
    font-weight: bold;
}
table td:nth-child(4),
table th:nth-child(4),
table td:nth-child(5),
table th:nth-child(5),
table td:nth-child(6),
table th:nth-child(6) {
    min-width: 80px; /* 1H, 24H, 7D */
}
table td:nth-child(8),
table th:nth-child(8),
table td:nth-child(9),
table th:nth-child(9) {
    min-width: 100px; /* VOLUME, SUPPLY */
}

/* Limita el ancho de la columna Name (columna 2) */
table td:nth-child(2),
table th:nth-child(2) {
    max-width: 220px; /* prob√° ajustar este valor */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.positivo {
    color: var(--color-verde);
    font-weight: 500;
}

.negativo {
    color: var(--color-rojo);
    font-weight: 500;
}

.flecha-verde,
.flecha-roja {
    font-size: 0.7em; /* m√°s peque√±o que el texto base */
    vertical-align: middle;
    margin-right: 4px;
}

.flecha-verde {
    color: var(--color-verde);
    margin-right: 4px;
}

.flecha-roja {
    color: var(--color-rojo);
    margin-right: 4px;
}


==================================================
=== ARCHIVO: ./frontend/static/css/styles_trading.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
    --color-azul-activo: #0d6efd; /* Azul de Bootstrap para botones activos */
    --color-fondo-base: #343a40; /* Un gris oscuro para fondos de input/select */
    --color-borde: #6c757d; /* Un gris m√°s claro para bordes */
    --color-texto: #f8f9fa; /* Texto casi blanco */
    --border-radius-suave: 0.375rem; /* El radio de borde por defecto de Bootstrap */
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #1e1e1e !important; /* Un fondo un poco m√°s oscuro que antes */
    color: #f0c000;
}

#chart {
    display: block;
    overflow: hidden;
    width: 100%;
    max-width: 100%;
    min-height: 500px;
}

/* --- ESTILOS UNIFICADOS PARA EL FORMULARIO --- */

/* Estilo base para todos los controles de formulario */
.form-control,
.form-select,
.select2-container--bootstrap-5 .select2-selection {
    background-color: var(--color-fondo-base) !important;
    color: var(--color-texto) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave) !important;
    box-shadow: none !important; /* Eliminar sombras por defecto */
}

/* Placeholder text color */
.form-control::placeholder {
    color: #999;
}

/* Estilo para los grupos de botones (Tipo de orden, Ingresar por, Timeframes) */
.btn-group .btn-outline-primary,
.btn-group .btn-outline-secondary {
    color: var(--color-texto);
    border-color: var(--color-borde);
}

/* Estilo para el bot√≥n ACTIVO en los grupos */
.btn-group .btn-check:checked + .btn-outline-primary,
.btn-group .btn.active {
    background-color: var(--color-azul-activo);
    border-color: var(--color-azul-activo);
    color: var(--color-texto);
}
.btn-group .timeframe-btn.active {
    background-color: var(--color-azul-activo) !important;
    border-color: var(--color-azul-activo) !important;
}

/* --- ESTILOS PERSONALIZADOS PARA SELECT2 --- */

/* Contenedor principal de Select2 */
.select2-container--bootstrap-5 .select2-selection {
    height: calc(1.5em + 0.75rem + 2px); /* Altura est√°ndar de Bootstrap */
    padding: 0.375rem 0.75rem;
    line-height: 1.5;
}

/* Flecha del dropdown de Select2 */
.select2-container--bootstrap-5 .select2-selection__arrow b {
    border-color: var(--color-texto) transparent transparent transparent !important;
}

/* Estilos para el Dropdown (la lista que se abre) */
.select2-dropdown {
    background-color: var(--color-fondo-base) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave) !important;
}

/* Campo de b√∫squeda dentro del dropdown */
.select2-search__field {
    background-color: #495057 !important;
    color: var(--color-texto) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave);
}

/* Opciones de la lista */
.select2-results__option {
    color: var(--color-texto) !important;
}

/* Opci√≥n seleccionada actualmente en la lista */
.select2-results__option--selected {
    background-color: #5a6268 !important;
}

/* Opci√≥n bajo el cursor del rat√≥n (hover) */
.select2-results__option--highlighted {
    background-color: var(--color-azul-activo) !important;
    color: var(--color-texto) !important;
}

/* --- L√ìGICA DE BOTONES DE COMPRA/VENTA (SIN CAMBIOS DE L√ìGICA, S√ìLO EST√âTICA) --- */
.boton-comprar.active {
    background-color: var(--color-verde) !important;
    border-color: var(--color-verde) !important;
}
.boton-vender.active {
    background-color: var(--color-rojo) !important;
    border-color: var(--color-rojo) !important;
}
.btn-outline-secondary {
    background-color: transparent;
    border-color: var(--color-borde);
}
.btn-outline-secondary:hover {
    background-color: var(--color-fondo-base);
}

/* --- OVERLAY DE ERROR (SIN CAMBIOS) --- */
.chart-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(30, 30, 30, 0.85);
    color: #f0c000;
    font-size: 1.2rem;
    font-weight: 500;
    text-align: center;
    padding: 20px;
    z-index: 10;
    border-radius: 8px;
    transition: opacity 0.3s ease-in-out;
}

.select2-container--bootstrap-5 .select2-selection--single .select2-selection__rendered,
.form-control::placeholder {
    color: var(--color-texto) !important;
}


==================================================
=== ARCHIVO: ./frontend/static/js/components/chartRenderer.js ===
==================================================

/**
 * @module chartRenderer
 * @description Gestiona la creaci√≥n, inicializaci√≥n y actualizaci√≥n del gr√°fico financiero
 * de velas utilizando la biblioteca Lightweight Charts‚Ñ¢.
 * Este m√≥dulo es responsable de todas las interacciones directas con la instancia del gr√°fico.
 */

// Variables globales para mantener las instancias del gr√°fico y sus series.
let chart;
let candleSeries;
let volumeSeries;

/**
 * @typedef {object} CandleData
 * @property {string} time - Marca de tiempo en formato 'YYYY-MM-DD'.
 * @property {number} open - Precio de apertura.
 * @property {number} high - Precio m√°ximo.
 * @property {number} low - Precio m√≠nimo.
 * @property {number} close - Precio de cierre.
 * @property {number} volume - Volumen de la operaci√≥n.
 */

/**
 * Crea e inicializa el gr√°fico de velas en la primera carga.
 * Configura la apariencia del gr√°fico, a√±ade las series de velas y volumen,
 * y establece los listeners de eventos para la interactividad.
 *
 * @param {CandleData[]} initialData - El conjunto de datos inicial de velas para mostrar.
 * @side-effects Manipula el DOM para crear el gr√°fico dentro del elemento '#chart'.
 *               Tambi√©n adjunta un ResizeObserver para manejar el redimensionamiento responsivo.
 */
export function initializeChart(initialData) {
    const chartContainer = document.getElementById('chart');
    if (!chartContainer) {
        console.warn("Elemento #chart no encontrado. No se puede renderizar el gr√°fico.");
        return;
    }
    if (!window.LightweightCharts) {
        console.error("La biblioteca LightweightCharts no est√° cargada.");
        return;
    }

    // Crea la instancia principal del gr√°fico con estilos personalizados.
    chart = window.LightweightCharts.createChart(chartContainer, {
        width: chartContainer.clientWidth,
        height: 500,
        layout: { textColor: '#ccc', background: { type: 'solid', color: '#1E1E1E' } },
        grid: { vertLines: { color: '#2B2B2B' }, horzLines: { color: '#2B2B2B' } },
        priceScale: { borderColor: '#485c7b' },
        timeScale: { borderColor: '#485c7b' },
    });

    // A√±ade la serie principal de velas para la acci√≥n del precio.
    candleSeries = chart.addCandlestickSeries({
        upColor: 'rgb(31, 191, 113)',
        downColor: 'rgb(226, 33, 52)',
        borderDownColor: 'rgb(226, 33, 52)',
        borderUpColor: 'rgb(31, 191, 113)',
        wickDownColor: '#838ca1',
        wickUpColor: '#838ca1',
    });

    // A√±ade una serie secundaria de histograma para el volumen de operaciones.
    volumeSeries = chart.addHistogramSeries({
        priceFormat: { type: 'volume' },
        priceScaleId: '', // Se adjunta a una escala de precios separada.
    });
    // Ajusta la escala de precios de la serie de volumen para darle m√°s espacio.
    volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });

    if (initialData && initialData.length > 0) {
        updateChartData(initialData);
    }

    // A√±ade un listener de eventos al checkbox para alternar la visibilidad del volumen.
    const volumeCheckbox = document.getElementById('toggleVolume');
    if (volumeCheckbox) {
        volumeCheckbox.addEventListener('change', (e) => {
            volumeSeries.applyOptions({ visible: e.target.checked });
        });
    }

    // Asegura que el gr√°fico se ajuste a su contenido y sea responsivo.
    chart.timeScale().fitContent();
    new ResizeObserver(() => chart.applyOptions({ width: chartContainer.clientWidth })).observe(chartContainer);
}

/**
 * Actualiza el gr√°fico con un nuevo conjunto de datos de velas.
 * Maneja tanto el caso en que hay datos disponibles como en el que no, mostrando
 * u ocultando un mensaje de error superpuesto seg√∫n corresponda.
 *
 * @param {CandleData[]} data - El nuevo array de datos de velas. Si el array est√° vac√≠o
 *        o es nulo, limpia el gr√°fico y muestra un mensaje de error.
 */
export function updateChartData(data) {
    if (!candleSeries || !volumeSeries) {
        console.warn("El gr√°fico no est√° inicializado. No se pueden actualizar los datos.");
        return;
    }

    const errorOverlay = document.getElementById('chart-error-overlay');

    if (data && data.length > 0) {
        // Oculta el mensaje de error si hay datos disponibles.
        errorOverlay.style.display = 'none';

        // Mapea los datos brutos al formato requerido por Lightweight Charts.
        const candleData = data.map(item => ({
            time: item.time,
            open: Number(item.open),
            high: Number(item.high),
            low: Number(item.low),
            close: Number(item.close)
        }));
        const volumeData = data.map(item => ({
            time: item.time,
            value: Number(item.volume),
            color: Number(item.close) > Number(item.open) ? 'rgba(31, 191, 113, 0.5)' : 'rgba(226, 33, 52, 0.5)'
        }));

        console.log(`üìä Actualizando gr√°fico con ${data.length} velas.`);
        candleSeries.setData(candleData);
        volumeSeries.setData(volumeData);
    } else {
        // Si no hay datos disponibles, limpia las series y muestra el overlay de error.
        console.log("üìä No hay datos de velas disponibles. Mostrando mensaje de error.");
        candleSeries.setData([]);
        volumeSeries.setData([]);
        errorOverlay.style.display = 'flex'; // Se usa 'flex' para que coincida con el centrado del CSS.
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/domElements.js ===
==================================================

/**
 * @module DOMElements
 * @description Centraliza las referencias a los elementos del DOM a los que se accede con frecuencia.
 * Este patr√≥n mejora el rendimiento al cachear los objetos jQuery, evitando consultas
 * redundantes al DOM y facilitando el mantenimiento del c√≥digo.
 */

/**
 * Un objeto que contiene referencias cacheadas de jQuery a los elementos del DOM
 * utilizados en la interfaz de trading.
 * @type {Object<string, JQuery>}
 */
export const DOMElements = {
    // Contenedor principal del formulario de trading
    form: $('#formulario-trading'),
    // Selector principal de criptomonedas (ej. BTC, ETH)
    selectorPrincipal: $('#cripto'),
    // Desplegable para seleccionar la moneda de pago (en una compra)
    selectorPagarCon: $('#moneda-pago'),
    // Desplegable para seleccionar la moneda a recibir (en una venta)
    selectorRecibirEn: $('#moneda-recibir'),
    // Bot√≥n de acci√≥n 'Comprar'
    botonComprar: $('.boton-comprar'),
    // Bot√≥n de acci√≥n 'Vender'
    botonVender: $('.boton-vender'),
    // Bot√≥n final 'Confirmar' para la transacci√≥n
    botonConfirmar: $('.boton-confirmar'),
    // Input oculto que almacena la acci√≥n actual ('comprar' o 'vender')
    inputAccion: $('#accion'),
    // Contenedor para el desplegable 'Pagar con'
    campoPagarCon: $('#campo-pagar-con'),
    // Contenedor para el desplegable 'Recibir en'
    campoRecibirEn: $('#campo-recibir-en'),
    // Span para mostrar el saldo disponible del usuario
    spanSaldoDisponible: $('#saldo-disponible'),
    // Botones de radio para cambiar entre modos de ingreso ('monto' vs 'total')
    radioModoIngreso: $('input[name="modo-ingreso"]'),
    // Etiqueta para el campo de entrada de monto
    labelMonto: $('label[for="monto"]'),
    // Campo de entrada principal para el monto
    inputMonto: $('#monto'),
    // Slider para ajustar el monto
    sliderMonto: $('#slider-monto'),
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/formLogic.js ===
==================================================

/**
 * @module FormLogic
 * @description Encapsula la l√≥gica principal para manejar las interacciones del usuario
 * y la manipulaci√≥n de datos dentro del formulario de trading.
 */

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';

/**
 * @typedef {Object} Moneda
 * @property {string} ticker - El s√≠mbolo de la moneda (ej. 'BTC').
 * @property {string} nombre - El nombre completo de la moneda (ej. 'Bitcoin').
 */

/**
 * Colecci√≥n de funciones que gestionan la l√≥gica del formulario de trading.
 */
export const FormLogic = {
    /**
     * Rellena un elemento <select> con una lista de opciones.
     *
     * @param {JQuery} selector - El objeto jQuery para el elemento <select> que se va a rellenar.
     * @param {Moneda[]} lista - Un array de objetos para crear las opciones.
     * @param {string} [valorPorDefecto] - El ticker del √≠tem que se seleccionar√° por defecto.
     * @returns {string|null} El ticker del valor finalmente seleccionado, o null si la lista est√° vac√≠a.
     * @side-effects Limpia y a√±ade elementos <option> al DOM. Dispara un evento 'change'.
     */
    popularSelector(selector, lista, valorPorDefecto) {
        selector.empty();
        lista.forEach(({ ticker, nombre }) => selector.append(new Option(`${nombre} (${ticker})`, ticker)));

        const valorFinal = (valorPorDefecto && lista.some(m => m.ticker === valorPorDefecto))
            ? valorPorDefecto
            : (lista.length > 0 ? lista[0].ticker : null);

        if (valorFinal) {
            selector.val(valorFinal).trigger('change');
        }
        return valorFinal;
    },

    /**
     * Calcula el monto de la operaci√≥n basado en el porcentaje del slider.
     *
     * Esta funci√≥n determina el saldo disponible de la moneda relevante
     * (moneda de pago para compras, moneda principal para ventas) y calcula
     * el monto correspondiente al porcentaje del slider.
     *
     * @returns {number} El monto calculado para la operaci√≥n.
     */
    calcularMontoSlider() {
        // Comprobaci√≥n defensiva: si los datos de monedas del usuario a√∫n no se han cargado,
        // devuelve 0 para evitar errores al inicio.
        if (!window.ownedCoins) {
            return 0;
        }

        const porcentaje = parseFloat(DOMElements.sliderMonto.val());
        const esCompra = UIState.esModoCompra();

        // Determina qu√© saldo de moneda usar seg√∫n la direcci√≥n de la operaci√≥n.
        const tickerDeSaldo = esCompra ? UIState.getTickerPago() : UIState.getTickerPrincipal();
        if (!tickerDeSaldo) return 0;

        // Busca la moneda espec√≠fica en la billetera del usuario y obtiene su cantidad disponible.
        const moneda = window.ownedCoins.find(m => m.ticker === tickerDeSaldo);
        const saldoDisponible = moneda ? parseFloat(moneda.cantidad) : 0;

        return (saldoDisponible * porcentaje) / 100.0;
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/tablaCotizacionesUI.js ===
==================================================

/**
 * @module tablaCotizacionesUI
 * @description Controla la renderizaci√≥n y actualizaci√≥n de la tabla de cotizaciones de criptomonedas.
 */

import { fetchCotizaciones } from '../services/apiService.js';
import { UIUpdater } from './uiUpdater.js';

const cuerpoTabla = document.getElementById('tabla-datos');

/**
 * @typedef {object} Cotizacion
 * @property {string} logo - URL del logo de la criptomoneda.
 * @property {string} nombre - Nombre de la criptomoneda.
 * @property {string} ticker - S√≠mbolo de la criptomoneda.
 * @property {string} precio_usd_formatted - Precio formateado en USD.
 * @property {string} '1h_%' - Variaci√≥n porcentual en la √∫ltima hora.
 * @property {string} '24h_%' - Variaci√≥n porcentual en las √∫ltimas 24 horas.
 * @property {string} '7d_%' - Variaci√≥n porcentual en los √∫ltimos 7 d√≠as.
 * @property {string} '1h_%_formatted' - Variaci√≥n porcentual formateada (1h).
 * @property {string} '24h_%_formatted' - Variaci√≥n porcentual formateada (24h).
 * @property {string} '7d_%_formatted' - Variaci√≥n porcentual formateada (7d).
 * @property {string} market_cap_formatted - Capitalizaci√≥n de mercado formateada.
 * @property {string} volumen_24h_formatted - Volumen de 24h formateado.
 * @property {string} circulating_supply_formatted - Suministro circulante formateado.
 */

/**
 * Crea el HTML para una fila de la tabla de cotizaciones.
 *
 * @private
 * @param {Cotizacion} cripto - El objeto de datos de la criptomoneda.
 * @param {number} index - El n√∫mero de fila (√≠ndice + 1).
 * @returns {string} Una cadena de texto con el HTML del `<tr>` para la criptomoneda.
 */
function createFilaCotizacionHTML(cripto, index) {
    /**
     * Determina la clase CSS y el s√≠mbolo de flecha para valores de rendimiento.
     * @param {string|number} value - El valor num√©rico a evaluar.
     * @returns {{className: string, arrow: string}} Objeto con la clase ('positivo' o 'negativo') y la flecha ('‚ñ≤' o '‚ñº').
     */
    const getPerfIndicator = (value) => {
        const isPositive = parseFloat(value) >= 0;
        return {
            className: isPositive ? 'positivo' : 'negativo',
            arrow: isPositive ? '‚ñ≤' : '‚ñº'
        };
    };

    const perf1h = getPerfIndicator(cripto['1h_%']);
    const perf24h = getPerfIndicator(cripto['24h_%']);
    const perf7d = getPerfIndicator(cripto['7d_%']);

    return `
        <tr>
            <td class="text-start px-3">${index}</td>
            <td class="text-start px-3">
                <img src="${cripto.logo}" width="20" class="logo-cripto" alt="${cripto.ticker} logo">
                <span class="nombre-cripto">${cripto.nombre}</span>
                <span class="ticker-cripto">(${cripto.ticker})</span>
            </td>
            <td class="text-start px-3 fw-bold">${cripto.precio_usd_formatted}</td>
            
            <td class="text-end px-3">
                <span class="${perf1h.className}">
                    <span class="flecha">${perf1h.arrow}</span>
                    ${cripto['1h_%_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${perf24h.className}">
                    <span class="flecha">${perf24h.arrow}</span>
                    ${cripto['24h_%_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${perf7d.className}">
                    <span class="flecha">${perf7d.arrow}</span>
                    ${cripto['7d_%_formatted']}
                </span>
            </td>
            
            <td class="text-end px-3">${cripto.market_cap_formatted}</td>
            <td class="text-end px-3">${cripto.volumen_24h_formatted}</td>
            <td class="text-end px-3">${cripto.circulating_supply_formatted}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de cotizaciones y renderiza la tabla completa en el DOM.
 * Maneja los estados de carga, √©xito y error.
 * @async
 * @side-effects Modifica el `innerHTML` del elemento '#tabla-datos'.
 *               Puede mostrar un mensaje de error global a trav√©s de `UIUpdater`.
 */
export async function renderTabla() {
    if (!cuerpoTabla) return;
    try {
        const cotizaciones = await fetchCotizaciones();
        if (!cotizaciones || cotizaciones.length === 0) {
            cuerpoTabla.innerHTML =
                '<tr><td colspan="9" class="text-center text-muted py-4">No hay datos disponibles.</td></tr>';
            return;
        }
        cuerpoTabla.innerHTML = cotizaciones.map((cripto, index) => createFilaCotizacionHTML(cripto, index + 1)).join('');
    } catch (error) {
        console.error('‚ùå Error al renderizar la tabla de cotizaciones:', error);
        UIUpdater.mostrarMensajeError('No se pudieron cargar las cotizaciones. La informaci√≥n puede estar desactualizada.');
        // Muestra un estado de error en la propia tabla para informar al usuario.
        cuerpoTabla.innerHTML = '<tr><td colspan="9" class="text-center text-danger py-4">Error al cargar las cotizaciones.</td></tr>';
    }
}


==================================================
=== ARCHIVO: ./frontend/static/js/components/uiState.js ===
==================================================

/**
 * @module uiState
 * @description Proporciona un objeto centralizado para consultar el estado actual de la interfaz de usuario.
 * Este m√≥dulo abstrae la l√≥gica de acceso a los valores de los elementos del DOM, facilitando
 * la obtenci√≥n de informaci√≥n sobre el estado de la UI sin interactuar directamente con `DOMElements`.
 */

import { DOMElements } from './domElements.js';

/**
 * @description Un objeto que agrupa funciones para obtener diferentes aspectos del estado de la UI.
 * Cada m√©todo consulta un elemento del DOM a trav√©s de `DOMElements` y devuelve su estado actual.
 * @exports UIState
 */
export const UIState = {
    /**
     * Comprueba si el modo de operaci√≥n actual es 'comprar'.
     * @returns {boolean} `true` si la acci√≥n seleccionada es 'comprar', de lo contrario `false`.
     */
    esModoCompra() {
        return DOMElements.inputAccion.val() === 'comprar';
    },

    /**
     * Obtiene el modo de ingreso seleccionado (ej. 'cantidad' o 'monto').
     * @returns {string} El valor del radio button seleccionado para el modo de ingreso.
     */
    getModoIngreso() {
        return DOMElements.radioModoIngreso.filter(':checked').val();
    },

    /**
     * Obtiene el ticker de la criptomoneda principal seleccionada.
     * @returns {string} El ticker de la criptomoneda en el selector principal.
     */
    getTickerPrincipal() {
        return DOMElements.selectorPrincipal.val();
    },

    /**
     * Obtiene el ticker de la moneda utilizada para pagar.
     * @returns {string} El ticker de la moneda en el selector 'pagar con'.
     */
    getTickerPago() {
        return DOMElements.selectorPagarCon.val();
    },

    /**
     * Obtiene el ticker de la moneda que se recibir√°.
     * @returns {string} El ticker de la moneda en el selector 'recibir en'.
     */
    getTickerRecibo() {
        return DOMElements.selectorRecibirEn.val();
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiUpdater.js ===
==================================================

/**
 * @module uiUpdater
 * @description Centraliza todas las funciones que actualizan din√°micamente la interfaz de usuario.
 * Este m√≥dulo es responsable de cambiar la apariencia y el contenido de los elementos del DOM
 * en respuesta a las acciones del usuario y los datos de la aplicaci√≥n.
 */

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';

/**
 * @description Objeto que agrupa m√©todos para manipular la interfaz de usuario.
 * @exports UIUpdater
 */
export const UIUpdater = {
    /**
     * Actualiza el texto y estilo de los botones de acci√≥n (comprar/vender) seg√∫n el modo actual.
     * @side-effects Modifica el texto y las clases CSS de `botonConfirmar`, `botonComprar` y `botonVender`.
     */
    actualizarBotones() {
        const esCompra = UIState.esModoCompra();
        DOMElements.botonConfirmar
            .text(esCompra ? 'COMPRAR' : 'VENDER')
            .toggleClass('btn-success', esCompra)
            .toggleClass('btn-danger', !esCompra);
        DOMElements.botonComprar
            .toggleClass('active btn-success', esCompra)
            .toggleClass('btn-outline-secondary', !esCompra);
        DOMElements.botonVender
            .toggleClass('active btn-danger', !esCompra)
            .toggleClass('btn-outline-secondary', esCompra);
    },

    /**
     * Muestra u oculta los campos de 'Pagar con' y 'Recibir en' seg√∫n el modo de operaci√≥n.
     * @side-effects Modifica la visibilidad y el estado `disabled` de los selectores correspondientes.
     */
    actualizarVisibilidadCampos() {
        const esCompra = UIState.esModoCompra();
        DOMElements.campoPagarCon.toggle(esCompra);
        DOMElements.campoRecibirEn.toggle(!esCompra);
        DOMElements.selectorPagarCon.prop('disabled', !esCompra);
        DOMElements.selectorRecibirEn.prop('disabled', esCompra);
    },

    /**
     * Actualiza la etiqueta del campo de monto/cantidad para reflejar la moneda relevante.
     * @side-effects Modifica el texto de `labelMonto`.
     */
    actualizarLabelMonto() {
        const esModoMonto = UIState.getModoIngreso() === 'monto';
        const esCompra = UIState.esModoCompra();
        let tickerRelevante = '';

        if (esCompra) {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerPago();
        } else {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerRecibo();
        }

        const etiqueta = esModoMonto ? 'Cantidad' : 'Total';
        DOMElements.labelMonto.text(`${etiqueta} (${tickerRelevante || '...'})`);
    },

    /**
     * Muestra el saldo disponible para una moneda espec√≠fica.
     * Se asegura de que el objeto `window.ownedCoins` est√© disponible antes de intentar leerlo.
     * @param {string} ticker - El ticker de la moneda para la cual mostrar el saldo.
     * @side-effects Modifica el texto de `spanSaldoDisponible`.
     */
    mostrarSaldo(ticker) {
        if (!ticker) {
            DOMElements.spanSaldoDisponible.text('--');
            return;
        }

        // Es crucial que 'window.ownedCoins' exista para evitar errores de referencia.
        if (!window.ownedCoins) {
            console.warn('Intento de mostrar saldo antes de que window.ownedCoins est√© listo.');
            DOMElements.spanSaldoDisponible.text('Cargando...');
            return;
        }

        const moneda = window.ownedCoins.find((m) => m.ticker === ticker);
        const saldoFormateado = moneda ? moneda.cantidad_formatted : '0.00000000';
        DOMElements.spanSaldoDisponible.text(`${saldoFormateado} ${ticker}`);
    },

    /**
     * Establece el valor del campo de entrada de monto.
     * @param {string|number} valor - El valor a establecer en el input.
     * @side-effects Modifica el valor de `inputMonto`.
     */
    setInputMonto(valor) {
        DOMElements.inputMonto.val(valor);
    },

    /**
     * Reinicia el control deslizante de monto a su valor inicial (0).
     * @side-effects Modifica el valor de `sliderMonto`.
     */
    resetSlider() {
        DOMElements.sliderMonto.val(0);
    },

    /**
     * Renderiza la tabla del historial de transacciones.
     * @param {Array<object>} historialData - Un array de objetos de transacciones.
     * @side-effects Modifica el `innerHTML` de `tabla-historial`.
     */
    renderHistorial(historialData) {
        const tablaHistorial = $('#tabla-historial');
        if (!tablaHistorial.length) return;

        if (historialData.length === 0) {
            tablaHistorial.html(
                '<tr><td colspan="5" class="text-center text-muted py-3">No hay transacciones en el historial.</td></tr>'
            );
            return;
        }

        const historialHTML = historialData
            .map((item) => {
                const claseTipo = item.tipo === 'compra' ? 'text-success' : 'text-danger';

                return `
                <tr>
                    <td class="text-start ps-3">${item.fecha_formatted}</td>
                    <td class="fw-bold">${item.par_formatted}</td>
                    <td class="${claseTipo}">${item.tipo_formatted}</td>
                    <td>${item.cantidad_formatted}</td>
                    <td>${item.valor_total_formatted}</td>
                </tr>
            `;
            })
            .join('');

        tablaHistorial.html(historialHTML);
    },

    /**
     * Muestra un mensaje de error en un contenedor espec√≠fico de la UI.
     * @param {string} mensaje - El mensaje de error a mostrar.
     * @param {string} [containerSelector='#error-container'] - El selector del contenedor donde se mostrar√° el error.
     * @side-effects Modifica el `innerHTML` del contenedor de errores.
     */
    mostrarMensajeError(mensaje, containerSelector = '#error-container') {
        const errorContainer = $(containerSelector);
        if (!errorContainer.length) {
            console.error(`Error container '${containerSelector}' not found.`);
            return;
        }
        const alertHTML = `
            <div class="alert alert-danger alert-dismissible fade show" role="alert">
                ${mensaje}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        `;
        errorContainer.html(alertHTML);
    }
};


==================================================
=== ARCHIVO: ./frontend/static/js/pages/billeteraPage.js ===
==================================================

/**
 * @module pages/billeteraPage
 * @description Orquesta la inicializaci√≥n y la l√≥gica principal de la p√°gina de la billetera,
 * incluyendo la obtenci√≥n de datos y la renderizaci√≥n de la tabla de activos.
 */

import { fetchEstadoBilletera } from '../services/apiService.js';
import { UIUpdater } from '../components/uiUpdater.js';

/**
 * @typedef {object} Cripto
 * @property {string} ticker - El s√≠mbolo de la criptomoneda (ej. "BTC").
 * @property {boolean} es_polvo - Indica si la cantidad es considerada "polvo" (muy peque√±a).
 * @property {string} cantidad_formatted - La cantidad de la criptomoneda, formateada como string.
 * @property {string} precio_actual_formatted - El precio actual por unidad, formateado.
 * @property {string} valor_usdt_formatted - El valor total en USDT, formateado.
 * @property {string|number} ganancia_perdida - El valor num√©rico de la ganancia o p√©rdida.
 * @property {string} ganancia_perdida_formatted - La ganancia o p√©rdida, formateada.
 * @property {string} porcentaje_ganancia_formatted - El porcentaje de ganancia o p√©rdida, formateado.
 * @property {string} porcentaje_formatted - El porcentaje que este activo representa en la billetera, formateado.
 */

/**
 * Crea una fila HTML (`<tr>`) para la tabla de la billetera a partir de un objeto de criptomoneda.
 * @param {Cripto} cripto - El objeto que contiene los datos del activo.
 * @returns {string} Una cadena de texto con el HTML de la fila de la tabla.
 */
function createBilleteraRowHTML(cripto) {
    // Determina la clase CSS para el color basado en si la ganancia/p√©rdida es positiva o negativa.
    const colorGanancia = parseFloat(cripto.ganancia_perdida) >= 0 ? 'positivo' : 'negativo';
    
    // Utiliza directamente los campos con el sufijo `_formatted` que ya vienen preparados del backend.
    return `
        <tr>
            <td class="text-center">${cripto.ticker} ${cripto.es_polvo ? '<span class="text-muted small">(polvo)</span>' : ''}</td>
            <td class="text-center">${cripto.cantidad_formatted}</td>
            <td class="text-center">${cripto.precio_actual_formatted}</td>
            <td class="text-center">${cripto.valor_usdt_formatted}</td>
            <td class="text-center ${colorGanancia}">${cripto.ganancia_perdida_formatted}</td>
            <td class="text-center ${colorGanancia}">${cripto.porcentaje_ganancia_formatted}</td>
            <td class="text-center">${cripto.porcentaje_formatted}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de la billetera desde la API y los renderiza en la tabla del DOM.
 * Maneja los estados de carga, √©xito y error, actualizando la UI correspondientemente.
 * @async
 * @function renderBilletera
 */
async function renderBilletera() {
    const cuerpoTabla = document.getElementById('tabla-billetera');
    if (!cuerpoTabla) {
        console.warn("El elemento #tabla-billetera no fue encontrado en el DOM. No se renderizar√° la tabla.");
        return;
    }

    console.log("Cargando datos de la billetera...");
    try {
        const datosBilletera = await fetchEstadoBilletera();

        if (datosBilletera.length === 0) {
            cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-muted py-4">Tu billetera est√° vac√≠a.</td></tr>';
            return;
        }

        const tablaHTML = datosBilletera.map(createBilleteraRowHTML).join('');
        cuerpoTabla.innerHTML = tablaHTML;
        console.log("Billetera renderizada correctamente.");
    } catch (error) {
        console.error('Error al renderizar la billetera:', error);
        // Muestra un mensaje de error tanto en la consola como en la interfaz de usuario.
        UIUpdater.mostrarMensajeError('No se pudieron cargar los datos de la billetera. Por favor, intenta recargar la p√°gina.');
        cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-danger py-4">Error al cargar los datos.</td></tr>';
    }
}

/**
 * @description Listener que se ejecuta cuando el DOM est√° completamente cargado.
 * Inicia el proceso de renderizado de la billetera.
 * @event DOMContentLoaded
 */
document.addEventListener('DOMContentLoaded', renderBilletera);

==================================================
=== ARCHIVO: ./frontend/static/js/pages/indexPage.js ===
==================================================

/**
 * @module pages/indexPage
 * @description L√≥gica para la p√°gina principal de cotizaciones.
 * Se encarga de inicializar y gestionar la actualizaci√≥n peri√≥dica de la tabla de cotizaciones.
 */

import { triggerActualizacionDatos } from '../services/apiService.js';
import { renderTabla } from '../components/tablaCotizacionesUI.js';

/**
 * @const {number} UPDATE_INTERVAL_MS
 * @description Intervalo en milisegundos para la actualizaci√≥n autom√°tica de la tabla de cotizaciones.
 * @default 15000
 */
const UPDATE_INTERVAL_MS = 15000; // 15 segundos

/**
 * Orquesta el ciclo completo de actualizaci√≥n de datos y renderizado de la tabla.
 * Primero, solicita al backend que actualice sus datos desde la fuente externa.
 * Una vez completado, renderiza la tabla de cotizaciones con la informaci√≥n m√°s reciente.
 * @async
 * @function actualizarYRenderizar
 * @throws {Error} Si alguna de las operaciones (actualizaci√≥n o renderizado) falla.
 */
async function actualizarYRenderizar() {
    console.log("Iniciando ciclo de actualizaci√≥n de cotizaciones...");
    try {
        await triggerActualizacionDatos();
        await renderTabla();
        console.log("Tabla de cotizaciones actualizada exitosamente.");
    } catch (error) {
        console.error("Fall√≥ el ciclo de actualizaci√≥n de la tabla de cotizaciones:", error);
    }
}

/**
 * @description Listener que se ejecuta cuando el DOM est√° completamente cargado.
 * Verifica si la tabla de cotizaciones existe en la p√°gina actual y, si es as√≠,
 * inicia el ciclo de actualizaci√≥n inmediata y peri√≥dica.
 * @event DOMContentLoaded
 */
document.addEventListener('DOMContentLoaded', () => {
    // Asegurarse de que el script solo se ejecute en la p√°gina correcta.
    if (document.getElementById('tabla-datos')) {
        console.log("P√°gina de cotizaciones detectada. Iniciando actualizaciones.");
        
        // Ejecuta la actualizaci√≥n inmediatamente al cargar la p√°gina.
        actualizarYRenderizar();
        
        // Establece el intervalo para futuras actualizaciones autom√°ticas.
        setInterval(actualizarYRenderizar, UPDATE_INTERVAL_MS);
    }
});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/tradingPage.js ===
==================================================

/**
 * @module pages/tradingPage
 * @description Orquesta toda la l√≥gica de la p√°gina de trading. Se encarga de la inicializaci√≥n,
 * la gesti√≥n del estado, la interacci√≥n del usuario y la comunicaci√≥n con otros m√≥dulos
 * como el gr√°fico, el formulario y los servicios de API.
 */

import { DOMElements } from '../components/domElements.js';
import { UIState } from '../components/uiState.js';
import { UIUpdater } from '../components/uiUpdater.js';
import { FormLogic } from '../components/formLogic.js';
import { initializeChart, updateChartData } from '../components/chartRenderer.js';
import { fetchCotizaciones, fetchEstadoBilletera, fetchHistorial, fetchVelas } from '../services/apiService.js';

document.addEventListener('DOMContentLoaded', () => {
    /** @type {string} El ticker de la criptomoneda actualmente seleccionada en el gr√°fico. */
    let currentTicker = 'BTC';
    /** @type {string} La temporalidad (intervalo) actual del gr√°fico (ej. '1d', '1h'). */
    let currentInterval = '1d';
    /** @type {boolean} Bandera para prevenir cargas concurrentes de datos para el gr√°fico. */
    let isChartLoading = false;

    /**
     * Configura la interfaz de usuario para el modo de operaci√≥n especificado (compra o venta).
     * @param {'comprar' | 'vender'} mode - El modo de trading a activar.
     */
    function setTradeMode(mode) {
        DOMElements.inputAccion.val(mode);

        UIUpdater.actualizarBotones();
        UIUpdater.actualizarVisibilidadCampos();

        let tickerForBalance = '';
        if (UIState.esModoCompra()) {
            // En modo COMPRA, el selector principal muestra todas las criptos disponibles para comprar.
            const cryptosWithoutUSDT = window.allCryptos.filter(c => c.ticker !== 'USDT');
            FormLogic.popularSelector(DOMElements.selectorPrincipal, cryptosWithoutUSDT, 'BTC');
            // El saldo a mostrar es el de la moneda con la que se paga (ej. USDT).
            tickerForBalance = UIState.getTickerPago();
        } else {
            // En modo VENTA, el selector principal muestra solo las criptos que el usuario posee.
            if (!window.ownedCoins || window.ownedCoins.length === 0) {
                console.warn("No se encontraron monedas en propiedad para configurar el modo de venta.");
                tickerForBalance = null; // No se puede mostrar saldo si no hay monedas.
            } else {
                const defaultTicker = window.ownedCoins[0].ticker;
                tickerForBalance = FormLogic.popularSelector(DOMElements.selectorPrincipal, window.ownedCoins, defaultTicker);
            }
        }

        UIUpdater.mostrarSaldo(tickerForBalance);
        UIUpdater.actualizarLabelMonto();
        UIUpdater.resetSlider();
    }

    /**
     * Obtiene los datos de velas para un par y temporalidad espec√≠ficos y actualiza el gr√°fico.
     * Utiliza una bandera (`isChartLoading`) para evitar peticiones concurrentes.
     * @async
     * @param {string} ticker - El ticker de la criptomoneda (ej. 'BTC').
     * @param {string} interval - La temporalidad del gr√°fico (ej. '1d', '15m').
     */
    async function actualizarGrafico(ticker, interval) {
        if (isChartLoading) {
            console.log("Petici√≥n de actualizaci√≥n de gr√°fico ignorada: carga en curso.");
            return;
        }
        isChartLoading = true;
        console.log(`Solicitando datos de velas para ${ticker} en intervalo ${interval}...`);
        try {
            const nuevosDatosVelas = await fetchVelas(ticker, interval);
            updateChartData(nuevosDatosVelas);
        } catch (error) {
            console.error(`Error al actualizar el gr√°fico para ${ticker}/${interval}:`, error);
            updateChartData([]); // En caso de error, limpia el gr√°fico y muestra un mensaje.
        } finally {
            isChartLoading = false; // Restablece la bandera para permitir futuras peticiones.
        }
    }

    /**
     * Configura todos los manejadores de eventos para los elementos interactivos de la p√°gina.
     */
    function setupEventListeners() {
        DOMElements.botonComprar.on('click', () => setTradeMode('comprar'));
        DOMElements.botonVender.on('click', () => setTradeMode('vender'));

        DOMElements.selectorPrincipal.on('change', () => {
            currentTicker = UIState.getTickerPrincipal();
            UIUpdater.actualizarLabelMonto();
            if (!UIState.esModoCompra()) {
                UIUpdater.mostrarSaldo(currentTicker);
            }
            actualizarGrafico(currentTicker, currentInterval);
        });

        // Delega el evento de clic para los botones de temporalidad.
        $('#timeframe-selector').on('click', '.timeframe-btn', function() {
            const $btn = $(this);
            if ($btn.hasClass('active')) return;

            $('#timeframe-selector .timeframe-btn').removeClass('active');
            $btn.addClass('active');

            currentInterval = $btn.data('interval');
            actualizarGrafico(currentTicker, currentInterval);
        });

        DOMElements.selectorPagarCon.on('change', () => {
            UIUpdater.actualizarLabelMonto();
            if (UIState.esModoCompra()) UIUpdater.mostrarSaldo(UIState.getTickerPago());
        });

        DOMElements.selectorRecibirEn.on('change', UIUpdater.actualizarLabelMonto);
        DOMElements.radioModoIngreso.on('change', UIUpdater.actualizarLabelMonto);

        DOMElements.sliderMonto.on('input', () => {
            const calculatedValue = FormLogic.calcularMontoSlider();
            UIUpdater.setInputMonto(calculatedValue.toFixed(8));
        });
    }

    /**
     * Funci√≥n principal que inicializa la p√°gina de trading.
     * Carga datos cr√≠ticos en paralelo, renderiza componentes y configura los listeners.
     * @async
     */
    async function initialize() {
        console.log("Inicializando p√°gina de trading...");
        try {
            // Carga todos los datos necesarios de forma concurrente para optimizar el tiempo de carga.
            const [cotizaciones, estadoBilletera, historial, velas] = await Promise.all([
                fetchCotizaciones(),
                fetchEstadoBilletera(),
                fetchHistorial(),
                fetchVelas(currentTicker, currentInterval) // Carga inicial para BTC en 1D.
            ]);

            // Almacena los datos en el objeto `window` para acceso global dentro de la p√°gina.
            window.allCryptos = cotizaciones;
            window.ownedCoins = estadoBilletera.filter(moneda => parseFloat(moneda.cantidad) > 0);

            // Renderiza los componentes que dependen de los datos cargados.
            UIUpdater.renderHistorial(historial);
            initializeChart(velas);

            // Inicializa la biblioteca Select2 en los selectores para mejorar su apariencia y funcionalidad.
            [DOMElements.selectorPrincipal, DOMElements.selectorPagarCon, DOMElements.selectorRecibirEn].forEach(sel => {
                sel.select2({
                    width: '100%',
                    dropdownCssClass: 'text-dark',
                    theme: "bootstrap-5"
                });
            });

            // Popula los selectores con las opciones correspondientes.
            FormLogic.popularSelector(DOMElements.selectorPagarCon, window.ownedCoins, 'USDT');
            FormLogic.popularSelector(DOMElements.selectorRecibirEn, window.allCryptos, 'USDT');

            setupEventListeners();
            
            // Establece el estado inicial de la UI en modo 'comprar'.
            setTradeMode('comprar');
            
            // Marca visualmente la temporalidad '1d' como activa.
            $('#timeframe-selector .timeframe-btn[data-interval="1d"]').addClass('active');

            console.log("P√°gina de trading inicializada correctamente.");
        } catch (error) {
            console.error('Error fatal durante la inicializaci√≥n de la p√°gina de trading:', error);
            UIUpdater.mostrarMensajeError('No se pudieron cargar los datos esenciales. Por favor, recarga la p√°gina.');
        }
    }

    // Inicia todo el proceso de inicializaci√≥n.
    initialize();
});

==================================================
=== ARCHIVO: ./frontend/static/js/services/apiService.js ===
==================================================

/**
 * @module services/apiService
 * @description Centraliza todas las llamadas a la API del backend. Proporciona una funci√≥n
 * gen√©rica para las solicitudes y exporta funciones espec√≠ficas para cada endpoint, 
 * manejando errores de forma consistente.
 */

/**
 * Realiza una solicitud `fetch` a un endpoint de la API y maneja la respuesta.
 * @private
 * @async
 * @param {string} url - El endpoint de la API al que se va a llamar.
 * @param {RequestInit} [options={}] - Opciones para la solicitud `fetch` (m√©todo, headers, body, etc.).
 * @param {string} [errorMessage='Error en la solicitud a la API'] - Mensaje de error personalizado para lanzar si la respuesta no es `ok`.
 * @returns {Promise<any>} Una promesa que se resuelve con la respuesta JSON de la API.
 * @throws {Error} Lanza un error si la solicitud de red falla o si la respuesta del servidor no es exitosa (status no es 2xx).
 */
async function _fetchData(url, options = {}, errorMessage = 'Error en la solicitud a la API') {
    try {
        const response = await fetch(url, options);
        if (!response.ok) {
            // Si la respuesta del servidor no es exitosa, construye un error informativo.
            throw new Error(`${errorMessage} (status: ${response.status})`);
        }
        return await response.json();
    } catch (error) {
        console.error(`Error en la llamada a la API [${url}]:`, error);
        // Re-lanza el error para que el c√≥digo que invoca la funci√≥n pueda manejarlo (ej. en un Promise.all).
        throw error;
    }
}

/**
 * Obtiene la lista completa de cotizaciones de criptomonedas desde el backend.
 * @returns {Promise<Array<object>>} Una promesa que se resuelve con un array de objetos de cotizaci√≥n.
 */
export const fetchCotizaciones = () => 
    _fetchData('/api/cotizaciones', {}, 'No se pudieron cargar las cotizaciones');

/**
 * Obtiene el estado completo y formateado de la billetera del usuario.
 * @returns {Promise<Array<object>>} Una promesa que se resuelve con un array de objetos, donde cada objeto representa una moneda en la billetera.
 */
export const fetchEstadoBilletera = () => 
    _fetchData('/api/billetera/estado-completo', {}, 'No se pudo cargar el estado de la billetera');

/**
 * Obtiene el historial de transacciones del usuario.
 * @returns {Promise<Array<object>>} Una promesa que se resuelve con un array de objetos de transacciones.
 */
export const fetchHistorial = () => 
    _fetchData('/api/historial', {}, 'No se pudo cargar el historial de transacciones');

/**
 * Obtiene los datos de velas (candlestick) para un ticker y un intervalo de tiempo espec√≠ficos.
 * @param {string} ticker - El ticker de la criptomoneda (ej. 'BTC').
 * @param {string} interval - La temporalidad de las velas (ej. '1d', '1h', '15m').
 * @returns {Promise<Array<object>>} Una promesa que se resuelve con un array de datos de velas.
 */
export const fetchVelas = (ticker, interval) => 
    _fetchData(`/api/velas/${ticker}/${interval}`, {}, `No se pudieron cargar los datos de velas para ${ticker} (${interval})`);

/**
 * Env√≠a una solicitud al backend para que actualice los datos de cotizaciones desde la fuente externa.
 * @returns {Promise<object>} Una promesa que se resuelve con un mensaje de √©xito o estado de la actualizaci√≥n.
 */
export const triggerActualizacionDatos = () => 
    _fetchData('/api/actualizar', {}, 'La solicitud para actualizar los datos fall√≥');

==================================================
=== ARCHIVO: ./frontend/templates/billetera.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Billetera</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="bg-dark text-white">
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes de error -->
    <div id="error-container" class="container-fluid mt-3"></div>

    <main class="container my-4">
        <div class="text-center">
            <h2 class="text-warning mb-4">Billetera</h2>
        </div>

        <div class="table-responsive mt-4">
            <table class="table table-dark table-bordered align-middle text-center">
                <thead class="table-secondary">
                    <tr class="table-dark">
                        <th>Nombre</th>
                        <th>Cantidad</th>
                        <th>Precio Actual</th>
                        <th>Valor USD</th>
                        <th>G&P (USD)</th>
                        <th>G&P (%)</th>
                        <th>% Billetera</th>
                    </tr>
                </thead>
                <tbody id="tabla-billetera">
                    <!-- El contenido ser√° renderizado aqu√≠ por billeteraPage.js -->
                    <tr>
                        <td colspan="7" class="text-center text-muted py-4">Cargando billetera...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </main>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/billeteraPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/index.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BlocX</title>
	<link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
	<link rel="stylesheet" href="{{ url_for('static', filename='css/styles_index.css') }}">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
</head>

<body class="bg-dark text-white">


	<nav class="navbar navbar-expand-lg bg-black shadow">
		<div class="container-fluid">
			<a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
				<img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
				<span>BlocX</span>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
				<span class="navbar-toggler-icon bg-light"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarNav">
				<ul class="navbar-nav ms-auto">
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Contenedor para mensajes de error -->
	<div id="error-container" class="container-fluid mt-3"></div>

	<!-- Contenedor principal -->
	<main class="container-fluid mt-4">
		<div class="row">
			<div class="col-12">
				<div class="p-2 shadow text-center">
					<h3 class="text-warning">Cotizaciones</h3>
					<table class="table table-dark table-striped mt-4">
						<thead>
							<tr>
								<th class="text-start px-3">#</th>
								<th class="text-start px-3">Nombre</th>
								<th class="text-start px-3">Precio</th>
								<th class="text-end px-3">1h</th>
								<th class="text-end px-3">24h</th>
								<th class="text-end px-3">7d</th>
								<th class="text-end px-3">Cap. Mercado</th>
								<th class="text-end px-3">Volumen</th>
								<th class="text-end px-3">Suministro</th>
							</tr>
						</thead>
						<tbody id="tabla-datos" class="align-middle">
							<!-- Aqu√≠ se insertar√°n las filas con JS -->
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</main>

	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
	<script type="module" src="{{ url_for('static', filename='js/pages/indexPage.js') }}"></script>

</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/trading.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Trading</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/select2-bootstrap-5-theme@1.3.0/dist/select2-bootstrap-5-theme.min.css" />
</head>

<body class="bg-dark text-white">

    <!-- ========== BARRA DE NAVEGACI√ìN ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes de error globales -->
    <div id="error-container" class="container-fluid mt-3"></div>

    <!-- ========== CONTENIDO PRINCIPAL ========== -->
    <div class="container mt-5">
        <div class="row">
            <div class="col-md-7">
                <h3 class="text-light">Gr√°fico velas</h3>
                
                <!-- Grupo de botones para las temporalidades -->
                <div class="btn-group btn-group-sm mb-2" role="group" id="timeframe-selector">
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="5m">5m</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="15m">15m</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="1h">1h</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="4h">4h</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn active" data-interval="1d">1D</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="1w">1S</button>
                </div>

                <!-- Checkbox para el volumen -->
                <div class="form-check form-switch mb-2 d-inline-block ms-3">
                    <input class="form-check-input" type="checkbox" id="toggleVolume" checked>
                    <label class="form-check-label text-light" for="toggleVolume">Mostrar volumen</label>
                </div>

                <!-- Contenedor del gr√°fico con posicionamiento relativo -->
                <div class="py-3" style="position: relative;">
                    <!-- Overlay de error, inicialmente oculto -->
                    <div id="chart-error-overlay" class="chart-overlay" style="display: none;">
                        <span>No hay datos de gr√°fico disponibles para este par y temporalidad.</span>
                    </div>
                    <!-- Contenedor donde se renderiza el gr√°fico -->
                    <div id="chart"></div>
                </div>
            </div>

            <form class="col-md-5 p-3" id="formulario-trading" method="POST" action="{{ url_for('trading.procesar_trading_form') }}">
                <h2 class="text-warning">Trading</h2>
                <div class="row g-2 mb-3">
                    <div class="col-6">
                        <label for="cripto" class="form-label">Criptomoneda</label>
                        <select class="form-select" id="cripto" name="ticker" required></select>
                    </div>
                    <div class="col-6">
                        <div id="campo-pagar-con" style="display: none;">
                            <label for="moneda-pago" class="form-label">Pagar con</label>
                            <select class="form-select" id="moneda-pago" name="moneda-pago"></select>
                        </div>
                        <div id="campo-recibir-en" style="display: none;">
                            <label for="moneda-recibir" class="form-label">Recibir en</label>
                            <select class="form-select" id="moneda-recibir" name="moneda-recibir"></select>
                        </div>
                    </div>
                </div>
                <div class="btn-group mb-3 w-100" role="group" id="toggle-trade-type">
                    <input type="hidden" name="accion" id="accion" value="comprar">
                    <button type="button" class="btn w-50 btn-success active boton-comprar" data-action="comprar">Comprar</button>
                    <button type="button" class="btn w-50 btn-outline-secondary boton-vender" data-action="vender">Vender</button>
                </div>
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Tipo de orden</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-mercado" value="mercado" autocomplete="off" checked required>
                        <label class="btn btn-outline-primary rounded-start-pill" for="tipo-mercado">Mercado</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-limite" value="limite" autocomplete="off">
                        <label class="btn btn-outline-primary" for="tipo-limite">L√≠mite</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-stop-limit" value="stop-limit" autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="tipo-stop-limit">Stop-Limit</label>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Ingresar por</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-monto" value="monto" autocomplete="off" checked required>
                        <label class="btn btn-outline-primary rounded-start-pill" for="modo-monto">Cantidad (Cripto)</label>
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-total" value="total" autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="modo-total">Total (USD)</label>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="monto" class="form-label">Cantidad</label> <!-- Texto cambiado aqu√≠ tambi√©n para consistencia -->
                    <input type="number" class="form-control" id="monto" placeholder="0.00" name="monto" required min="0.00000001" step="any">
                </div>
                <div class="mb-3">
                    <input type="range" class="form-range" min="0" max="100" step="1" id="slider-monto" value="0" name="slider">
                    <div class="d-flex justify-content-between text-white-50 small">
                        <span>0%</span><span>25%</span><span>50%</span><span>75%</span><span>100%</span>
                    </div>
                </div>
                <div class="mb-3 text-end text-secondary">
                    <small>Disponible: <span id="saldo-disponible">--</span></small>
                </div>
                <button type="submit" class="btn w-100 btn-success boton-confirmar" id="boton-confirmar">CONFIRMAR</button>
            </form>
        </div>

        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">Historial de transacciones</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Cantidad</th>
                                <th>Valor Total</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-historial">
                            <tr><td colspan="5" class="text-center text-muted py-3">Cargando historial...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== SECCI√ìN SCRIPTS ===== -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/tradingPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./README.md ===
==================================================

# Simulador Exchange - **BlokX**

Este proyecto educativo fue desarrollado en el marco de la materia "Algoritmos y Estructuras de Datos I" de UADE, bajo la supervisi√≥n de la profesora Julia Monasterio.  
Su objetivo es aplicar los conocimientos de la c√°tedra simulando el funcionamiento b√°sico de un exchange de criptomonedas.  
El sistema permite a los usuarios operar con saldo ficticio utilizando datos reales de cotizaci√≥n obtenidos de CoinGecko y Binance.

## üéØ Objetivos del proyecto

- Familiarizar a los usuarios con el entorno de un exchange de criptomonedas.
- Simular operaciones de compra y venta mediante distintos tipos de √≥rdenes: Market, Limit y Stop-Loss.
- Calcular y visualizar ganancias, p√©rdidas y balances del portafolio.
- Almacenar toda la informaci√≥n de manera local utilizando archivos `.json`.
- Comprender la interacci√≥n entre frontend y backend mediante una arquitectura moderna (HTML, CSS, Flask y Python).

## ‚öôÔ∏è Funcionalidades

### Panel general de cotizaciones
- Visualizaci√≥n del top de criptomonedas con:
  - Nombre, ticker, precio, market cap, volumen, supply.
  - Variaci√≥n en 1h, 24h y 7 d√≠as.
- Actualizaci√≥n autom√°tica de precios cada 15 segundos.

### Panel de trading
En este panel se ver√°n tres secciones diferentes que contemplan lo necesario para ejecutar las ordenes de compra/venta.

#### Gr√°fico de velas japonesas
- Grafico en el cual se va a poder visualizar los diferentes pares de criptos usando Lightweight Charts (Libreria de JavaScript), en diferentes time frames: 1m, 5m, 15m, 1h, 4hs, 1d y 1w.

#### √ìrdenes
- Compra y venta de activos con √≥rdenes:
  - Market
  - Limit
  - Stop-loss
- Comisi√≥n fija del 0.5% por transacci√≥n.
- Validaciones de saldo y tenencias disponibles.

#### Historial
- Registro de todas las operaciones realizadas.
- Incluye tipo de orden, precio, cantidad, fecha y fee aplicado.
  
### Billetera
- Visualizaci√≥n de tenencias actuales:
  - Cantidad, precio promedio, valor actual, ganancia/p√©rdida por activo.
- Balance total del portafolio en USDT.

## üß† C√≥mo funciona el sistema

El sistema est√° dise√±ado bajo una arquitectura desacoplada que separa claramente las responsabilidades del backend y del frontend:

- **Backend (Python/Flask)**: Act√∫a como una API pura de JSON. Sus responsabilidades son:
    - **`rutas/`**: Define los endpoints de la API (`/api/...`) que exponen los datos y la l√≥gica de negocio en formato JSON. Tambi√©n sirve el contenedor HTML inicial de cada p√°gina.
    - **`servicios/`**: Contiene toda la l√≥gica de negocio (c√°lculos de billetera, procesamiento de √≥rdenes, formato de datos) y prepara los datos para ser enviados como JSON.
    - **`acceso_datos/`**: Gestiona la lectura y escritura de los archivos `.json` que act√∫an como base de datos.
    - **`utils/`**: Proporciona funciones de utilidad, como formateadores de datos que se aplican en el backend.

- **Frontend (JavaScript)**: Es un cliente din√°mico que consume la API del backend.
    - **Aut√≥nomo**: Cada p√°gina carga su propio HTML y luego utiliza JavaScript para buscar todos los datos que necesita de los endpoints `/api/...`.
    - **Renderizado en el cliente**: Todo el renderizado y la manipulaci√≥n del DOM (actualizaci√≥n de tablas, saldos, gr√°ficos) se realiza en el navegador, creando una experiencia de usuario fluida y r√°pida sin recargas de p√°gina.
    - **Estructura modular en `js/`**:
        - **`pages/`**: Contiene la l√≥gica de inicializaci√≥n y orquestaci√≥n para cada p√°gina principal (ej. `tradingPage.js`).
        - **`components/`**: M√≥dulos encargados de actualizar partes espec√≠ficas de la interfaz (ej. `uiUpdater.js`, `tablaCotizacionesUI.js`).
        - **`services/`**: Gestiona la comunicaci√≥n con la API del backend.

### Flujo desacoplado

1.  El usuario navega a una URL (ej. `/trading`).
2.  Flask sirve un archivo HTML m√≠nimo (`trading.html`) que act√∫a como un esqueleto.
3.  El archivo JavaScript asociado a esa p√°gina (`tradingPage.js`) se ejecuta.
4.  El script de JS realiza llamadas a los endpoints de la API del backend (`/api/cotizaciones`, `/api/historial`, etc.) para obtener los datos en formato JSON.
5.  Una vez recibidos los datos, JavaScript actualiza din√°micamente el DOM para mostrar la informaci√≥n al usuario.

## üóÉÔ∏è Estructura del proyecto

```
simulador_exchange/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ app.py                      # Servidor Flask y punto de entrada
‚îÇ   ‚îú‚îÄ‚îÄ config.py                   # Configuraci√≥n del sistema y constantes globales
‚îÇ   ‚îú‚îÄ‚îÄ rutas/                      # Blueprints que definen las vistas y API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trading_vista.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ billetera_vista.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api_cotizaciones_vista.py
‚îÇ   ‚îú‚îÄ‚îÄ servicios/                  # L√≥gica de negocio de cada m√≥dulo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_cotizaciones.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ estado_billetera.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ velas_logica.py
‚îÇ   ‚îú‚îÄ‚îÄ acceso_datos/               # Acceso y manipulaci√≥n de archivos .json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ datos_billetera.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ datos_cotizaciones.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ datos_historial.py
‚îÇ   ‚îî‚îÄ‚îÄ utils/                      # Utilidades auxiliares
‚îÇ       ‚îî‚îÄ‚îÄ formatters.py
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ templates/                  # Plantillas HTML (contenedores iniciales)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ billetera.html
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trading.html
‚îÇ   ‚îî‚îÄ‚îÄ static/                     # Archivos est√°ticos
‚îÇ       ‚îú‚îÄ‚îÄ css/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ styles_index.css
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ styles_trading.css
‚îÇ       ‚îú‚îÄ‚îÄ img/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ logo_BlocX.png
‚îÇ       ‚îî‚îÄ‚îÄ js/                     # L√≥gica del cliente
‚îÇ           ‚îú‚îÄ‚îÄ components/         # M√≥dulos para actualizar la UI
‚îÇ           ‚îú‚îÄ‚îÄ pages/              # Scripts de orquestaci√≥n por p√°gina
‚îÇ           ‚îî‚îÄ‚îÄ services/           # Servicios de comunicaci√≥n con la API
‚îÇ
‚îú‚îÄ‚îÄ datos/                          # Archivos de persistencia
‚îÇ   ‚îú‚îÄ‚îÄ billetera.json
‚îÇ   ‚îú‚îÄ‚îÄ datos_cotizaciones.json
‚îÇ   ‚îú‚îÄ‚îÄ datos_velas.json
‚îÇ   ‚îî‚îÄ‚îÄ historial_operaciones.json
‚îÇ
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ README.md
```

## üöÄ C√≥mo ejecutar el proyecto

### 1. Crear entorno virtual (recomendado)
```bash
python3 -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

### 2. Instalar dependencias
```bash
pip install -r requirements.txt
```

### 3. Iniciar la app
```bash
python3 app.py
```

Y luego acceder desde el navegador a:  
```
http://localhost:5000
```

## üì¶ Tecnolog√≠as utilizadas

- Python 3.13
- Flask
- HTML, CSS, JavaScript
- Lightweight Charts (TradingView)

## üìå Notas

- Todos los datos se almacenan localmente en formato JSON.
- No se requiere conexi√≥n a bases de datos externas.
- El sistema est√° pensado para ser did√°ctico y extensible.

---

**Grupo 12**  
Fausto Lovera ‚Äî Patricio Menta ‚Äî Andrei Veis


==================================================
=== ARCHIVO: ./requirements.txt ===
==================================================

Flask==3.1.0
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
requests==2.32.3
Werkzeug==3.1.3



==================================================
=== FIN DEL REPORTE ===
==================================================
