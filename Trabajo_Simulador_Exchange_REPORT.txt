==================================================
=== REPORTE DE CÓDIGO CONSOLIDADO ===
Proyecto: Trabajo_Simulador_Exchange
Ruta: /Users/andreiveis/UADE/2do cuatrimestre/05_Algoritmos y Estructura de datos I/Trabajo_Simulador_Exchange
Generado el: Tue Jul  1 21:20:10 -03 2025
==================================================

--- INFORMACIÓN DEL REPOSITORIO GIT ---
Rama actual: fix_codigo
Último commit: 07e451f - Mejora en la visualizacion de los numeros con los decimales y las comas (andreiveisuade, 5 days ago)
---

--- ESTRUCTURA DEL DIRECTORIO ---
.
├── .env
├── .gitignore
├── .pytest_cache
│   ├── .gitignore
│   ├── CACHEDIR.TAG
│   ├── README.md
│   └── v
│       └── cache
│           ├── lastfailed
│           ├── nodeids
│           └── stepwise
├── backend
│   ├── __init__.py
│   ├── acceso_datos
│   │   ├── datos_billetera.py
│   │   ├── datos_comisiones.py
│   │   ├── datos_cotizaciones.py
│   │   ├── datos_historial.py
│   │   └── datos_ordenes.py
│   ├── app.py
│   ├── rutas
│   │   ├── __init__.py
│   │   ├── api_externa.py
│   │   ├── billetera_vista.py
│   │   ├── home.py
│   │   └── trading_vista.py
│   ├── servicios
│   │   ├── __init__.py
│   │   ├── api_cotizaciones.py
│   │   ├── estado_billetera.py
│   │   ├── presentacion_datos.py
│   │   └── trading
│   │       ├── __init__.py
│   │       ├── ejecutar_orden.py
│   │       ├── gestor.py
│   │       ├── motor.py
│   │       └── procesador.py
│   └── utils
│       ├── formatters.py
│       ├── responses.py
│       └── utilidades_numericas.py
├── config.py
├── documentacion.md
├── frontend
│   ├── static
│   │   ├── css
│   │   │   ├── styles_index.css
│   │   │   └── styles_trading.css
│   │   ├── img
│   │   └── js
│   │       ├── components
│   │       │   ├── chartRenderer.js
│   │       │   ├── domElements.js
│   │       │   ├── formLogic.js
│   │       │   ├── tablaCotizacionesUI.js
│   │       │   ├── uiManager.js
│   │       │   ├── uiState.js
│   │       │   └── uiUpdater.js
│   │       ├── pages
│   │       │   ├── billeteraPage.js
│   │       │   ├── indexPage.js
│   │       │   └── tradingPage.js
│   │       ├── services
│   │       │   ├── apiService.js
│   │       │   ├── appDataManager.js
│   │       │   ├── appState.js
│   │       │   └── statePersistence.js
│   │       └── utils
│   │           └── sweetalert-init.js
│   └── templates
│       ├── _flashes.html
│       ├── billetera.html
│       ├── index.html
│       └── trading.html
├── pytest.ini
├── README.md
├── requirements.txt
├── run.py
└── tests
    ├── __init__.py
    ├── conftest.py
    ├── test_datos_cotizaciones.py
    ├── test_ejecutar_orden.py
    ├── test_estado_billetera.py
    ├── test_trading_gestor.py
    ├── test_trading_motor.py
    ├── test_trading_procesador.py
    └── test_utilidades_numericas.py

21 directories, 68 files
---

==================================================
=== ARCHIVO: ./.env ===
==================================================

# Clave secreta para sesiones de Flask. ¡NO COMPARTIR!
FLASK_SECRET_KEY='f9ce7ff641c611e7e519d1551ccdfd699929967d87528324'


==================================================
=== ARCHIVO: ./.gitignore ===
==================================================

# ARCHIVOS PROPIOS NUESTROS
/datos/
/datos/datos_cotizaciones.json
/datos/datos_velas.json
/datos/billetera.json
/datos/historial_operaciones.json
/datos/ordenes_pendientes.json
Trabajo_Simulador_Exchange_REPORT.txt

# Python
__pycache__/
backend/__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.env
.venv
env/
venv/
ENV/
.pytest_cache/
.coverage
coverage.xml
*.cover
.hypothesis/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
__MACOSX/

# IDEs and editors
.idea/
.vscode/
*.swp
*.swo
.project
.classpath
*.sublime-workspace
*.sublime-project

# Frontend
node_modules/
/dist
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env.local
.env.*.local
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
*.sqlite
*.sqlite3
*.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Backup files
*.bak
*.backup
*~

# Environment variables
.env
.env.*
!.env.example

# System Files
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
datos/billetera.json
datos/datos_cotizaciones.json
datos/datos_velas.json
*.pyc
# D2 files
*.d2
diagrama.png


==================================================
=== ARCHIVO: ./.pytest_cache/.gitignore ===
==================================================

# Created by pytest automatically.
*


==================================================
=== ARCHIVO: ./.pytest_cache/CACHEDIR.TAG ===
==================================================

Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html


==================================================
=== ARCHIVO: ./.pytest_cache/README.md ===
==================================================

# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


==================================================
=== ARCHIVO: ./.pytest_cache/v/cache/lastfailed ===
==================================================

{
  "tests/test_estado_billetera.py::test_estado_actual_completo": true,
  "tests/test_trading_logica.py::test_compra_ingresando_monto_cripto": true,
  "tests/test_trading_logica.py::test_compra_ingresando_total_fiat": true,
  "tests/test_trading_logica.py::test_venta_ingresando_monto_cripto": true,
  "tests/test_trading_logica.py::test_calculo_con_monto_cero": true,
  "tests/test_trading_logica.py::test_calculo_con_precio_destino_cero": true,
  "tests/test_trading_logica.py::test_falla_al_vender_en_modo_total": true,
  "tests/test_trading_logica.py::test_ejecutar_orden_mercado_compra_exitosa": true,
  "tests/test_trading_logica.py::test_ejecutar_orden_mercado_falla_ejecucion": true,
  "tests/test_trading_logica.py::test_crear_orden_compra_limite_modo_total_exitosa": true,
  "tests/test_trading_logica.py::test_crear_orden_venta_limite_exitosa": true,
  "tests/test_trading_motor.py::test_ejecutar_orden_limite_simple": true,
  "tests/test_trading_procesador.py::test_calcular_detalles_intercambio_exitoso[kwargs0-expected0]": true,
  "tests/test_trading_procesador.py::test_calcular_detalles_intercambio_exitoso[kwargs1-expected1]": true,
  "tests/test_trading_procesador.py::test_calcular_detalles_intercambio_exitoso[kwargs2-expected2]": true,
  "tests/test_trading_procesador.py::test_ejecutar_orden_mercado_llama_a_transaccion_con_datos_correctos": true,
  "tests/test_trading_procesador.py::test_crear_orden_limite_reserva_fondos_correctamente": true,
  "tests/test_trading_procesador.py::test_crear_orden_venta_limite_modo_monto": true,
  "tests/test_trading_procesador.py::test_crear_orden_compra_limite_modo_monto": true,
  "tests/test_trading_procesador.py::test_crear_orden_compra_stop_limit": true,
  "tests/test_trading_procesador.py::test_crear_orden_venta_stop_limit": true,
  "tests/test_trading_procesador.py::test_crear_orden_venta_falla_en_modo_total": true,
  "tests/test_trading_motor.py::test_motor_ejecuta_orden_favorable": true,
  "tests/test_trading_motor.py::test_motor_maneja_lista_mixta_de_ordenes": true,
  "tests/test_trading_procesador.py::test_crear_orden_venta_limite_modo_total": true,
  "tests/test_datos_cotizaciones.py::test_guardar_y_cargar_datos_cotizaciones_con_ruta_temporal": true,
  "tests/test_datos_cotizaciones.py::test_cargar_datos_cotizaciones_archivo_no_existente": true,
  "tests/test_datos_cotizaciones.py::test_guardar_en_ruta_temporal_no_afecta_cache_global": true,
  "tests/test_ejecutar_orden.py::test_ejecucion_exitosa_orden_mercado": true,
  "tests/test_trading_gestor.py::test_cancelacion_exitosa_con_archivos": true,
  "tests/test_trading_motor.py::test_verificar_condicion_orden[compra-limit-40000-39000-True]": true,
  "tests/test_trading_motor.py::test_verificar_condicion_orden[venta-limit-60000-61000-True]": true,
  "tests/test_trading_motor.py::test_verificar_condicion_orden[compra-stop-limit-55000-56000-True]": true,
  "tests/test_trading_motor.py::test_verificar_condicion_orden[venta-stop-limit-45000-44000-True]": true,
  "tests/test_trading_motor.py::test_motor_ejecuta_orden_favorable_con_archivos": true,
  "tests/test_estado_billetera.py::test_estado_actual_completo_con_archivos_temporales": true,
  "tests/test_estado_billetera.py::test_obtener_historial_formateado_con_archivo_temporal": true,
  "tests/test_trading_gestor.py::test_cancelar_orden_inexistente": true
}

==================================================
=== ARCHIVO: ./.pytest_cache/v/cache/nodeids ===
==================================================

[
  "tests/test_datos_cotizaciones.py::test_cargar_datos_cotizaciones_archivo_no_existente",
  "tests/test_datos_cotizaciones.py::test_guardar_datos_actualiza_cache_correctamente",
  "tests/test_datos_cotizaciones.py::test_guardar_en_ruta_temporal_no_afecta_cache_global",
  "tests/test_datos_cotizaciones.py::test_guardar_y_cargar_datos_cotizaciones_con_ruta_temporal",
  "tests/test_ejecutar_orden.py::test_crear_activo_si_no_existe",
  "tests/test_ejecutar_orden.py::test_ejecucion_exitosa_orden_mercado",
  "tests/test_ejecutar_orden.py::test_ejecucion_exitosa_orden_pendiente",
  "tests/test_estado_billetera.py::test_calcular_metricas_activo",
  "tests/test_estado_billetera.py::test_estado_actual_completo",
  "tests/test_estado_billetera.py::test_estado_actual_completo_con_archivos_temporales",
  "tests/test_estado_billetera.py::test_obtener_historial_formateado_con_archivo_temporal",
  "tests/test_estado_billetera.py::test_preparar_datos_compra_agrupa_multiples_compras",
  "tests/test_estado_billetera.py::test_preparar_datos_compra_mixto",
  "tests/test_estado_billetera.py::test_preparar_datos_compra_sin_compras",
  "tests/test_estado_billetera.py::test_preparar_datos_compra_vacio",
  "tests/test_trading_gestor.py::test_cancelacion_exitosa",
  "tests/test_trading_gestor.py::test_cancelacion_exitosa_con_archivos",
  "tests/test_trading_gestor.py::test_cancelar_con_error_consistencia",
  "tests/test_trading_gestor.py::test_cancelar_orden_inexistente",
  "tests/test_trading_gestor.py::test_cancelar_orden_no_pendiente",
  "tests/test_trading_logica.py::test_calculo_con_monto_cero",
  "tests/test_trading_logica.py::test_calculo_con_precio_destino_cero",
  "tests/test_trading_logica.py::test_compra_ingresando_monto_cripto",
  "tests/test_trading_logica.py::test_compra_ingresando_total_fiat",
  "tests/test_trading_logica.py::test_crear_orden_compra_limite_modo_total_exitosa",
  "tests/test_trading_logica.py::test_crear_orden_falla_por_saldo_insuficiente",
  "tests/test_trading_logica.py::test_crear_orden_venta_limite_exitosa",
  "tests/test_trading_logica.py::test_ejecutar_orden_mercado_compra_exitosa",
  "tests/test_trading_logica.py::test_ejecutar_orden_mercado_falla_ejecucion",
  "tests/test_trading_logica.py::test_ejecutar_orden_mercado_falla_validacion_saldo",
  "tests/test_trading_logica.py::test_falla_al_vender_en_modo_total",
  "tests/test_trading_logica.py::test_falla_con_accion_desconocida",
  "tests/test_trading_logica.py::test_validar_saldo_insuficiente",
  "tests/test_trading_logica.py::test_validar_saldo_moneda_inexistente",
  "tests/test_trading_logica.py::test_validar_saldo_suficiente",
  "tests/test_trading_logica.py::test_venta_ingresando_monto_cripto",
  "tests/test_trading_motor.py::test_ejecutar_orden_con_datos_erroneos",
  "tests/test_trading_motor.py::test_ejecutar_orden_limite_simple",
  "tests/test_trading_motor.py::test_ejecutar_stop_limit_con_precio_favorable",
  "tests/test_trading_motor.py::test_motor_ejecuta_orden_favorable",
  "tests/test_trading_motor.py::test_motor_ejecuta_orden_favorable_con_archivos",
  "tests/test_trading_motor.py::test_motor_maneja_error_de_precio",
  "tests/test_trading_motor.py::test_motor_maneja_lista_mixta_de_ordenes",
  "tests/test_trading_motor.py::test_motor_no_ejecuta_orden_desfavorable",
  "tests/test_trading_motor.py::test_motor_no_hace_nada_sin_ordenes_pendientes",
  "tests/test_trading_motor.py::test_no_ejecutar_stop_limit_con_precio_desfavorable",
  "tests/test_trading_motor.py::test_verificar_compra_limite[precio_mercado0-True]",
  "tests/test_trading_motor.py::test_verificar_compra_limite[precio_mercado1-True]",
  "tests/test_trading_motor.py::test_verificar_compra_limite[precio_mercado2-False]",
  "tests/test_trading_motor.py::test_verificar_compra_stop_limit[precio_mercado0-True]",
  "tests/test_trading_motor.py::test_verificar_compra_stop_limit[precio_mercado1-True]",
  "tests/test_trading_motor.py::test_verificar_compra_stop_limit[precio_mercado2-False]",
  "tests/test_trading_motor.py::test_verificar_condicion_orden[compra-limit-40000-39000-True]",
  "tests/test_trading_motor.py::test_verificar_condicion_orden[compra-limit-40000-40001-False]",
  "tests/test_trading_motor.py::test_verificar_condicion_orden[compra-stop-limit-55000-54999-False]",
  "tests/test_trading_motor.py::test_verificar_condicion_orden[compra-stop-limit-55000-56000-True]",
  "tests/test_trading_motor.py::test_verificar_condicion_orden[venta-limit-60000-59999-False]",
  "tests/test_trading_motor.py::test_verificar_condicion_orden[venta-limit-60000-61000-True]",
  "tests/test_trading_motor.py::test_verificar_condicion_orden[venta-stop-limit-45000-44000-True]",
  "tests/test_trading_motor.py::test_verificar_condicion_orden[venta-stop-limit-45000-45001-False]",
  "tests/test_trading_motor.py::test_verificar_venta_limite[precio_mercado0-True]",
  "tests/test_trading_motor.py::test_verificar_venta_limite[precio_mercado1-True]",
  "tests/test_trading_motor.py::test_verificar_venta_limite[precio_mercado2-False]",
  "tests/test_trading_motor.py::test_verificar_venta_stop_limit[precio_mercado0-True]",
  "tests/test_trading_motor.py::test_verificar_venta_stop_limit[precio_mercado1-True]",
  "tests/test_trading_motor.py::test_verificar_venta_stop_limit[precio_mercado2-False]",
  "tests/test_trading_procesador.py::test_calcular_detalles_intercambio_exitoso[kwargs0-expected0]",
  "tests/test_trading_procesador.py::test_calcular_detalles_intercambio_exitoso[kwargs1-expected1]",
  "tests/test_trading_procesador.py::test_calcular_detalles_intercambio_exitoso[kwargs2-expected2]",
  "tests/test_trading_procesador.py::test_crear_orden_compra_limite_modo_monto",
  "tests/test_trading_procesador.py::test_crear_orden_compra_stop_limit",
  "tests/test_trading_procesador.py::test_crear_orden_falla_por_saldo_insuficiente",
  "tests/test_trading_procesador.py::test_crear_orden_limite_reserva_fondos_correctamente",
  "tests/test_trading_procesador.py::test_crear_orden_venta_falla_en_modo_total",
  "tests/test_trading_procesador.py::test_crear_orden_venta_limite_modo_monto",
  "tests/test_trading_procesador.py::test_crear_orden_venta_stop_limit",
  "tests/test_trading_procesador.py::test_ejecutar_orden_mercado_falla_si_no_hay_precio",
  "tests/test_trading_procesador.py::test_ejecutar_orden_mercado_llama_a_transaccion_con_datos_correctos",
  "tests/test_trading_procesador.py::test_validar_saldo_insuficiente",
  "tests/test_trading_procesador.py::test_validar_saldo_suficiente",
  "tests/test_utilidades_numericas.py::test_a_decimal_float",
  "tests/test_utilidades_numericas.py::test_a_decimal_int",
  "tests/test_utilidades_numericas.py::test_a_decimal_invalid_str",
  "tests/test_utilidades_numericas.py::test_a_decimal_none",
  "tests/test_utilidades_numericas.py::test_a_decimal_str",
  "tests/test_utilidades_numericas.py::test_cuantizar_cripto_redondeo",
  "tests/test_utilidades_numericas.py::test_cuantizar_usd_redondeo",
  "tests/test_utilidades_numericas.py::test_formato_cantidad_cripto_decimales",
  "tests/test_utilidades_numericas.py::test_formato_cantidad_cripto_elimina_ceros",
  "tests/test_utilidades_numericas.py::test_formato_cantidad_cripto_entero",
  "tests/test_utilidades_numericas.py::test_formato_cantidad_usd_basico",
  "tests/test_utilidades_numericas.py::test_formato_cantidad_usd_elimina_ceros",
  "tests/test_utilidades_numericas.py::test_formato_numero_grande_billones",
  "tests/test_utilidades_numericas.py::test_formato_numero_grande_menor_millon",
  "tests/test_utilidades_numericas.py::test_formato_numero_grande_millon"
]

==================================================
=== ARCHIVO: ./.pytest_cache/v/cache/stepwise ===
==================================================

[]

==================================================
=== ARCHIVO: ./backend/__init__.py ===
==================================================

"""
Paquete principal del backend de la aplicación.

Este archivo `__init__.py` no solo marca el directorio `backend` como un paquete de
Python, sino que también contiene la "Application Factory" `crear_app`.
Este patrón es una buena práctica en Flask que permite crear múltiples instancias
de la aplicación con diferentes configuraciones, facilitando las pruebas y la
escalabilidad.
"""

from flask import Flask
from config import FLASK_SECRET_KEY
from backend.rutas import registrar_rutas

def crear_app() -> Flask:
    """
    Crea, configura y devuelve una instancia de la aplicación Flask.

    Esta función sigue el patrón de diseño "Application Factory". Se encarga de:
    1. Crear la instancia de la aplicación Flask.
    2. Configurar la ubicación de las carpetas de plantillas y archivos estáticos.
    3. Establecer la clave secreta para la gestión de sesiones y mensajes flash.
    4. Registrar todos los blueprints (conjuntos de rutas) de la aplicación.

    Returns:
        Flask: La instancia de la aplicación Flask configurada y lista para usarse.
    """
    app = Flask(
        __name__,
        static_folder="../frontend/static",
        template_folder="../frontend/templates",
    )

    app.secret_key = FLASK_SECRET_KEY

    registrar_rutas(app)

    return app

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_billetera.py ===
==================================================

# backend/acceso_datos/datos_billetera.py
### MODIFICADO Y SIMPLIFICADO ###

import json
import os
from decimal import Decimal
from typing import Optional

from backend.utils.utilidades_numericas import a_decimal, cuantizar_cripto
from config import BILLETERA_PATH, BALANCE_INICIAL_USDT

def _crear_billetera_inicial() -> dict:
    """Crea el objeto de billetera inicial con la nueva estructura."""
    return {
        "USDT": {
            "nombre": "Tether",
            "saldos": {
                "disponible": a_decimal(BALANCE_INICIAL_USDT),
                "reservado": a_decimal("0")
            }
        }
    }

def cargar_billetera(ruta_archivo: Optional[str] = None) -> dict[str, dict]:
    """
    Carga la billetera de criptomonedas desde un archivo JSON.
    Si no se provee una ruta, usa la ruta por defecto de la configuración.
    """
    ruta_efectiva = ruta_archivo if ruta_archivo is not None else BILLETERA_PATH
    os.makedirs(os.path.dirname(ruta_efectiva), exist_ok=True)

    if not os.path.exists(ruta_efectiva) or os.path.getsize(ruta_efectiva) == 0:
        billetera_inicial = _crear_billetera_inicial()
        guardar_billetera(billetera_inicial, ruta_archivo=ruta_efectiva)
        return billetera_inicial

    try:
        with open(ruta_efectiva, "r", encoding="utf-8") as f:
            datos_cargados = json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(f"Advertencia: Archivo '{ruta_efectiva}' corrupto. Se reiniciará la billetera.")
        billetera_inicial = _crear_billetera_inicial()
        guardar_billetera(billetera_inicial, ruta_archivo=ruta_efectiva)
        return billetera_inicial

    billetera_final = {}
    for ticker, activo in datos_cargados.items():
        billetera_final[ticker] = {
            "nombre": activo.get("nombre", ticker),
            "saldos": {
                "disponible": a_decimal(activo["saldos"].get("disponible", "0")),
                "reservado": a_decimal(activo["saldos"].get("reservado", "0"))
            }
        }
    return billetera_final

def guardar_billetera(billetera: dict[str, dict], ruta_archivo: Optional[str] = None):
    """
    Guarda el estado actual de la billetera en un archivo JSON.
    Si no se provee una ruta, usa la ruta por defecto de la configuración.
    """
    ruta_efectiva = ruta_archivo if ruta_archivo is not None else BILLETERA_PATH
    os.makedirs(os.path.dirname(ruta_efectiva), exist_ok=True)

    datos_para_json = {}
    for ticker, activo in billetera.items():
        saldos = activo.get("saldos", {})
        
        saldo_disponible = saldos.get("disponible", a_decimal(0))
        saldo_reservado = saldos.get("reservado", a_decimal(0))
        
        saldo_disponible_q = cuantizar_cripto(saldo_disponible)
        saldo_reservado_q = cuantizar_cripto(saldo_reservado)
        
        str_disponible = "0.00000000" if saldo_disponible_q.is_zero() else str(saldo_disponible_q)
        str_reservado = "0.00000000" if saldo_reservado_q.is_zero() else str(saldo_reservado_q)
        
        datos_para_json[ticker] = {
            "nombre": activo.get("nombre", ticker),
            "saldos": {
                "disponible": str_disponible,
                "reservado": str_reservado,
            }
        }

    with open(ruta_efectiva, "w", encoding="utf-8") as f:
        json.dump(datos_para_json, f, indent=4)

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_comisiones.py ===
==================================================

# backend/acceso_datos/datos_comisiones.py
### MODIFICADO ###

import json
import os
from datetime import datetime
from decimal import Decimal
from typing import Optional

from backend.utils.utilidades_numericas import cuantizar_cripto, cuantizar_usd
from config import COMISIONES_PATH

def cargar_comisiones(ruta_archivo: Optional[str] = None) -> list:
    """Carga el historial de comisiones desde el archivo JSON."""
    ruta_efectiva = ruta_archivo if ruta_archivo is not None else COMISIONES_PATH
    if not os.path.exists(ruta_efectiva) or os.path.getsize(ruta_efectiva) == 0:
        return []
    try:
        with open(ruta_efectiva, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(f"Advertencia: No se pudo leer o el archivo '{ruta_efectiva}' está corrupto.")
        return []

def registrar_comision(
    ticker_comision: str,
    cantidad_comision: Decimal,
    valor_usd_comision: Decimal,
    ruta_archivo: Optional[str] = None
):
    """
    Guarda un nuevo registro de comisión usando las utilidades de cuantización.
    """
    ruta_efectiva = ruta_archivo if ruta_archivo is not None else COMISIONES_PATH
    os.makedirs(os.path.dirname(ruta_efectiva), exist_ok=True)
    comisiones = cargar_comisiones(ruta_archivo=ruta_efectiva)

    cantidad_comision_q = cuantizar_cripto(cantidad_comision)
    valor_usd_comision_q = cuantizar_usd(valor_usd_comision)

    nueva_comision = {
        "id": len(comisiones) + 1,
        "timestamp": datetime.now().isoformat(),
        "ticker": ticker_comision,
        "cantidad": str(cantidad_comision_q),
        "valor_usd": str(valor_usd_comision_q),
    }
    
    print(
        f"💰 COMISIÓN REGISTRADA: "
        f"{nueva_comision['cantidad']} {nueva_comision['ticker']} "
        f"(valor: ${nueva_comision['valor_usd']})"
    )

    comisiones.insert(0, nueva_comision)

    with open(ruta_efectiva, "w", encoding="utf-8") as f:
        json.dump(comisiones, f, indent=4)

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_cotizaciones.py ===
==================================================

"""
Módulo de acceso a datos de cotizaciones.

Este módulo utiliza un diccionario a nivel de módulo como caché de precios para
mayor simplicidad y claridad. El caché se carga bajo demanda.

Expone públicamente:
- obtener_precio(ticker): Obtiene el precio de una cripto, usando el caché.
- recargar_cache_precios(): Fuerza la recarga del caché desde el archivo.
- cargar_datos_cotizaciones(): Carga la lista de cotizaciones desde el archivo.
- guardar_datos_cotizaciones(data): Guarda las cotizaciones y actualiza el caché.
"""

import json
import os
from decimal import Decimal
from typing import Any

from config import COTIZACIONES_PATH

# El caché es ahora un diccionario explícito a nivel de módulo.
_cache_precios: dict[str, Decimal] = {}

def recargar_cache_precios(ruta_archivo=COTIZACIONES_PATH):
    """
    Lee el archivo JSON y puebla el caché de precios.
    Esta función ahora es pública y puede ser llamada desde los tests para
    inyectar diferentes fuentes de datos.
    """
    global _cache_precios
    print(f"🔄 Recargando caché de precios desde '{ruta_archivo}'...")

    if not os.path.exists(ruta_archivo) or os.path.getsize(ruta_archivo) == 0:
        lista_criptos = []
    else:
        try:
            with open(ruta_archivo, "r", encoding="utf-8") as f:
                lista_criptos = json.load(f)
        except (json.JSONDecodeError, FileNotFoundError):
            print(f"⚠️ No se pudo leer el archivo de cotizaciones en '{ruta_archivo}'. Se usará una lista vacía.")
            lista_criptos = []

    _cache_precios = {
        cripto.get("ticker", "").upper(): Decimal(str(cripto.get("precio_usd", "0")))
        for cripto in lista_criptos
        if cripto.get("ticker")  # Asegurarse de que el ticker no sea None o vacío
    }
    print("✅ Caché de precios actualizado en memoria.")

def obtener_precio(ticker: str) -> Decimal | None:
    """
    Obtiene el precio desde el caché. Si está vacío, lo carga primero.
    """
    if not _cache_precios:
        recargar_cache_precios()
    
    return _cache_precios.get(ticker.upper())

def cargar_datos_cotizaciones(ruta_archivo=COTIZACIONES_PATH) -> list[dict]:
    """
    Carga la lista completa de cotizaciones desde el archivo.
    Esto es necesario para el módulo de presentación que formatea todos los datos.
    """
    if not os.path.exists(ruta_archivo) or os.path.getsize(ruta_archivo) == 0:
        return []
    try:
        with open(ruta_archivo, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return []

def guardar_datos_cotizaciones(data: list[dict[str, Any]], ruta_archivo=COTIZACIONES_PATH):
    """
    Guarda los datos de cotizaciones en el archivo.
    Después de guardar, fuerza automáticamente la recarga del caché en memoria si
    la ruta de guardado es la misma que la de configuración principal.
    """
    os.makedirs(os.path.dirname(ruta_archivo), exist_ok=True)
    print(f"💾 Guardando datos en '{ruta_archivo}'...")
    try:
        with open(ruta_archivo, "w", encoding="utf-8") as archivo:
            json.dump(data, archivo, indent=4)
        print("✅ Datos de cotizaciones guardados en archivo.")
        
        # Si la ruta guardada es la misma que la de configuración, recargamos el caché global.
        if ruta_archivo == COTIZACIONES_PATH:
            recargar_cache_precios()
            
    except (IOError, TypeError) as e:
        print(f"❌ Error al guardar el archivo de cotizaciones: {e}")

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_historial.py ===
==================================================

# backend/acceso_datos/datos_historial.py
### MODIFICADO ###

import json
import os
from datetime import datetime
from decimal import Decimal
from typing import Optional

from backend.utils.utilidades_numericas import cuantizar_cripto, cuantizar_usd
from config import HISTORIAL_PATH

def cargar_historial(ruta_archivo: Optional[str] = None) -> list:
    """
    Carga el historial de transacciones desde el archivo JSON.
    Si no se provee una ruta, usa la ruta por defecto de la configuración.
    """
    ruta_efectiva = ruta_archivo if ruta_archivo is not None else HISTORIAL_PATH
    if not os.path.exists(ruta_efectiva) or os.path.getsize(ruta_efectiva) == 0:
        return []

    try:
        with open(ruta_efectiva, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: No se pudo leer o el archivo '{ruta_efectiva}' está corrupto."
        )
        return []

def guardar_en_historial(
    tipo_operacion: str,
    moneda_origen: str,
    cantidad_origen: Decimal,
    moneda_destino: str,
    cantidad_destino: Decimal,
    valor_usd: Decimal,
    ruta_archivo: Optional[str] = None,
):
    """
    Guarda una nueva operación en el historial de transacciones.
    Si no se provee una ruta, usa la ruta por defecto de la configuración.
    """
    ruta_efectiva = ruta_archivo if ruta_archivo is not None else HISTORIAL_PATH
    os.makedirs(os.path.dirname(ruta_efectiva), exist_ok=True)
    historial = cargar_historial(ruta_archivo=ruta_efectiva)

    cantidad_origen_q = cuantizar_cripto(cantidad_origen)
    cantidad_destino_q = cuantizar_cripto(cantidad_destino)
    valor_usd_q = cuantizar_usd(valor_usd)

    operacion = {
        "id": len(historial) + 1,
        "timestamp": datetime.now().isoformat(),
        "tipo": tipo_operacion,
        "origen": {"ticker": moneda_origen, "cantidad": str(cantidad_origen_q)},
        "destino": {"ticker": moneda_destino, "cantidad": str(cantidad_destino_q)},
        "valor_usd": str(valor_usd_q),
    }

    historial.insert(0, operacion)

    with open(ruta_efectiva, "w", encoding="utf-8") as f:
        json.dump(historial, f, indent=4)

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_ordenes.py ===
==================================================

# backend/acceso_datos/datos_ordenes.py

"""
Módulo de Acceso a Datos para las Órdenes Pendientes.

Este módulo se encarga de la persistencia de las órdenes de trading que no se
ejecutan de inmediato (Límite, Stop-Loss) y que están a la espera de que se
cumplan ciertas condiciones de mercado.
"""
import json
import os
from typing import Optional
from config import ORDENES_PENDIENTES_PATH

def cargar_ordenes_pendientes(ruta_archivo: Optional[str] = None) -> list[dict]:
    """
    Carga la lista de órdenes pendientes desde el archivo JSON.
    Si no se provee una ruta, usa la ruta por defecto de la configuración.
    """
    ruta_efectiva = ruta_archivo if ruta_archivo is not None else ORDENES_PENDIENTES_PATH
    os.makedirs(os.path.dirname(ruta_efectiva), exist_ok=True)
    
    if not os.path.exists(ruta_efectiva) or os.path.getsize(ruta_efectiva) == 0:
        return []

    try:
        with open(ruta_efectiva, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(f"Advertencia: No se pudo leer o el archivo '{ruta_efectiva}' está corrupto.")
        return []

def guardar_ordenes_pendientes(lista_ordenes: list[dict], ruta_archivo: Optional[str] = None):
    """
    Guarda la lista completa de órdenes pendientes en el archivo JSON.
    Si no se provee una ruta, usa la ruta por defecto de la configuración.
    """
    ruta_efectiva = ruta_archivo if ruta_archivo is not None else ORDENES_PENDIENTES_PATH
    os.makedirs(os.path.dirname(ruta_efectiva), exist_ok=True)

    with open(ruta_efectiva, "w", encoding="utf-8") as f:
        json.dump(lista_ordenes, f, indent=4)

def agregar_orden_pendiente(nueva_orden: dict, ruta_archivo: Optional[str] = None):
    """
    Añade una nueva orden a la lista de órdenes pendientes y la guarda.
    Si no se provee una ruta, usa la ruta por defecto de la configuración.
    """
    ordenes = cargar_ordenes_pendientes(ruta_archivo=ruta_archivo)
    ordenes.append(nueva_orden)
    guardar_ordenes_pendientes(ordenes, ruta_archivo=ruta_archivo)

==================================================
=== ARCHIVO: ./backend/app.py ===
==================================================

"""
Este módulo crea una instancia global de la aplicación Flask utilizando la
'Application Factory' (`crear_app`).

Esta instancia 'app' puede ser utilizada por otras herramientas, como un servidor
WSGI (por ejemplo, Gunicorn o uWSGI), que esperan encontrar una variable de
aplicación global.

El punto de entrada principal para iniciar el servidor de desarrollo es ahora
el script `run.py` en el directorio raíz del proyecto.
"""

from flask import Flask
from . import crear_app

# Se crea la instancia global de la aplicación llamando a la factory.
app: Flask = crear_app()

==================================================
=== ARCHIVO: ./backend/rutas/__init__.py ===
==================================================

"""
Inicializa el paquete de rutas y registra todos los Blueprints de la aplicación.

Este archivo importa los Blueprints definidos en los diferentes módulos de vistas
(home, trading, billetera, etc.) y proporciona una función centralizada `registrar_rutas`
para vincularlos a la instancia principal de la aplicación Flask.
"""

from .home import bp as home_bp
from .trading_vista import bp as trading_bp
from .billetera_vista import bp as billetera_bp
from .api_externa import bp as api_ruta_bp


def registrar_rutas(app):
    """
    Registra todos los Blueprints de la aplicación en la instancia de Flask.

    Args:
        app (Flask): La instancia principal de la aplicación Flask a la que se
                     registrarán los Blueprints.

    Side Effects:
        Modifica el objeto `app` registrando las rutas definidas en los Blueprints.
    """
    app.register_blueprint(home_bp)
    app.register_blueprint(trading_bp)
    app.register_blueprint(billetera_bp)
    app.register_blueprint(api_ruta_bp)


==================================================
=== ARCHIVO: ./backend/rutas/api_externa.py ===
==================================================

# backend/rutas/api_externa.py

"""
Define los endpoints de la API externa de la aplicación.

Este módulo contiene las rutas que exponen datos del mercado de criptomonedas,
como cotizaciones y datos de velas (candlestick), para ser consumidos por el frontend
u otros clientes.
"""

from flask import Blueprint, jsonify
from backend.servicios.api_cotizaciones import obtener_datos_criptos_coingecko, obtener_velas_de_api
from backend.servicios.presentacion_datos import obtener_cotizaciones_formateadas

from backend.servicios.trading.motor import verificar_y_ejecutar_ordenes_pendientes

bp = Blueprint("api_externa", __name__, url_prefix="/api")


@bp.route("/actualizar")
def actualizar():
    """
    Endpoint para forzar la actualización de los datos de cotizaciones desde CoinGecko.

    Al ser llamado, este endpoint invoca al servicio que obtiene los precios más
    recientes y, crucialmente, LUEGO invoca al motor de ejecución de órdenes
    para ver si alguna orden pendiente debe dispararse con los nuevos precios.
    """
    print("--- PING: Endpoint /api/actualizar ALCANZADO ---")
    
    # 1. Obtener los datos más recientes de cotizaciones y guardarlos.
    datos_criptos = obtener_datos_criptos_coingecko()
    
    # --- 2. ¡ACTIVAR EL MOTOR DE EJECUCIÓN DE ÓRDENES! ---
    # Con los precios frescos en memoria, verificamos si alguna orden pendiente se cumple.
    verificar_y_ejecutar_ordenes_pendientes()
    
    # 3. Devolver la respuesta al frontend.
    return jsonify({"estado": "ok", "cantidad_criptos": len(datos_criptos)})


@bp.route("/cotizaciones")
def get_cotizaciones():
    """
    Retorna la lista completa de cotizaciones, formateada para la presentación.

    Esta ruta utiliza el servicio de presentación para tomar los datos crudos
    y enriquecerlos con formato antes de enviarlos al frontend.

    Returns:
        Response: Un objeto JSON que contiene una lista de todas las criptomonedas
                  y sus datos de cotización listos para ser mostrados.
                  Ejemplo: `[{"ticker": "BTC", "precio_usd_formatted": "$65,000.10", ...}]`
    """
    return jsonify(obtener_cotizaciones_formateadas())


@bp.route("/velas/<string:ticker>/<string:interval>")
def obtener_datos_velas_por_ticker(ticker: str, interval: str):
    """
    Obtiene los datos de velas (candlestick) para un par y un intervalo específicos.

    Esta ruta dinámica consulta a una API externa para obtener los datos históricos
    de precios (OHLCV) necesarios para graficar las velas.

    Args:
        ticker (str): El símbolo del par a consultar (ej. "BTCUSDT").
        interval (str): El intervalo de tiempo para las velas (ej. "1h", "4h", "1d").

    Returns:
        Response: Un objeto JSON con una lista de listas, donde cada sublista
                  representa una vela. En caso de error, retorna una lista vacía.
                  Ejemplo: `[[1622505600000, "49000.00", ...], ...]`
    """
    try:
        datos = obtener_velas_de_api(ticker, interval)
        return jsonify(datos)
    except Exception as e:
        print(f"❌ Error en la ruta de velas para {ticker}/{interval}: {e}")
        return jsonify([])

==================================================
=== ARCHIVO: ./backend/rutas/billetera_vista.py ===
==================================================

"""
Define las rutas relacionadas con la visualización de la billetera y el historial.

Este módulo contiene los endpoints para renderizar la página de la billetera
y para proporcionar datos financieros (estado actual y transacciones pasadas)
 a través de una API REST al frontend.
"""

from flask import Blueprint, render_template, jsonify, request, flash, redirect, url_for
from backend.servicios.estado_billetera import estado_actual_completo, obtener_historial_formateado
from backend.acceso_datos.datos_comisiones import cargar_comisiones
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes
from backend.servicios.trading.gestor import cancelar_orden_pendiente
from config import ESTADO_PENDIENTE

bp = Blueprint("billetera", __name__)


@bp.route("/billetera")
def mostrar_billetera():
    """
    Renderiza la página principal de la billetera.

    Esta ruta sirve el archivo `billetera.html`, que actúa como el contenedor
    principal para la interfaz de la billetera. Los datos se cargan de forma
    asíncrona a través de llamadas a la API desde JavaScript.

    Returns:
        Response: El contenido HTML renderizado de la página de la billetera.
    """
    return render_template("billetera.html")


@bp.route("/api/billetera/estado-completo")
def get_estado_billetera_completo():
    """
    Endpoint de API que devuelve el estado financiero completo de la billetera.

    Proporciona un resumen detallado que incluye el balance de cada criptomoneda,
    su valor en USD, el total general, y el rendimiento.

    Returns:
        Response: Un objeto JSON con el estado completo de la billetera.
            Ejemplo: `{"total_usd": "10500.50", "rendimiento": "5.00", ...}`
    """
    datos = estado_actual_completo()
    return jsonify(datos)


@bp.route("/api/historial")
def get_historial_transacciones():
    """
    Endpoint de API que devuelve el historial completo de transacciones.

    Retorna una lista de todas las operaciones de compra y venta realizadas,
    formateadas para su visualización en el frontend.

    Returns:
        Response: Un objeto JSON que contiene una lista de transacciones.
            Ejemplo: `[{"id": 1, "fecha": "21/06/2025", "tipo": "compra", ...}]`
    """
    return jsonify(obtener_historial_formateado())

@bp.route("/api/comisiones")
def get_historial_comisiones():
    """
    Endpoint de API que devuelve el historial completo de comisiones cobradas.
    """
    return jsonify(cargar_comisiones())

@bp.route("/api/ordenes-abiertas")
def get_ordenes_abiertas():
    """
    Endpoint de API que devuelve la lista de órdenes que están pendientes de ejecución.
    """
    todas_las_ordenes = cargar_ordenes_pendientes()
    # Filtramos para devolver solo las que están activas
    ordenes_abiertas = [o for o in todas_las_ordenes if o.get("estado") == ESTADO_PENDIENTE]
    return jsonify(ordenes_abiertas)

@bp.route("/api/orden/cancelar/<string:id_orden>", methods=["POST"])
def cancelar_orden_api(id_orden: str):
    """
    Endpoint de API para cancelar una orden pendiente.
    Devuelve una respuesta JSON estandarizada.
    """
    resultado = cancelar_orden_pendiente(id_orden)
    
    if resultado["estado"] == "error":
        return jsonify(resultado), 400
    else:
        return jsonify(resultado), 200

==================================================
=== ARCHIVO: ./backend/rutas/home.py ===
==================================================

"""
Define la ruta principal (landing page) de la aplicación.

Este módulo es responsable de servir la página de inicio (index.html),
que actúa como el punto de entrada para los usuarios.
"""

from flask import Blueprint, render_template

bp = Blueprint("home", __name__)


@bp.route("/")
def index():
    """
    Renderiza la página de inicio de la aplicación.

    Esta ruta sirve el archivo `index.html`, que es el esqueleto principal
    de la interfaz. El contenido dinámico, como las cotizaciones, se carga
    posteriormente de forma asíncrona mediante JavaScript.

    Returns:
        Response: El contenido HTML renderizado de la página de inicio.
    """
    return render_template("index.html")

==================================================
=== ARCHIVO: ./backend/rutas/trading_vista.py ===
==================================================

# backend/rutas/trading_vista.py
### REFACTORIZADO ###

import json # Importamos la librería json
from flask import Blueprint, request, redirect, url_for, render_template, flash
from backend.servicios.trading.procesador import procesar_operacion_trading

bp = Blueprint("trading", __name__)

@bp.route("/trading", methods=["GET"])
def mostrar_trading_page():
    """ SIN CAMBIOS - Renderiza la página de trading. """
    return render_template("trading.html")

@bp.route("/trading/operar", methods=["POST"])
def procesar_trading_form():
    """
    ### REFACTORIZADO ###
    Procesa el formulario y pasa un JSON al sistema de flash en caso de éxito.
    Maneja la nueva respuesta estandarizada en formato de diccionario.
    """
    print(">>> DATOS RECIBIDOS DEL FORMULARIO:", request.form)

    ticker_operado = request.form.get("ticker", "BTC").upper()
    
    # La función de servicio ahora devuelve un único diccionario de respuesta.
    respuesta = procesar_operacion_trading(request.form)

    if respuesta["estado"] == "exito":
        # Si la operación fue exitosa, los datos están en la clave 'datos'.
        # Lo convertimos a un string JSON para guardarlo en la sesión flash.
        flash(json.dumps(respuesta["datos"]), "success")
    else:
        # Si falló, el mensaje de error está en la clave 'mensaje'.
        flash(respuesta["mensaje"], "danger")
    
    # La lógica de redirección no cambia.
    redirect_url = url_for("trading.mostrar_trading_page", ticker=ticker_operado)
    return redirect(redirect_url)

==================================================
=== ARCHIVO: ./backend/servicios/__init__.py ===
==================================================

"""
El paquete 'servicios' contiene la lógica de negocio de la aplicación.

Este módulo separa las operaciones complejas, los cálculos y las interacciones
con APIs externas de las capas de acceso a datos y de las vistas (rutas).
Su objetivo es mantener el código organizado, reutilizable y fácil de mantener.
"""

==================================================
=== ARCHIVO: ./backend/servicios/api_cotizaciones.py ===
==================================================

"""
Servicio para interactuar con APIs externas de criptomonedas.

Este módulo centraliza las llamadas a las APIs de CoinGecko (para cotizaciones
generales del mercado) y Binance (para datos de velas/k-lines). Se encarga de
realizar las peticiones, procesar los datos y guardarlos localmente.
"""

from decimal import Decimal
import requests
import json

from backend.acceso_datos.datos_cotizaciones import guardar_datos_cotizaciones
from config import COINGECKO_URL, BINANCE_URL, CANTIDAD_CRIPTOMONEDAS, CANTIDAD_VELAS

def obtener_datos_criptos_coingecko() -> list[dict]:
    """
    Obtiene y procesa datos de mercado desde la API de CoinGecko.

    Realiza una petición para obtener una lista de las principales criptomonedas,
    procesa la respuesta JSON y guarda los datos crudos en un archivo local.
    El formateo para la UI se delega a otra capa de servicio.
    """
    params = {
        "vs_currency": "usd",
        "order": "market_cap_desc",
        "per_page": CANTIDAD_CRIPTOMONEDAS,
        "page": 1,
        "sparkline": "false",
        "price_change_percentage": "1h,24h,7d",
    }

    try:
        respuesta = requests.get(COINGECKO_URL, params, timeout=10)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"❌ Error al obtener datos de CoinGecko: {str(e)}")
        return []

    print(f"✅ Estado de la respuesta CoinGecko: {respuesta.status_code}")

    try:
        datos = respuesta.json()
        resultado = []
        for i, dato in enumerate(datos, start=1):
            resultado.append({
                "id": i,
                "nombre": dato.get("name"),
                "ticker": dato.get('symbol', '').upper(),
                "logo": dato.get("image"),
                "precio_usd": str(Decimal(str(dato.get("current_price", 0)))),
                "1h_%": str(Decimal(str(dato.get("price_change_percentage_1h_in_currency", 0)))),
                "24h_%": str(Decimal(str(dato.get("price_change_percentage_24h_in_currency", 0)))),
                "7d_%": str(Decimal(str(dato.get("price_change_percentage_7d_in_currency", 0)))),
                "market_cap": str(Decimal(str(dato.get("market_cap", 0)))),
                "volumen_24h": str(Decimal(str(dato.get("total_volume", 0)))),
                "circulating_supply": str(Decimal(str(dato.get("circulating_supply", 0)))),
            })
    except (KeyError, TypeError, ValueError, json.JSONDecodeError) as e:
        print(f"❌ Error al procesar los datos de CoinGecko: {str(e)}")
        return []

    print(f"💡 Total de criptos procesadas: {len(resultado)}")
    guardar_datos_cotizaciones(resultado)
    return resultado


def obtener_velas_de_api(ticker: str, interval: str) -> list[dict]:
    """
    Obtiene datos históricos de velas (K-lines) desde la API de Binance.
    """
    params = {
        "symbol": f"{ticker.upper()}USDT",
        "interval": interval,
        "limit": CANTIDAD_VELAS,
    }
    try:
        respuesta = requests.get(BINANCE_URL, params, timeout=10)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"❌ Error al obtener datos de Binance para {ticker} ({interval}): {str(e)}")
        return []

    print(f"✅ Estado de la respuesta Binance para {ticker} ({interval}): {respuesta.status_code}")

    try:
        datos = respuesta.json()
        if not isinstance(datos, list):
            print(f"⚠️ Respuesta inesperada de Binance para {ticker} ({interval}): {datos}")
            return []
        
        resultado = [
            {
                "time": int(vela[0] / 1000), "open": str(Decimal(vela[1])),
                "high": str(Decimal(vela[2])), "low": str(Decimal(vela[3])),
                "close": str(Decimal(vela[4])), "volume": str(Decimal(vela[5])),
            }
            for vela in datos
        ]
        return resultado
    except (json.JSONDecodeError, IndexError, TypeError) as e:
        print(f"❌ Error al procesar los datos de velas de Binance para {ticker}: {e}")
        return []

==================================================
=== ARCHIVO: ./backend/servicios/estado_billetera.py ===
==================================================

# backend/servicios/estado_billetera.py

from decimal import Decimal

from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_historial import cargar_historial
# Se elimina la importación de obtener_precio, ya que no se usará el caché global en los tests.
from backend.acceso_datos.datos_cotizaciones import cargar_datos_cotizaciones
from backend.utils.utilidades_numericas import (
    a_decimal, formato_cantidad_usd, formato_cantidad_cripto, formato_porcentaje
)
from backend.utils.formatters import format_datetime
from config import (
    UMBRAL_POLVO_USD, UMBRAL_CASI_CERO,
    BILLETERA_PATH, HISTORIAL_PATH, COTIZACIONES_PATH
)

def _division_segura(numerador: Decimal, denominador: Decimal) -> Decimal:
    return numerador / denominador if denominador > a_decimal(0) else a_decimal(0)

def _preparar_datos_compra(historial: list[dict]) -> dict[str, dict]:
    datos_compra_por_ticker = {}
    for operacion in historial:
        if operacion.get("tipo", "").endswith("compra"):
            destino = operacion.get("destino", {})
            ticker = destino.get("ticker")
            if not ticker or ticker == "USDT": continue
            if ticker not in datos_compra_por_ticker:
                datos_compra_por_ticker[ticker] = {"total_invertido": a_decimal(0), "cantidad_comprada": a_decimal(0)}
            datos_compra_por_ticker[ticker]["total_invertido"] += a_decimal(operacion.get("valor_usd"))
            datos_compra_por_ticker[ticker]["cantidad_comprada"] += a_decimal(destino.get("cantidad"))
    return datos_compra_por_ticker

def _calcular_metricas_activo(ticker: str, cantidad_total: Decimal, precio_actual: Decimal, datos_compra: dict) -> dict:
    valor_actual_usd = cantidad_total * precio_actual
    total_invertido = datos_compra.get("total_invertido", a_decimal(0))
    cantidad_comprada = datos_compra.get("cantidad_comprada", a_decimal(0))
    precio_promedio_compra = _division_segura(total_invertido, cantidad_comprada)
    costo_base_actual = cantidad_total * precio_promedio_compra
    ganancia_o_perdida = valor_actual_usd - costo_base_actual if costo_base_actual > 0 else a_decimal(0)
    porcentaje_ganancia = _division_segura(ganancia_o_perdida, costo_base_actual) * Decimal("100")
    return {
        "ticker": ticker, "cantidad": cantidad_total, "precio_actual": precio_actual,
        "valor_usdt": valor_actual_usd, "precio_promedio_compra": precio_promedio_compra,
        "costo_base_actual": costo_base_actual, "ganancia_perdida": ganancia_o_perdida,
        "porcentaje_ganancia": porcentaje_ganancia,
    }

def _formatear_activo_para_presentacion(activo_calculado: dict, cripto_info: dict, saldos: dict, total_billetera_usd: Decimal) -> dict:
    porcentaje_en_billetera = _division_segura(activo_calculado["valor_usdt"], total_billetera_usd) * Decimal("100")
    es_polvo = activo_calculado["valor_usdt"] < UMBRAL_POLVO_USD

    cantidad_total = activo_calculado["cantidad"]
    saldo_disponible = saldos.get("disponible", a_decimal(0))
    saldo_reservado = saldos.get("reservado", a_decimal(0))

    return {
        "ticker": activo_calculado["ticker"],
        "nombre": cripto_info.get("nombre", activo_calculado["ticker"]),
        "logo": cripto_info.get("logo", ""),
        "es_polvo": es_polvo,
        
        "cantidad_total": str(cantidad_total),
        "cantidad_disponible": str(saldo_disponible),
        "cantidad_reservada": str(saldo_reservado),

        "cantidad_total_formatted": formato_cantidad_cripto(cantidad_total),
        "cantidad_disponible_formatted": formato_cantidad_cripto(saldo_disponible),
        "cantidad_reservada_formatted": formato_cantidad_cripto(saldo_reservado),
        
        "precio_actual_formatted": formato_cantidad_usd(activo_calculado["precio_actual"]),
        "valor_usdt_formatted": formato_cantidad_usd(activo_calculado["valor_usdt"]),
        "ganancia_perdida_formatted": formato_cantidad_usd(activo_calculado["ganancia_perdida"]),
        "ganancia_perdida_cruda": str(activo_calculado["ganancia_perdida"]),
        "porcentaje_ganancia_formatted": formato_porcentaje(activo_calculado["porcentaje_ganancia"]),
        "porcentaje_formatted": formato_porcentaje(porcentaje_en_billetera),
    }

def estado_actual_completo(
    ruta_billetera: str = BILLETERA_PATH,
    ruta_historial: str = HISTORIAL_PATH,
    ruta_cotizaciones: str = COTIZACIONES_PATH
) -> list[dict]:
    billetera = cargar_billetera(ruta_archivo=ruta_billetera)
    historial = cargar_historial(ruta_archivo=ruta_historial)
    cotizaciones_raw = cargar_datos_cotizaciones(ruta_archivo=ruta_cotizaciones)
    
    info_criptos = {c['ticker']: c for c in cotizaciones_raw}
    precios_locales = {c['ticker']: a_decimal(c.get('precio_usd', '0')) for c in cotizaciones_raw}
    
    # ### LA SOLUCIÓN ESTÁ AQUÍ ###
    # Forzamos el nombre y logo canónicos para USDT, ignorando lo que venga de la API.
    # Esto asegura consistencia y evita nombres como "Polygon Bridged USDT".
    info_criptos['USDT'] = {
        'nombre': 'Tether', 
        'logo': 'https://assets.coingecko.com/coins/images/325/large/Tether.png?1696501661',
        'ticker': 'USDT'
    }

    datos_compra_por_ticker = _preparar_datos_compra(historial)
    activos_calculados = []
    
    for ticker, activo_data in billetera.items():
        saldos = activo_data.get("saldos", {})
        cantidad_total = saldos.get("disponible", a_decimal(0)) + saldos.get("reservado", a_decimal(0))

        if cantidad_total < UMBRAL_CASI_CERO:
            continue
            
        # Obtenemos la información de la cripto de nuestro diccionario 'curado'.
        cripto_info_actual = info_criptos.get(ticker, {"nombre": ticker, "logo": ""})

        if ticker == "USDT":
            metricas = {
                "ticker": "USDT", "cantidad": cantidad_total, "precio_actual": a_decimal(1),
                "valor_usdt": cantidad_total, "ganancia_perdida": a_decimal(0),
                "porcentaje_ganancia": a_decimal(0),
            }
        else:
            precio_actual = precios_locales.get(ticker, a_decimal(0))
            datos_compra_activo = datos_compra_por_ticker.get(ticker, {})
            metricas = _calcular_metricas_activo(ticker, cantidad_total, precio_actual, datos_compra_activo)
        
        metricas['cripto_info'] = cripto_info_actual
        metricas['saldos'] = saldos
        activos_calculados.append(metricas)

    activos_calculados.sort(key=lambda x: x['valor_usdt'], reverse=True)
    total_billetera_usd = sum(activo['valor_usdt'] for activo in activos_calculados)

    activos_para_presentacion = [
        _formatear_activo_para_presentacion(activo, activo['cripto_info'], activo['saldos'], total_billetera_usd)
        for activo in activos_calculados
    ]
    return activos_para_presentacion

def obtener_historial_formateado(ruta_historial: str = HISTORIAL_PATH) -> list[dict]:
    historial_crudo = cargar_historial(ruta_archivo=ruta_historial)
    historial_formateado = []
    for item in historial_crudo:
        tipo_op = item.get('tipo', '')
        par_origen = item.get('origen', {}).get('ticker', '?')
        par_destino = item.get('destino', {}).get('ticker', '?')
        cantidad = a_decimal(item.get('destino', {}).get('cantidad')) if tipo_op.endswith('compra') else a_decimal(item.get('origen', {}).get('cantidad'))
        item_formateado = {
            "id": item.get("id"), "tipo": tipo_op,
            "fecha_formatted": format_datetime(item.get('timestamp')),
            "par_formatted": f"{par_destino}/{par_origen}",
            "tipo_formatted": tipo_op.replace('-', ' ').capitalize(),
            "cantidad_formatted": formato_cantidad_cripto(cantidad),
            "valor_total_formatted": formato_cantidad_usd(a_decimal(item.get('valor_usd'))),
        }
        historial_formateado.append(item_formateado)
    return historial_formateado

==================================================
=== ARCHIVO: ./backend/servicios/presentacion_datos.py ===
==================================================

"""
Servicio de Presentación de Datos.

Este módulo se encarga de tomar los datos crudos de la aplicación (como las cotizaciones)
y enriquecerlos con formato y lógica de presentación para ser consumidos directamente
por el frontend. Utiliza el módulo `utilidades_numericas` para todo el formateo numérico.
"""

from backend.acceso_datos.datos_cotizaciones import cargar_datos_cotizaciones
from backend.utils.formatters import get_performance_indicator
from backend.utils.utilidades_numericas import (
    formato_cantidad_usd,
    formato_porcentaje,
    formato_numero_grande,
    a_decimal
)

def obtener_cotizaciones_formateadas() -> list[dict]:
    """
    Carga las cotizaciones crudas y las transforma en una lista de diccionarios
    listos para ser renderizados en el frontend.
    """
    cotizaciones_crudas = cargar_datos_cotizaciones()
    cotizaciones_presentacion = []

    for cripto in cotizaciones_crudas:
        precio_usd = a_decimal(cripto.get("precio_usd"))
        perf_1h = a_decimal(cripto.get("1h_%"))
        perf_24h = a_decimal(cripto.get("24h_%"))
        perf_7d = a_decimal(cripto.get("7d_%"))
        market_cap = a_decimal(cripto.get("market_cap"))
        volumen_24h = a_decimal(cripto.get("volumen_24h"))
        circulating_supply = a_decimal(cripto.get("circulating_supply"))
        ticker = cripto.get("ticker", "")

        cripto_presentacion = {
            "id": cripto.get("id"),
            "nombre": cripto.get("nombre"),
            "ticker": ticker,
            "logo": cripto.get("logo"),

            "precio_usd_formatted": formato_cantidad_usd(precio_usd),
            "market_cap_formatted": formato_numero_grande(market_cap),
            "volumen_24h_formatted": formato_numero_grande(volumen_24h),
            
            "circulating_supply_formatted": (
                f"{circulating_supply:,.0f} {ticker}"
                if circulating_supply > 0
                else "-"
            ),

            "1h_formatted": formato_porcentaje(perf_1h),
            "24h_formatted": formato_porcentaje(perf_24h),
            "7d_formatted": formato_porcentaje(perf_7d),

            "perf_1h": get_performance_indicator(perf_1h),
            "perf_24h": get_performance_indicator(perf_24h),
            "perf_7d": get_performance_indicator(perf_7d),
        }
        cotizaciones_presentacion.append(cripto_presentacion)

    return cotizaciones_presentacion

==================================================
=== ARCHIVO: ./backend/servicios/trading/__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./backend/servicios/trading/ejecutar_orden.py ===
==================================================

from decimal import Decimal
from typing import Dict

from backend.acceso_datos.datos_billetera import guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio, cargar_datos_cotizaciones
from backend.acceso_datos.datos_historial import guardar_en_historial
from backend.acceso_datos.datos_comisiones import registrar_comision
from config import TASA_COMISION
from backend.utils.utilidades_numericas import a_decimal

# --- Funciones Privadas del Módulo ---

def _crear_activo_si_no_existe(billetera: dict, ticker: str):
    """Crea una entrada para un activo en la billetera si no existe."""
    if ticker not in billetera:
        info_criptos = {c['ticker']: c for c in cargar_datos_cotizaciones()}
        info_nueva_moneda = info_criptos.get(ticker, {"nombre": ticker})
        billetera[ticker] = {"nombre": info_nueva_moneda.get("nombre", ticker), "saldos": {"disponible": a_decimal("0"), "reservado": a_decimal("0")}}

# --- Punto de Entrada Público del Módulo ---

def ejecutar_transaccion(
    billetera: Dict,
    moneda_origen: str,
    cantidad_origen_bruta: Decimal,
    moneda_destino: str,
    tipo_operacion_historial: str,
    es_orden_pendiente: bool = False
) -> tuple[bool, dict]:
    """
    ### NUEVO - Función Atómica y Centralizada ###
    Ejecuta una transacción completa: calcula comisión, actualiza saldos,
    registra en historial y devuelve los detalles.
    
    Args:
        billetera: El objeto de la billetera actual.
        moneda_origen: Ticker de la moneda que se gasta.
        cantidad_origen_bruta: Cantidad total que se deduce del origen.
        moneda_destino: Ticker de la moneda que se recibe.
        tipo_operacion_historial: String para guardar en el historial (ej. "Compra", "limit-compra").
        es_orden_pendiente: True si los fondos vienen de 'reservado' en lugar de 'disponible'.

    Returns:
        Una tupla (éxito, diccionario_de_resultados).
    """
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)

    if not all([precio_origen_usdt, precio_destino_usdt, not precio_destino_usdt.is_zero()]):
        return False, {"error": "No se pudo obtener la cotización para ejecutar la transacción."}

    # 1. Calcular comisión y cantidades netas
    cantidad_comision = cantidad_origen_bruta * TASA_COMISION
    cantidad_origen_neta = cantidad_origen_bruta - cantidad_comision
    valor_neto_usd_final = cantidad_origen_neta * precio_origen_usdt
    cantidad_destino_neta_final = valor_neto_usd_final / precio_destino_usdt

    # 2. Actualizar saldos de la billetera
    saldo_a_modificar = "reservado" if es_orden_pendiente else "disponible"
    billetera[moneda_origen]["saldos"][saldo_a_modificar] -= cantidad_origen_bruta
    
    _crear_activo_si_no_existe(billetera, moneda_destino)
    billetera[moneda_destino]["saldos"]["disponible"] += cantidad_destino_neta_final
    
    # 3. Registrar comisión e historial
    registrar_comision(moneda_origen, cantidad_comision, cantidad_comision * precio_origen_usdt)
    guardar_en_historial(
        tipo_operacion_historial,
        moneda_origen,
        cantidad_origen_neta,
        moneda_destino,
        cantidad_destino_neta_final,
        valor_neto_usd_final
    )
    
    # 4. Devolver los detalles de la ejecución
    detalles_ejecucion = {
        "cantidad_destino_final": cantidad_destino_neta_final,
        "cantidad_origen_neta": cantidad_origen_neta,
        "cantidad_comision": cantidad_comision,
        "valor_usd_final": valor_neto_usd_final,
    }
    
    return True, detalles_ejecucion

==================================================
=== ARCHIVO: ./backend/servicios/trading/gestor.py ===
==================================================

# backend/servicios/trading/gestor.py
from typing import Dict, Any
from decimal import Decimal
from datetime import datetime

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes, guardar_ordenes_pendientes
from backend.utils.responses import crear_respuesta_error, crear_respuesta_exitosa
from backend.utils.utilidades_numericas import a_decimal, formato_cantidad_cripto
from backend.servicios.estado_billetera import estado_actual_completo
from config import (
    ESTADO_ERROR, ESTADO_PENDIENTE, ESTADO_CANCELADA, ESTADO_EJECUTADA,
    TIPO_ORDEN_MERCADO
)

def crear_orden(
    par: str,
    tipo_orden: str,
    accion: str,
    cantidad: Decimal,
    precio_limite: Decimal = None,
    precio_disparo: Decimal = None
) -> Dict[str, Any]:
    """
    Crea una nueva orden, reserva los fondos necesarios y la guarda en el sistema.
    Si la orden es de tipo 'market', se intenta ejecutar inmediatamente.
    """
    # Importación local para evitar dependencia circular
    from backend.servicios.trading.motor import _crear_nueva_orden, _ejecutar_orden_pendiente

    nueva_orden = _crear_nueva_orden(par, tipo_orden, accion, cantidad, precio_limite, precio_disparo)

    if ESTADO_ERROR in nueva_orden:
        return nueva_orden

    billetera = cargar_billetera()
    moneda_a_reservar = nueva_orden["moneda_reservada"]
    cantidad_a_reservar = a_decimal(nueva_orden["cantidad_reservada"])

    # Verificación robusta de fondos disponibles
    if billetera.get(moneda_a_reservar, {}).get('saldos', {}).get('disponible', Decimal('0')) < cantidad_a_reservar:
        return {ESTADO_ERROR: f"Fondos insuficientes de {moneda_a_reservar}."}

    # Reservar fondos
    billetera[moneda_a_reservar]['saldos']['disponible'] -= cantidad_a_reservar
    billetera[moneda_a_reservar]['saldos']['reservado'] += cantidad_a_reservar

    # Las órdenes de mercado se ejecutan inmediatamente
    if nueva_orden["tipo_orden"] == TIPO_ORDEN_MERCADO:
        print(f"📈 Orden de mercado detectada ({nueva_orden['id_orden']}). Ejecutando inmediatamente...")
        billetera = _ejecutar_orden_pendiente(nueva_orden, billetera)

    # Guardar estado
    todas_las_ordenes = cargar_ordenes_pendientes()
    
    # Reemplazar la orden si ya existe (caso de orden de mercado que se actualizó) o añadirla si es nueva
    orden_existente_idx = next((i for i, o in enumerate(todas_las_ordenes) if o.get("id_orden") == nueva_orden['id_orden']), -1)
    if orden_existente_idx != -1:
        todas_las_ordenes[orden_existente_idx] = nueva_orden
    else:
        todas_las_ordenes.append(nueva_orden)
    
    guardar_ordenes_pendientes(todas_las_ordenes)
    guardar_billetera(billetera)

    print(f"✅ Orden {nueva_orden['id_orden']} creada exitosamente.")
    return nueva_orden


def cancelar_orden_pendiente(id_orden: str) -> Dict:
    """
    Busca una orden pendiente por su ID, la cancela y libera los fondos reservados.
    """
    todas_las_ordenes = cargar_ordenes_pendientes()
    orden_a_cancelar = next((o for o in todas_las_ordenes if o.get("id_orden") == id_orden), None)

    if not orden_a_cancelar:
        return crear_respuesta_error(f"No se encontró una orden con el ID {id_orden}.")

    if orden_a_cancelar.get("estado") != ESTADO_PENDIENTE:
        return crear_respuesta_error(f"La orden {id_orden} no está pendiente y no puede ser cancelada.")

    billetera = cargar_billetera()
    moneda_reservada = orden_a_cancelar["moneda_reservada"]
    cantidad_reservada = a_decimal(orden_a_cancelar["cantidad_reservada"])

    activo_en_billetera = billetera.get(moneda_reservada)

    # Verificación de consistencia de fondos
    if not activo_en_billetera or a_decimal(activo_en_billetera.get("saldos", {}).get("reservado", Decimal('0'))) < cantidad_reservada:
        orden_a_cancelar["estado"] = ESTADO_ERROR
        orden_a_cancelar["mensaje_error"] = "Error de consistencia: los fondos a liberar no coinciden con la billetera."
        guardar_ordenes_pendientes(todas_las_ordenes)
        return crear_respuesta_error(orden_a_cancelar["mensaje_error"])

    # Liberar fondos
    activo_en_billetera["saldos"]["reservado"] -= cantidad_reservada
    activo_en_billetera["saldos"]["disponible"] += cantidad_reservada

    # Actualizar estado de la orden
    orden_a_cancelar["estado"] = ESTADO_CANCELADA
    orden_a_cancelar["timestamp_cancelacion"] = datetime.now().isoformat()

    guardar_ordenes_pendientes(todas_las_ordenes)
    guardar_billetera(billetera)

    # Devolver una respuesta clara y útil para el frontend
    mensaje_exito = f"Orden {orden_a_cancelar['par']} cancelada. Se liberaron {formato_cantidad_cripto(cantidad_reservada)} {moneda_reservada}."
    
    billetera_actualizada_completa = estado_actual_completo()
    activo_modificado = next((a for a in billetera_actualizada_completa if a['ticker'] == moneda_reservada), None)

    datos_exito = {
        "orden_cancelada": orden_a_cancelar,
        "activo_actualizado": activo_modificado
    }
    return crear_respuesta_exitosa(datos_exito, mensaje_exito)

==================================================
=== ARCHIVO: ./backend/servicios/trading/motor.py ===
==================================================

# backend/servicios/trading/motor.py
from datetime import datetime
from decimal import Decimal

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes, guardar_ordenes_pendientes
from config import (
    ACCION_COMPRAR,
    ACCION_VENDER,
    ESTADO_EJECUTADA,
    ESTADO_PENDIENTE,
    ESTADO_ERROR,
    TIPO_ORDEN_LIMITE,
    TIPO_ORDEN_MERCADO,
    TIPO_ORDEN_STOP_LIMIT
)
from backend.servicios.trading.ejecutar_orden import ejecutar_transaccion
from backend.utils.utilidades_numericas import a_decimal, cuantizar_cripto


def _verificar_condicion_orden(orden: dict, precio_actual: Decimal) -> bool:
    """Verifica si el precio actual cumple la condición de DISPARO de la orden."""
    precio_disparo = a_decimal(orden["precio_disparo"])
    tipo_orden = orden.get("tipo_orden", TIPO_ORDEN_LIMITE)

    if tipo_orden == TIPO_ORDEN_LIMITE:
        if orden["accion"] == ACCION_COMPRAR:
            return precio_actual <= precio_disparo
        elif orden["accion"] == ACCION_VENDER:
            return precio_actual >= precio_disparo
            
    elif tipo_orden == TIPO_ORDEN_STOP_LIMIT:
        if orden["accion"] == ACCION_COMPRAR:
            return precio_actual >= precio_disparo
        elif orden["accion"] == ACCION_VENDER:
            return precio_actual <= precio_disparo

    return False


def _ejecutar_orden_pendiente(orden: dict, billetera: dict) -> dict:
    """
    Intenta ejecutar una orden que ya ha sido disparada (condición cumplida),
    con lógica especial para la verificación del precio límite en órdenes Stop-Limit.
    """
    if orden.get("tipo_orden") == TIPO_ORDEN_STOP_LIMIT:
        precio_limite = a_decimal(orden.get("precio_limite"))
        
        if not precio_limite or precio_limite.is_zero():
             print(f"❌ ERROR DE DATOS: Orden Stop-Limit {orden['id_orden']} no tiene precio límite válido.")
             orden["estado"] = ESTADO_ERROR
             return billetera
              
        precio_actual_mercado = obtener_precio(orden["par"])
        if not precio_actual_mercado:
             print(f"⚠️  No se pudo obtener el precio de mercado para {orden['par']} para validar el límite de la orden {orden['id_orden']}.")
             return billetera

        if orden["accion"] == ACCION_COMPRAR and precio_actual_mercado > precio_limite:
            print(f"🚦 ORDEN STOP-LIMIT {orden['id_orden']} DISPARADA, PERO NO EJECUTADA: Precio actual ({precio_actual_mercado}) > Precio Límite ({precio_limite}).")
            return billetera
        
        elif orden["accion"] == ACCION_VENDER and precio_actual_mercado < precio_limite:
            print(f"🚦 ORDEN STOP-LIMIT {orden['id_orden']} DISPARADA, PERO NO EJECUTADA: Precio actual ({precio_actual_mercado}) < Precio Límite ({precio_limite}).")
            return billetera

    moneda_origen = orden["moneda_reservada"]
    cantidad_origen_bruta = a_decimal(orden["cantidad_reservada"])
    # Corregido: La moneda de destino se saca del par, no de la propia orden directamente.
    moneda_destino = orden["par"].split('/')[0] if orden["accion"] == ACCION_COMPRAR else orden["par"].split('/')[1]
    
    # El tipo de operación para el historial debe ser más descriptivo
    tipo_op_historial = f"{orden['tipo_orden']}-{orden['accion']}"

    # --- LLAMADA CORREGIDA ---
    exito_ejecucion, detalles_ejecucion = ejecutar_transaccion(
        billetera=billetera,
        moneda_origen=moneda_origen,
        cantidad_origen_bruta=cantidad_origen_bruta,
        moneda_destino=moneda_destino,
        tipo_operacion_historial=tipo_op_historial,
        es_orden_pendiente=True # ¡Importante! Para que use el saldo 'reservado'
    )
    
    if not exito_ejecucion:
        print(f"❌ ERROR al ejecutar orden pendiente {orden['id_orden']}: {detalles_ejecucion.get('error')}")
        orden.update({"estado": ESTADO_ERROR, "mensaje_error": detalles_ejecucion.get("error")})
        return billetera

    print(f"✅ ORDEN EJECUTADA: {orden['id_orden']} ({orden['par']})")
    orden.update({
        "estado": ESTADO_EJECUTADA,
        "timestamp_ejecucion": datetime.now().isoformat(),
        "cantidad_destino_final": str(cuantizar_cripto(detalles_ejecucion["cantidad_destino_final"]))
    })
    return billetera


def verificar_y_ejecutar_ordenes_pendientes():
    """Motor principal que itera sobre órdenes pendientes y las ejecuta si cumplen la condición."""
    todas_las_ordenes = cargar_ordenes_pendientes()
    ordenes_pendientes = [o for o in todas_las_ordenes if o.get("estado") == ESTADO_PENDIENTE]
    if not ordenes_pendientes: 
        return

    billetera = cargar_billetera()
    ordenes_modificadas = []
    
    for orden in ordenes_pendientes:
        precio_actual = obtener_precio(orden["par"])
        if not precio_actual:
            print(f"⚠️  No se pudo obtener precio para el par {orden['par']}. Saltando orden {orden['id_orden']}.")
            continue

        if _verificar_condicion_orden(orden, precio_actual):
            print(f"🔔 CONDICIÓN CUMPLIDA para orden {orden['id_orden']}. Intentando ejecutar...")
            billetera = _ejecutar_orden_pendiente(orden, billetera)
        
        ordenes_modificadas.append(orden)

    ordenes_no_modificadas = [o for o in todas_las_ordenes if o.get("estado") != ESTADO_PENDIENTE]
    
    guardar_ordenes_pendientes(ordenes_no_modificadas + ordenes_modificadas)
    guardar_billetera(billetera)
    print("--- Ciclo de motor de trading finalizado ---")


def _crear_nueva_orden(par, tipo_orden, accion, cantidad, precio_limite=None, precio_disparo=None):
    """
    Valida los datos de una nueva orden y la estructura para ser guardada.
    No guarda la orden, solo la prepara y valida.
    """
    if tipo_orden not in [TIPO_ORDEN_MERCADO, TIPO_ORDEN_LIMITE, TIPO_ORDEN_STOP_LIMIT]:
        return {ESTADO_ERROR: "Tipo de orden no válido"}
    
    if accion not in [ACCION_COMPRAR, ACCION_VENDER]:
        return {ESTADO_ERROR: "Acción no válida"}

    if tipo_orden in [TIPO_ORDEN_LIMITE, TIPO_ORDEN_STOP_LIMIT] and (not precio_limite or precio_limite <= 0):
        return {ESTADO_ERROR: "El precio límite es obligatorio para órdenes límite y stop-limit"}

    if tipo_orden == TIPO_ORDEN_STOP_LIMIT and (not precio_disparo or precio_disparo <= 0):
        return {ESTADO_ERROR: "El precio de disparo es obligatorio para órdenes stop-limit"}

    moneda_principal, moneda_cotizada = par.split('/')
    
    if accion == ACCION_COMPRAR:
        moneda_reservada = moneda_cotizada
        cantidad_reservada = cantidad if tipo_orden == TIPO_ORDEN_MERCADO else cantidad * precio_limite
    else: # Vender
        moneda_reservada = moneda_principal
        cantidad_reservada = cantidad

    id_orden = f"{par.replace('/', '_').lower()}_{accion}_{datetime.now().timestamp()}"
    
    precio_disparo_final = precio_disparo if precio_disparo else precio_limite

    nueva_orden = {
        "id_orden": id_orden,
        "par": par,
        "accion": accion,
        "tipo_orden": tipo_orden,
        "cantidad": str(cantidad),
        "precio_limite": str(precio_limite) if precio_limite else "0",
        "precio_disparo": str(precio_disparo_final) if precio_disparo_final else "0",
        "moneda_reservada": moneda_reservada,
        "cantidad_reservada": str(cantidad_reservada),
        "moneda_origen": moneda_reservada,
        "moneda_destino": moneda_principal if accion == ACCION_COMPRAR else moneda_cotizada,
        "estado": ESTADO_PENDIENTE if tipo_orden in [TIPO_ORDEN_LIMITE, TIPO_ORDEN_STOP_LIMIT] else ESTADO_EJECUTADA,
        "timestamp_creacion": datetime.now().isoformat(),
        "timestamp_ejecucion": None,
        "cantidad_destino_final": "0"
    }
    
    return nueva_orden

==================================================
=== ARCHIVO: ./backend/servicios/trading/procesador.py ===
==================================================

# backend/servicios/trading/procesador.py

import uuid
from datetime import datetime
from decimal import Decimal
from typing import Tuple, Dict, Any

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from config import ACCION_COMPRAR, ACCION_VENDER
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_ordenes import agregar_orden_pendiente
from backend.servicios.trading.ejecutar_orden import ejecutar_transaccion
from backend.utils.responses import crear_respuesta_error, crear_respuesta_exitosa
from backend.utils.utilidades_numericas import (
    a_decimal, cuantizar_cripto, cuantizar_usd, 
    formato_cantidad_cripto, formato_cantidad_usd
)

def _validar_saldo_disponible(billetera: dict, moneda_origen: str, cantidad_requerida: Decimal) -> Tuple[bool, str | None]:
    """Valida si hay suficiente saldo disponible en la billetera."""
    activo = billetera.get(moneda_origen)
    if not activo:
        return False, f"❌ No posees {moneda_origen} en tu billetera."
    saldo_disponible = a_decimal(activo['saldos'].get("disponible"))
    if cantidad_requerida > saldo_disponible:
        return False, f"❌ Saldo insuficiente. Tienes {formato_cantidad_cripto(saldo_disponible)} {moneda_origen} disponibles, pero se requieren {formato_cantidad_cripto(cantidad_requerida)}."
    return True, None

def _calcular_detalles_intercambio(
    accion: str,
    modo_ingreso: str,
    monto_form: Decimal,
    precio_origen_usdt: Decimal,
    precio_destino_usdt: Decimal
) -> Tuple[bool, Dict[str, Any] | str]:
    """
    Función de cálculo pura para un intercambio.
    No modifica estado, solo realiza matemáticas. Devuelve las cantidades brutas.
    """
    if precio_origen_usdt.is_zero() or precio_destino_usdt.is_zero():
        return False, "No se pudo obtener una cotización válida para el par."

    cantidad_origen_bruta = Decimal("0")
    cantidad_destino_bruta = Decimal("0")
    valor_usd = Decimal("0")
    
    if accion == ACCION_COMPRAR:
        if modo_ingreso == "monto":
            cantidad_destino_bruta = monto_form
            valor_usd = cantidad_destino_bruta * precio_destino_usdt
            cantidad_origen_bruta = valor_usd / precio_origen_usdt
        elif modo_ingreso == "total":
            cantidad_origen_bruta = monto_form
            valor_usd = cantidad_origen_bruta * precio_origen_usdt
            cantidad_destino_bruta = valor_usd / precio_destino_usdt
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no válido para una compra."
    
    elif accion == "vender":
        if modo_ingreso == "monto":
            cantidad_origen_bruta = monto_form
            valor_usd = cantidad_origen_bruta * precio_origen_usdt
            cantidad_destino_bruta = valor_usd / precio_destino_usdt
        elif modo_ingreso == "total":
            cantidad_destino_bruta = monto_form
            valor_usd = cantidad_destino_bruta * precio_destino_usdt
            cantidad_origen_bruta = valor_usd / precio_origen_usdt
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no válido para una venta."
    
    else:
        return False, f"Acción de trading desconocida: '{accion}'."

    return True, {
        "cantidad_origen_bruta": cantidad_origen_bruta,
        "cantidad_destino_bruta": cantidad_destino_bruta,
        "valor_usd": valor_usd
    }
    
def _ejecutar_orden_mercado(moneda_origen: str, moneda_destino: str, monto_form: Decimal, modo_ingreso: str, accion: str) -> Dict[str, Any]:
    """Orquesta la ejecución de una orden a precio de mercado."""
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)
    if not all([precio_origen_usdt, precio_destino_usdt]):
        return crear_respuesta_error("❌ No se pudo obtener la cotización para realizar el swap.")

    exito_calculo, detalles_brutos = _calcular_detalles_intercambio(accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt)
    if not exito_calculo:
        return crear_respuesta_error(f"❌ {detalles_brutos}")

    cantidad_origen_bruta = detalles_brutos["cantidad_origen_bruta"]
    billetera = cargar_billetera()
    exito_validacion, mensaje_error = _validar_saldo_disponible(billetera, moneda_origen, cantidad_origen_bruta)
    if not exito_validacion: 
        return crear_respuesta_error(mensaje_error)

    tipo_op_historial = "Compra" if accion == ACCION_COMPRAR else "Venta"
    exito_ejecucion, detalles_ejecucion = ejecutar_transaccion(
        billetera=billetera,
        moneda_origen=moneda_origen,
        cantidad_origen_bruta=cantidad_origen_bruta,
        moneda_destino=moneda_destino,
        tipo_operacion_historial=tipo_op_historial,
        es_orden_pendiente=False
    )

    if not exito_ejecucion:
        error_msg = detalles_ejecucion.get("error", "Error desconocido durante la ejecución.")
        return crear_respuesta_error(error_msg)

    guardar_billetera(billetera)

    resultado_operacion = {
        "titulo": "Operación de Mercado Exitosa",
        "tipo": "mercado",
        "detalles": {
            "recibiste": {"cantidad": formato_cantidad_cripto(detalles_ejecucion["cantidad_destino_final"]), "ticker": moneda_destino},
            "pagaste": {"cantidad": formato_cantidad_cripto(cantidad_origen_bruta), "ticker": moneda_origen},
            "comision": {"cantidad": formato_cantidad_cripto(detalles_ejecucion["cantidad_comision"]), "ticker": moneda_origen}
        }
    }
    return crear_respuesta_exitosa(resultado_operacion)

def _calcular_reserva_y_cantidad_principal(
    accion: str, 
    modo_ingreso: str, 
    monto_form: Decimal, 
    precio_disparo: Decimal,
    precio_destino_usdt: Decimal | None = None
) -> Dict[str, Any]:
    """
    Calcula la cantidad a reservar y la cantidad principal de la cripto para una orden pendiente.
    Es una función de cálculo pura que no realiza I/O.
    Devuelve un diccionario con el resultado.
    """
    cantidad_a_reservar = Decimal("0")
    cantidad_cripto_principal = Decimal("0")

    if accion == ACCION_COMPRAR:
        if modo_ingreso == 'monto':
            cantidad_cripto_principal = monto_form
            cantidad_a_reservar = cantidad_cripto_principal * precio_disparo
        elif modo_ingreso == 'total':
            cantidad_a_reservar = monto_form
            if precio_disparo.is_zero():
                return crear_respuesta_error("El precio de disparo no puede ser cero para este cálculo.")
            cantidad_cripto_principal = cantidad_a_reservar / precio_disparo
        else:
            return crear_respuesta_error(f"Modo de ingreso '{modo_ingreso}' no válido para una compra.")

    elif accion == ACCION_VENDER:
        if modo_ingreso == 'monto':
            cantidad_cripto_principal = monto_form
            cantidad_a_reservar = cantidad_cripto_principal
        elif modo_ingreso == 'total':
            if not precio_destino_usdt or precio_destino_usdt.is_zero():
                return crear_respuesta_error("Se requiere un precio de destino válido para este cálculo.")
            if precio_disparo.is_zero():
                return crear_respuesta_error("El precio de disparo no puede ser cero para este cálculo.")
            
            valor_usd_objetivo = monto_form * precio_destino_usdt
            cantidad_cripto_principal = valor_usd_objetivo / precio_disparo
            cantidad_a_reservar = cantidad_cripto_principal
        else:
            return crear_respuesta_error(f"Modo de ingreso '{modo_ingreso}' no válido para una venta.")
    else:
        return crear_respuesta_error(f"Acción desconocida: {accion}")

    return crear_respuesta_exitosa({
        "cantidad_a_reservar": cantidad_a_reservar,
        "cantidad_cripto_principal": cantidad_cripto_principal
    })

def _crear_orden_pendiente(moneda_origen: str, moneda_destino: str, monto_form: Decimal, modo_ingreso: str, precio_disparo: Decimal, tipo_orden: str, accion: str, precio_limite: Decimal | None) -> Dict[str, Any]:
    """Crea y guarda una orden pendiente (Límite o Stop-Limit)."""
    billetera = cargar_billetera()
    
    if precio_disparo.is_zero():
        return crear_respuesta_error("❌ El precio de disparo no puede ser cero.")

    # Obtener precio de destino si es necesario para el cálculo
    precio_destino_usdt = None
    if accion == ACCION_VENDER and modo_ingreso == 'total':
        precio_destino_usdt = obtener_precio(moneda_destino)
        if not precio_destino_usdt or precio_destino_usdt.is_zero():
            return crear_respuesta_error(f"❌ No se pudo obtener la cotización actual de {moneda_destino} para calcular la reserva.")

    # Calcular cantidades usando la nueva función de ayuda
    resultado_calculo = _calcular_reserva_y_cantidad_principal(
        accion, modo_ingreso, monto_form, precio_disparo, precio_destino_usdt
    )
    if resultado_calculo["estado"] == "error":
        mensaje = f"Error en cálculo de reserva: {resultado_calculo['mensaje']}"
        return crear_respuesta_error(mensaje)

    datos_calculo = resultado_calculo["datos"]
    cantidad_a_reservar = datos_calculo["cantidad_a_reservar"]
    cantidad_cripto_principal = datos_calculo["cantidad_cripto_principal"]
    
    moneda_a_reservar = moneda_origen

    exito_validacion, mensaje_error = _validar_saldo_disponible(billetera, moneda_a_reservar, cantidad_a_reservar)
    if not exito_validacion: 
        return crear_respuesta_error(mensaje_error)

    billetera[moneda_a_reservar]["saldos"]["disponible"] -= cantidad_a_reservar
    billetera[moneda_a_reservar]["saldos"]["reservado"] += cantidad_a_reservar
    guardar_billetera(billetera)

    id_orden = str(uuid.uuid4())
    par_correcto = f"{moneda_destino}/{moneda_origen}" if accion == ACCION_COMPRAR else f"{moneda_origen}/{moneda_destino}"

    nueva_orden = {
        "id_orden": id_orden,
        "timestamp_creacion": datetime.now().isoformat(),
        "tipo_orden": tipo_orden,
        "accion": accion,
        "par": par_correcto,
        "moneda_origen": moneda_origen,
        "moneda_destino": moneda_destino,
        "cantidad_cripto_principal": str(cuantizar_cripto(cantidad_cripto_principal)),
        "precio_disparo": str(cuantizar_usd(precio_disparo)),
        "precio_limite": str(cuantizar_usd(precio_limite)) if precio_limite else None,
        "cantidad_reservada": str(cuantizar_cripto(cantidad_a_reservar)),
        "moneda_reservada": moneda_a_reservar,
        "estado": "pendiente"
    }
    agregar_orden_pendiente(nueva_orden)
    
    accion_texto = "Compra" if accion == ACCION_COMPRAR else "Venta"
    ticker_mostrado = moneda_destino if accion == ACCION_COMPRAR else moneda_origen
    
    resultado_operacion = {
        "titulo": f"Orden {tipo_orden.replace('-', ' ').title()} Creada",
        "tipo": tipo_orden,
        "detalles": {
            "accion": f"{accion_texto} de {formato_cantidad_cripto(cantidad_cripto_principal)} {ticker_mostrado}",
            "precio_disparo": formato_cantidad_usd(precio_disparo)
        }
    }
    return crear_respuesta_exitosa(resultado_operacion)

def procesar_operacion_trading(formulario: dict) -> Dict[str, Any]:
    """Punto de entrada principal para procesar una operación desde el formulario."""
    try:
        ticker_principal = formulario["ticker"].upper()
        accion = formulario["accion"]
        monto_form = a_decimal(formulario["monto"])
        modo_ingreso = formulario.get("modo-ingreso", "monto")
        tipo_orden = formulario.get("tipo-orden", "market").lower()
    except (KeyError, ValueError) as e:
        return crear_respuesta_error(f"❌ Error en los datos del formulario: {e}")

    if monto_form <= a_decimal(0): 
        return crear_respuesta_error("❌ El monto debe ser un número positivo.")

    moneda_origen, moneda_destino = (formulario.get("moneda-pago", "USDT").upper(), ticker_principal) if accion == ACCION_COMPRAR else (ticker_principal, formulario.get("moneda-recibir", "USDT").upper())
    if moneda_origen == moneda_destino: 
        return crear_respuesta_error("❌ La moneda de origen y destino no pueden ser la misma.")

    if tipo_orden == "market":
        return _ejecutar_orden_mercado(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion)
    
    elif tipo_orden in ["limit", "stop-limit"]:
        try:
            precio_disparo = a_decimal(formulario.get("precio_disparo"))
            if precio_disparo <= a_decimal(0): 
                return crear_respuesta_error("❌ Se requiere un precio de disparo válido y positivo.")
            
            precio_limite = None
            if tipo_orden == 'stop-limit':
                precio_limite = a_decimal(formulario.get("precio_limite"))
                if precio_limite <= a_decimal(0):
                    return crear_respuesta_error("❌ Se requiere un precio límite válido y positivo para una orden Stop-Limit.")

        except (KeyError, ValueError, TypeError):
            return crear_respuesta_error("❌ Precio de disparo o límite inválido o faltante.")
        
        return _crear_orden_pendiente(
            moneda_origen, 
            moneda_destino, 
            monto_form, 
            modo_ingreso, 
            precio_disparo, 
            tipo_orden, 
            accion, 
            precio_limite
        )
    
    else:
        return crear_respuesta_error(f"Tipo de orden '{tipo_orden}' no soportado.")

==================================================
=== ARCHIVO: ./backend/utils/formatters.py ===
==================================================

"""
Utilidades de formateo para la presentación de datos no numéricos.

Este módulo proporciona un conjunto de funciones reutilizables para dar formato a
diversos tipos de datos como fechas y otros indicadores de UI.
La lógica de formateo numérico se ha movido a `utils.number_utils`.
"""

from datetime import datetime
from decimal import Decimal
from typing import Union


def get_performance_indicator(value: Union[str, Decimal]) -> dict:
    """
    Analiza un valor de rendimiento y devuelve un diccionario con la clase CSS y
    el símbolo de flecha correspondiente.

    Args:
        value (Union[str, Decimal]): El valor de rendimiento.

    Returns:
        dict: Un diccionario con las claves 'className' y 'arrow'.
    """
    try:
        valor_decimal = Decimal(str(value))
        if valor_decimal >= 0:
            return {"className": "positivo", "arrow": "▲"}
        return {"className": "negativo", "arrow": "▼"}
    except (ValueError, TypeError, InvalidOperation):
        return {"className": "", "arrow": ""}


def format_datetime(timestamp: Union[int, float, str]) -> str:
    """
    Formatea un timestamp o un string ISO a una fecha y hora local.

    Maneja tanto timestamps numéricos (segundos desde la época) como strings
    de fecha en formato ISO 8601.

    Args:
        timestamp: El timestamp o string a formatear.

    Returns:
        La fecha y hora formateada. Ej: "21/06/2024 15:45:12".
    """
    if not timestamp:
        return "--:--"
    
    try:
        if isinstance(timestamp, (int, float)):
            dt_object = datetime.fromtimestamp(timestamp)
        elif isinstance(timestamp, str):
            dt_object = datetime.fromisoformat(timestamp)
        else:
            return "--:--"
            
        return dt_object.strftime("%d/%m/%Y %H:%M:%S")
    except (ValueError, TypeError):
        return "--:--"

==================================================
=== ARCHIVO: ./backend/utils/responses.py ===
==================================================

"""
Utilidades para estandarizar las respuestas de los servicios.
"""

def crear_respuesta_exitosa(datos, mensaje=""):
    """Crea una respuesta estandarizada para operaciones exitosas."""
    return {"estado": "ok", "datos": datos, "mensaje": mensaje}

def crear_respuesta_error(mensaje):
    """Crea una respuesta estandarizada para operaciones fallidas."""
    return {"estado": "error", "mensaje": mensaje}


==================================================
=== ARCHIVO: ./backend/utils/utilidades_numericas.py ===
==================================================

# backend/utils/utilidades_numericas.py

"""
Módulo de Utilidades Numéricas.

Este módulo centraliza todas las operaciones relacionadas con la manipulación
de números en la aplicación, especialmente para garantizar la consistencia
y precisión al trabajar con la librería `Decimal`.
"""

from decimal import Decimal, InvalidOperation

from config import PRECISION_CRIPTOMONEDA, PRECISION_USD


def a_decimal(valor) -> Decimal:
    """
    Convierte de forma segura un valor a un objeto Decimal.
    """
    if valor is None:
        return Decimal("0")
    try:
        return Decimal(str(valor))
    except (InvalidOperation, TypeError, ValueError):
        return Decimal("0")

def cuantizar_cripto(valor: Decimal) -> Decimal:
    """
    Cuantiza un valor Decimal a la precisión estándar para criptomonedas.
    """
    return valor.quantize(PRECISION_CRIPTOMONEDA)

def cuantizar_usd(valor: Decimal) -> Decimal:
    """
    Cuantiza un valor Decimal a la precisión estándar para USD.
    """
    return valor.quantize(PRECISION_USD)


# --- Funciones de Formateo para Presentación (Versión Final) ---

def formato_cantidad_cripto(valor: Decimal) -> str:
    """
    Formatea una cantidad de criptomoneda con separadores de miles
    y elimina ceros decimales innecesarios.
    """
    valor_q = cuantizar_cripto(valor)
    # El carácter "," es la clave para los separadores de miles.
    precision = abs(PRECISION_CRIPTOMONEDA.as_tuple().exponent)
    string_formateado = f"{valor_q:,.{precision}f}"
    
    if '.' in string_formateado:
        string_formateado = string_formateado.rstrip('0').rstrip('.')
        
    return string_formateado

def formato_cantidad_usd(valor: Decimal, simbolo: str = "$") -> str:
    """
    Formatea un valor monetario en USD con separadores de miles
    y elimina ceros decimales innecesarios.
    """
    valor_q = cuantizar_usd(valor)
    # El carácter "," es la clave para los separadores de miles.
    precision = abs(PRECISION_USD.as_tuple().exponent)
    string_formateado = f"{valor_q:,.{precision}f}"
    
    if '.' in string_formateado:
        string_formateado = string_formateado.rstrip('0').rstrip('.')
        
    return f"{simbolo}{string_formateado}"

def formato_numero_grande(valor: Decimal, simbolo: str = "$") -> str:
    """
    Formatea números grandes con abreviaturas (M, B, T).
    Para números menores a 1 millón, usa el formato USD estándar.
    """
    numero = a_decimal(valor)

    if numero >= 1_000_000_000_000:
        return f"{simbolo}{(numero / Decimal('1e12')).quantize(Decimal('0.01'))}T"
    if numero >= 1_000_000_000:
        return f"{simbolo}{(numero / Decimal('1e9')).quantize(Decimal('0.01'))}B"
    if numero >= 1_000_000:
        return f"{simbolo}{(numero / Decimal('1e6')).quantize(Decimal('0.01'))}M"
    
    # Para números por debajo de 1 millón, usamos el formato USD con comas.
    return formato_cantidad_usd(numero, simbolo)

def formato_porcentaje(valor: Decimal) -> str:
    """
    Formatea un número como un porcentaje con dos decimales.
    """
    return f"{a_decimal(valor):.2f}%"

==================================================
=== ARCHIVO: ./config.py ===
==================================================

import os

# --- CONSTANTES DE LA APLICACIÓN ---
# Acciones de Trading
ACCION_COMPRAR = "comprar"
ACCION_VENDER = "vender"

# Tipos de Órdenes
TIPO_ORDEN_MERCADO = "market"
TIPO_ORDEN_LIMITE = "limit"
TIPO_ORDEN_STOP_LIMIT = "stop-limit"

# Estados de Órdenes
ESTADO_PENDIENTE = "pendiente"
ESTADO_EJECUTADA = "ejecutada"
ESTADO_CANCELADA = "cancelada"
ESTADO_ERROR = "error"
from decimal import getcontext, ROUND_HALF_DOWN, Decimal
from dotenv import load_dotenv

# Cargar variables de entorno desde el archivo .env
load_dotenv()

# Base del proyecto y carpeta de datos
PROYECTO_DIR = os.path.dirname(os.path.abspath(__file__))
BASE_DATA_DIR = os.path.join(PROYECTO_DIR, "datos")
os.makedirs(BASE_DATA_DIR, exist_ok=True)

# Rutas de archivos JSON
COTIZACIONES_PATH = os.path.join(BASE_DATA_DIR, "cotizaciones.json")
BILLETERA_PATH = os.path.join(BASE_DATA_DIR, "billetera.json")
HISTORIAL_PATH = os.path.join(BASE_DATA_DIR, "historial.json")
VELAS_PATH = os.path.join(BASE_DATA_DIR, "velas.json")
COMISIONES_PATH = os.path.join(BASE_DATA_DIR, "comisiones.json")
ORDENES_PENDIENTES_PATH = os.path.join(BASE_DATA_DIR, "ordenes_pendientes.json")

# Configuración inicial de los USDT con los cuales inicializa la app
BALANCE_INICIAL_USDT = "10000"

# Comisión por trade
TASA_COMISION = Decimal("0.005")  # 0.5% de comisión

# Clave secreta para Flask
FLASK_SECRET_KEY = os.getenv("FLASK_SECRET_KEY", "clave_por_defecto_insegura")

# URLs de APIs
COINGECKO_URL = "https://api.coingecko.com/api/v3/coins/markets"
BINANCE_URL = "https://api.binance.com/api/v3/klines"

# Parámetros de scraping
CANTIDAD_CRIPTOMONEDAS = 100
CANTIDAD_VELAS = 250

# --- CONFIGURACIÓN NUMÉRICA GLOBAL --- ### NUEVO ###
# Precisión para los cálculos intermedios de la librería Decimal
getcontext().prec = 28
getcontext().rounding = ROUND_HALF_DOWN

# Precisión estándar para el almacenamiento y la visualización
# de cantidades de criptomonedas (8 decimales)
PRECISION_CRIPTOMONEDA = Decimal("0.00000001")

# Precisión de decimales 4 para valores en USD
PRECISION_USD = Decimal("0.0001")

# Umbrales para la lógica de "polvo" (saldos pequeños)
UMBRAL_POLVO_USD = Decimal("0.01") # Valor en USD por debajo del cual se considera polvo
UMBRAL_CASI_CERO = Decimal("0.00000001") # Cantidad por debajo de la cual se considera cero para ciertas validaciones


==================================================
=== ARCHIVO: ./documentacion.md ===
==================================================

¡Excelente! Ahora que has completado la refactorización, es el momento perfecto para dar un paso atrás y consolidar el conocimiento sobre la nueva arquitectura. Has transformado tu proyecto en un sistema mucho más robusto y profesional.

Basándome en el código finalizado y en la estructura de tu `documentacion.md`, he preparado una explicación actualizada y detallada de la arquitectura y las responsabilidades de cada componente.

---

### **Diagrama de Arquitectura Actualizado: "BlocX - Simulador de Exchange"**

Este diagrama refleja la nueva estructura, destacando la especialización dentro del paquete de servicios de trading.

```
+-----------------------------------------------------------------------------------------------------------------------+
|                                                  NAVEGADOR DEL USUARIO                                                |
|      - Renderiza HTML/CSS, ejecuta JS.                                                                                |
|      - Envía acciones del usuario (formularios, clics) al Backend.                                                    |
|      - Muestra notificaciones de SweetAlert2 construidas desde datos JSON.                                            |
+------------------------------------------+--------------------------------------------------+-------------------------+
                                           |                                                  |                         ^
 (1) Petición inicial (GET /trading)       | (16) Muestra UI actualizada                      | (3) Sirve HTML inicial  |
                                           |      con datos de la API                         |                         |
                                           v                                                  |                         |
+------------------------------------------+--------------------------------------------------+-------------------------+
|                                                      FRONTEND (Cliente)                                               |
|                                            (Se ejecuta completamente en el navegador)                                   |
|-----------------------------------------------------------------------------------------------------------------------|
| HTML: /templates/                                                                                                     |
|  - _flashes.html: Componente JS-HTML que parsea JSON y renderiza notificaciones.                                       |
|                                                                                                                       |
| JS: /static/js/                                                                                                       |
|                                                                                                                       |
|  (4) Inicia lógica (pages/tradingPage.js)  (14) Recibe JSON, actualiza DOM     (18) Muestra Toast/Popup                  |
|            +                                     |                                     ^                               |
|            |     +-----------------------------+ v                                     |                               |
|            +---> |   pages/*.js                | --(15) Llama a componentes--->+---------------------------------+    |
|                  |   - Orquesta la página.     |                               |    components/*.js              |    |
|                  |   - Llama a servicios.      |                               |    (uiUpdater, chartRenderer)   |    |
|                  +------------+----------------+                               +------------------^--------------+    |
|                               | (5, 17) Solicita datos a API                                      |                  |
|                               v                                                                                     |
|                  +-----------------------------+  (13) Devuelve JSON          +------------------------------------+  |
|                  |  services/apiService.js     | <--------------------------+ |  services/appState.js              |  |
|                  |  - Centraliza llamadas      |                              |  - Gestiona el estado global (JS)  |  |
|                  |    fetch() al backend.      |                              |                                    |  |
|                  +-----------------------------+                              +------------------------------------+  |
|                               | (6) Petición HTTP (POST /trading/operar, POST /api/orden/cancelar/...)                 |
+-------------------------------v-------------------------------------------------------------------------------------+
                                | (A) Recibe POST /trading/operar                                                       (2) Sirve HTML
                                | (B) Recibe POST /api/orden/cancelar/...                                               (vía render_template)
                                | (C) Recibe GET /api/actualizar
+-------------------------------v-------------------------------------------------------------------------------------+
|                                                       BACKEND (Servidor)                                            |
|                                                 (Aplicación Flask - Python)                                         |
|---------------------------------------------------------------------------------------------------------------------|
| __init__.py -> app.py                                                                                               |
| - Inicia la app Flask y registra las rutas.                                                                         |
|                                                                                                                     |
| +-----------------------------------------------------------------------------------------------------------------+ |
| |                                            RUTAS (Capa de Vistas)                                               | |
| | /rutas/*.py (trading_vista.py, billetera_vista.py, api_externa.py)                                              | |
| | - Definen los endpoints (URL).                                                                                  | |
| | - (A, B, C) Delegan la lógica a la capa de Servicios.                                                           | |
| | - Devuelven JSON (para /api/...) o HTML (para rutas base).                                                      | |
| +--------------------------------------------------------+--+-----------------------------------------------------+ |
|                                                          |  |  (C.1) Llama a motor                                  |
|                                     (A.1) Llama a procesador |  (B.1) Llama a gestor                                |
|                                                          v  v                                                      |
| +--------------------------------------------------------+--+-----------------------------------------------------+ |
| |                                     SERVICIOS (Capa de Lógica de Negocio)                                       | |
| | /servicios/*.py (estado_billetera.py, api_cotizaciones.py)                                                      | |
| |                                                                                                                 | |
| | +-------------------------------------------------------------------------------------------------------------+ | |
| | |                                            /servicios/trading/                                              | | |
| | | - procesador.py: El "Recepcionista". Valida y CREA órdenes.                                                 | | |
| | | - motor.py: El "Vigilante". VERIFICA condiciones de órdenes pendientes.                                     | | |
| | | - gestor.py: El "Administrador". GESTIONA órdenes existentes (ej. cancelar).                               | | |
| | | - ejecutor.py: El "Brazo Ejecutor". EJECUTA la transacción atómica (comisión, saldos, historial).          | | |
| | +---------------------------------------------------------+---------------------------------------------------+ | |
| |                                                           | (D) Llama a ejecutor para completar la transacción    |
| +-----------------------------------------------------------v-----------------------------------------------------+ |
|                                                             | (E) Pide/guarda datos crudos                          |
|                                                             v                                                       |
| +-----------------------------------------------------------+-----------------------------------------------------+ |
| |                              ACCESO A DATOS (Capa de Persistencia)                                              | |
| | /acceso_datos/*.py (datos_billetera.py, datos_ordenes.py, etc.)                                                 | |
| | - Leen y escriben en los archivos .json.                                                                        | |
| | - Abstraen el manejo de archivos.                                                                               | |
| +---------------------+-------------------------------------+-----------------------------------------------------+ |
|                       |                                     |                                                       |
|             (F) Lee/Escribe                                 | (G) Lee/Escribe                                       |
|                       v                                     v                                                       |
| +---------------------+---------+  +------------------------+-------+  +--------------------------+  +----------------+
| | billetera.json, historial.json|  | ordenes_pendientes.json        |  | cotizaciones.json        |  | comisiones.json|
| +-------------------------------+  +--------------------------------+  +--------------------------+  +----------------+
+---------------------------------------------------------------------------------------------------------------------+

```

### **Glosario de Componentes y Responsabilidades Actualizado**

Aquí desglosamos qué hace cada parte del sistema en su estado actual y refactorizado.

#### **1. Backend (`/backend`)**

Es el cerebro del sistema. Su única responsabilidad es gestionar la lógica de negocio y exponer los datos a través de una API que habla en JSON. **No sabe ni le importa cómo se ve la página web.**

*   **Rutas (`/rutas`)**: Son los **"Controladores de Tráfico"**.
    *   **Responsabilidad**: Definen las URLs (endpoints) que el frontend puede llamar. Reciben las peticiones HTTP, validan los parámetros más básicos y delegan inmediatamente el trabajo a la capa de Servicios.
    *   **Ejemplo**: `trading_vista.py` recibe el `POST` del formulario de trading, pero no sabe qué es una orden de mercado; simplemente llama a `procesar_operacion_trading()` en el servicio correspondiente. Luego, toma la respuesta (un diccionario o un error) y la formatea como JSON o la pasa al sistema de `flash`.

*   **Acceso a Datos (`/acceso_datos`)**: Son los **"Bibliotecarios"**.
    *   **Responsabilidad**: Son los únicos que saben leer y escribir en los archivos `.json`. Aíslan al resto de la aplicación del "cómo" se guardan los datos. Si mañana decidieras cambiar de archivos JSON a una base de datos en memoria, solo tendrías que modificar esta capa.
    *   **Ejemplo**: `datos_billetera.py` tiene las funciones `cargar_billetera()` y `guardar_billetera()`. Nadie más en la aplicación toca `billetera.json` directamente.

*   **Servicios (`/servicios`)**: Es el **"Núcleo del Negocio"**. Aquí reside toda la inteligencia de la aplicación.
    *   **Responsabilidad**: Orquestar la lógica de negocio, realizar cálculos complejos, interactuar con APIs externas y preparar los datos para ser consumidos.
    *   **Ejemplo**: `estado_billetera.py` toma los datos crudos de la billetera y el historial (pedidos a `acceso_datos`), los cruza con los precios actuales y calcula el valor del portafolio, las ganancias/pérdidas, etc.
    *   **Subpaquete `servicios/trading/` (La Lógica de Trading Refactorizada)**: Este es el corazón de tu sistema y ahora tiene responsabilidades muy bien definidas:
        *   **`procesador.py` - El "Recepcionista"**: Es el punto de entrada para cualquier *intención de trading* que provenga de un usuario. Su trabajo es validar los datos de un formulario y **CREAR** una orden (ya sea para ejecución inmediata o para ponerla en espera).
        *   **`motor.py` - El "Vigilante del Mercado"**: Es un proceso *automatizado*. Su única misión es **VERIFICAR** periódicamente si alguna de las órdenes pendientes cumple las condiciones del mercado para ser ejecutada. No ejecuta nada por sí mismo; si una orden se debe disparar, le pasa la posta al `ejecutor`.
        *   **`gestor.py` - El "Administrador de Órdenes"**: Se encarga de **GESTIONAR** las órdenes que ya existen pero que no están siendo ejecutadas. Su principal función hoy es `cancelar_orden_pendiente`.
        *   **`ejecutor.py` - El "Brazo Ejecutor" o "Notario"**: Es la pieza más crítica y centralizada. Contiene la función `ejecutar_transaccion()`, que realiza una **transacción atómica**. Su única responsabilidad es tomar los detalles de una operación y **EJECUTARLA**: calcular la comisión, modificar los saldos, y registrarla en el historial. Es llamado tanto por el `procesador` (para órdenes de mercado) como por el `motor` (para órdenes pendientes).

#### **2. Frontend (`/frontend`)**

Es la cara visible de la aplicación. Es un cliente completamente dinámico que se ejecuta en el navegador.

*   **Templates (`/templates`)**: Son los **"Esqueletos HTML"**.
    *   **Responsabilidad**: Proveer la estructura HTML inicial de cada página. Son deliberadamente simples.
    *   **Ejemplo**: `trading.html` contiene los `divs` y `table` vacíos que actuarán como contenedores. `_flashes.html` es ahora un componente "inteligente" que ya no contiene HTML, sino un script que sabe cómo construir el HTML de la notificación a partir de los datos JSON que recibe.

*   **JS - Services (`/js/services`)**: Son los **"Módulos de Soporte"** del frontend.
    *   **Responsabilidad**: Proporcionar funcionalidades reutilizables para el resto del código JavaScript.
    *   **`apiService.js`**: El "Embajador". Centraliza todas las llamadas `fetch` a la API del backend.
    *   **`appState.js`**: El "Estado Global del Cliente". Guarda en memoria (del navegador) los datos que vienen de la API (como la lista de monedas o el estado de la billetera) para que otros componentes puedan acceder a ellos sin tener que pedirlos de nuevo.

*   **JS - Components (`/js/components`)**: Son los **"Especialistas de la UI"**.
    *   **Responsabilidad**: Cada módulo se encarga de una parte muy específica de la interfaz de usuario.
    *   **Ejemplo**: `chartRenderer.js` solo sabe de gráficos. `uiUpdater.js` solo sabe cómo cambiar el texto de las etiquetas o el color de los botones.

*   **JS - Pages (`/js/pages`)**: Son los **"Directores de Orquesta"** de cada página.
    *   **Responsabilidad**: Es el punto de entrada para la lógica de una página específica. Cuando se carga `trading.html`, `tradingPage.js` se ejecuta y comienza a orquestar todo: llama a `apiService` para traer los datos, los guarda en `appState` y luego usa los `components` para llenar la página con esa información.

#### **3. Persistencia (`/datos/*.json`)**

Son la **"Base de Datos"** de tu proyecto.
*   **Responsabilidad**: Almacenar el estado de la aplicación (la billetera, las órdenes, el historial) de forma que los datos persistan incluso si el servidor se reinicia. Son la "única fuente de verdad" del sistema.
*   



¡Excelente pregunta! Seguir el flujo de una operación de principio a fin es la mejor manera de entender cómo todas las piezas del sistema encajan. Aquí tienes el recorrido detallado, paso a paso, sin asumir nada, desde que abres el navegador hasta que la compra se concreta.

### **Escenario: Comprar $100 de BTC a Precio de Mercado**

---

#### **Fase 1: Carga Inicial de la Página de Trading**

1.  **Paso 1: Abrir el Navegador**
    *   Escribes `http://127.0.0.1:5000/` en tu navegador y presionas Enter. Por defecto, Flask te redirigirá (o la ruta `/` ya apunta) a la página de cotizaciones (`index.html`). Haces clic en el enlace "Trading" en la barra de navegación. La URL cambia a `http://127.0.0.1:5000/trading`.

2.  **Paso 2: Petición HTTP al Backend (GET)**
    *   Tu navegador envía una petición `GET` al servidor Flask, solicitando el recurso en la ruta `/trading`.

3.  **Paso 3: El Backend Responde (Capa de Rutas)**
    *   Flask recibe la petición. El archivo `backend/rutas/trading_vista.py` tiene una función `mostrar_trading_page()` asociada a la ruta `/trading`.
    *   Esta función ejecuta `render_template("trading.html")`. Flask toma este archivo de plantilla, lo procesa (incluyendo el `_flashes.html`, que en este punto no tiene mensajes) y lo devuelve al navegador como una respuesta HTML.

4.  **Paso 4: El Frontend Cobra Vida (HTML y JS)**
    *   El navegador recibe el archivo HTML. Es un "esqueleto": contiene la estructura, los `divs` para el gráfico, el formulario y las tablas, pero están casi todos vacíos o con mensajes de "Cargando...".
    *   El navegador parsea el HTML y, al final, encuentra la línea `<script type="module" src=".../tradingPage.js"></script>`. Inmediatamente, descarga y ejecuta este archivo JavaScript.

5.  **Paso 5: Orquestación del Frontend (`tradingPage.js`)**
    *   Se ejecuta la función `initialize()` dentro de `tradingPage.js`.
    *   Esta función es el "director de orquesta". Sabe que necesita muchos datos para llenar la página, así que usa `Promise.all` para hacer varias peticiones a la API del backend de forma concurrente, a través de las funciones en `apiService.js`:
        *   `fetchCotizaciones()` -> `GET /api/cotizaciones`
        *   `fetchEstadoBilletera()` -> `GET /api/billetera/estado-completo`
        *   `fetchHistorial()` -> `GET /api/historial`
        *   `fetchOrdenesAbiertas()` -> `GET /api/ordenes-abiertas`
        *   `fetchVelas('BTC', '1d')` -> `GET /api/velas/BTC/1d` (asumiendo BTC como default)

6.  **Paso 6: El Backend Sirve los Datos (Servicios y Acceso a Datos)**
    *   Para cada una de esas peticiones GET, el backend realiza un ciclo:
        *   La **Ruta** (ej. `api_externa.py`) recibe la petición.
        *   Llama al **Servicio** correspondiente (ej. `presentacion_datos.py` o `estado_billetera.py`).
        *   El **Servicio** pide los datos crudos a la capa de **Acceso a Datos** (ej. `datos_cotizaciones.py` lee `cotizaciones.json`).
        *   El **Servicio** procesa, calcula y formatea los datos.
        *   La **Ruta** toma los datos procesados y los devuelve como una respuesta JSON.

7.  **Paso 7: El Frontend Renderiza la Página**
    *   De vuelta en `tradingPage.js`, las promesas de `Promise.all` se resuelven. El script ahora tiene todos los datos que necesita.
    *   Guarda estos datos en el estado global del cliente (`AppState.js`).
    *   Llama a los componentes "especialistas":
        *   `UIUpdater.renderHistorial()` para construir la tabla de historial.
        *   `initializeChart()` para dibujar el gráfico de velas.
        *   `actualizarFormularioUI()` para rellenar los selectores de criptomonedas y mostrar tu saldo inicial de USDT.
    *   **Resultado visual**: La página está completamente cargada. Ves el gráfico de BTC, el formulario de trading y tus saldos.

---

#### **Fase 2: Interacción del Usuario y Envío del Formulario**

8.  **Paso 8: Configurar la Operación**
    *   En el formulario de trading, seleccionas "BTC" (si no estaba ya por defecto).
    *   El modo "Comprar" está activado por defecto.
    *   El tipo de orden "Mercado" está activado por defecto.
    *   Seleccionas el modo de ingreso "Total (USDT)". El script `tradingPage.js` detecta este cambio (`radioModoIngreso.on('change', ...)` ) y, a través de `UIUpdater.js`, actualiza la etiqueta del campo de monto a "Total (USDT)".
    *   En el campo de monto, escribes `100`.

9.  **Paso 9: Confirmar la Compra**
    *   Haces clic en el botón "COMPRAR".
    *   Esto dispara el evento `submit` del formulario `<form id="formulario-trading" ...>`.

10. **Paso 10: Petición HTTP al Backend (POST)**
    *   El navegador empaqueta todos los datos del formulario (ticker: 'BTC', accion: 'comprar', tipo-orden: 'market', modo-ingreso: 'total', monto: '100', moneda-pago: 'USDT') y envía una petición `POST` a la URL especificada en el `action` del formulario: `/trading/operar`.

---

#### **Fase 3: Procesamiento de la Operación en el Backend**

11. **Paso 11: La Ruta Recibe la Petición**
    *   Flask recibe el `POST`. La función `procesar_trading_form()` en `backend/rutas/trading_vista.py` se ejecuta.

12. **Paso 12: Delegación al Servicio Procesador**
    *   La ruta no sabe cómo procesar un trade. Delega inmediatamente todo el trabajo llamando a `procesar_operacion_trading(request.form)` en `backend/servicios/trading/procesador.py`.

13. **Paso 13: El Procesador Analiza la Orden**
    *   `procesar_operacion_trading` recibe el diccionario del formulario.
    *   Valida los datos: el monto es positivo, las monedas de origen (USDT) y destino (BTC) no son la misma.
    *   Detecta que `tipo_orden` es "market", por lo que llama a su función auxiliar `_ejecutar_orden_mercado(...)`.

14. **Paso 14: Orquestación de la Orden de Mercado**
    *   `_ejecutar_orden_mercado` comienza su trabajo:
        a.  Llama a `obtener_precio('USDT')` y `obtener_precio('BTC')` desde `datos_cotizaciones.py`. Supongamos que BTC está a $50,000.
        b.  Llama a su función de cálculo pura: `_calcular_detalles_intercambio('comprar', 'total', 100, 1, 50000)`. Esta función devuelve `{ "cantidad_origen_bruta": 100, "cantidad_destino_bruta": 0.002, ... }`.
        c.  Carga tu billetera actual usando `cargar_billetera()`.
        d.  Valida si tienes saldo suficiente con `_validar_saldo_disponible(billetera, 'USDT', 100)`. Como tienes $10,000 iniciales, la validación es exitosa.

15. **Paso 15: La Ejecución Atómica**
    *   Ahora, `_ejecutar_orden_mercado` tiene todo lo que necesita. Llama a la función centralizada `ejecutar_transaccion()` del módulo `ejecutor.py`, pasándole todos los detalles.
    *   Dentro de `ejecutar_transaccion()`:
        a.  **Cálculo de Comisión**: `cantidad_comision = 100 (USDT) * 0.005 = 0.5 USDT`.
        b.  **Cálculo Neto**: La cantidad neta de origen que se usará para el intercambio es `100 - 0.5 = 99.5 USDT`.
        c.  **Cálculo Final**: La cantidad final de BTC que recibirás es `99.5 / 50000 = 0.00199 BTC`.
        d.  **Modificación de Billetera (en memoria)**:
            *   Resta 100 del saldo `disponible` de USDT.
            *   Suma 0.00199 al saldo `disponible` de BTC.
        e.  **Registro de Comisión**: Llama a `registrar_comision()` en `datos_comisiones.py`, que abre `comisiones.json` y añade la nueva línea.
        f.  **Registro de Historial**: Llama a `guardar_en_historial()` en `datos_historial.py`, que abre `historial.json` y añade el registro de la compra.
        g.  Devuelve un diccionario con los detalles de la ejecución a `_ejecutar_orden_mercado`.

16. **Paso 16: Finalización y Respuesta**
    *   `_ejecutar_orden_mercado` recibe la confirmación de éxito del ejecutor.
    *   Llama a `guardar_billetera(billetera)`, que abre `billetera.json` y **sobrescribe el archivo completo** con los nuevos saldos.
    *   Construye el diccionario de respuesta final para el frontend: `{"titulo": "Operación de Mercado Exitosa", "tipo": "mercado", "detalles": {...}}`.
    *   Este diccionario se devuelve a `procesar_operacion_trading`.
    *   `procesar_operacion_trading` lo devuelve a la ruta `procesar_trading_form`.

---

#### **Fase 4: Redirección y Notificación al Usuario**

17. **Paso 17: El Sistema de "Flashes" de Flask**
    *   La ruta `procesar_trading_form` tiene la tupla `(True, diccionario_resultado)`.
    *   Como fue exitosa, convierte el diccionario a un string JSON usando `json.dumps()`.
    *   Llama a `flash(json_string, "success")`. Flask guarda este mensaje en una cookie de sesión temporal.
    *   Finalmente, ejecuta `return redirect(url_for('trading.mostrar_trading_page', ticker='BTC'))`.

18. **Paso 18: Nueva Petición y Renderizado**
    *   El navegador recibe la respuesta de redirección (código 302). Inmediatamente hace una **nueva petición `GET`** a `http://127.0.0.1:5000/trading?ticker=BTC`.
    *   El ciclo de carga de la página (Pasos 3 a 7) se repite. La página se carga de nuevo desde cero, pero esta vez, cuando `render_template` procesa `_flashes.html`, detecta que hay un mensaje en la sesión.

19. **Paso 19: Notificación en el Frontend**
    *   El script dentro de `_flashes.html` se ejecuta.
    *   Parsea el string JSON del mensaje flash de vuelta a un objeto JavaScript.
    *   Llama a la función `buildFlashMessageHTML()` para construir el HTML de la notificación.
    *   Usa `Toast.fire()` de SweetAlert2 para mostrar una notificación emergente en la esquina superior derecha con el resumen de la operación: "Recibiste: 0.00199000 BTC", "Pagaste: 100.00000000 USDT", etc.

20. **Paso 20: Visualización del Estado Actualizado**
    *   Como la página se recargó, las llamadas a la API en el `initialize()` de `tradingPage.js` traen los datos actualizados.
    *   La llamada a `fetchEstadoBilletera()` ahora devolverá un estado de billetera que incluye BTC.
    *   La llamada a `fetchHistorial()` incluirá la nueva transacción.
    *   El frontend renderiza las tablas con la información nueva. **Ya tienes oficialmente tus $100 (menos comisión) en BTC.**

¡Y así concluye el ciclo completo de una operación! Cada capa tiene una responsabilidad clara, y el flujo de datos entre el cliente y el servidor es predecible y robusto.

==================================================
=== ARCHIVO: ./frontend/static/css/styles_index.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030;
    color: #f0c000;
}

.logo-cripto {
    margin-right: 1.5rem;
    vertical-align: middle;
}

.nombre-cripto {
    padding-left: 0.75rem;
    font-weight: bold;
    font-size: 1.05rem;
}

.logo-cripto {
    margin-right: 10px;
    vertical-align: middle;
}

.ticker-cripto {
    color: #aaaaaa;
    font-size: 0.85rem;
    margin-left: 4px;
}

table thead th {
    font-size: 0.85rem;
    font-weight: 500;
    text-transform: uppercase;
}

td,
th {
    white-space: nowrap;
}

/* PRECIO */
table td:nth-child(3),
table th:nth-child(3) {
    min-width: 100px;
    font-weight: bold;
}
table td:nth-child(4),
table th:nth-child(4),
table td:nth-child(5),
table th:nth-child(5),
table td:nth-child(6),
table th:nth-child(6) {
    min-width: 80px; /* 1H, 24H, 7D */
}
table td:nth-child(8),
table th:nth-child(8),
table td:nth-child(9),
table th:nth-child(9) {
    min-width: 100px; /* VOLUME, SUPPLY */
}

/* Limita el ancho de la columna Name (columna 2) */
table td:nth-child(2),
table th:nth-child(2) {
    max-width: 220px; /* probá ajustar este valor */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.positivo {
    color: var(--color-verde);
    font-weight: 500;
}

.negativo {
    color: var(--color-rojo);
    font-weight: 500;
}

.flecha-verde,
.flecha-roja {
    font-size: 0.7em; /* más pequeño que el texto base */
    vertical-align: middle;
    margin-right: 4px;
}

.flecha-verde {
    color: var(--color-verde);
    margin-right: 4px;
}

.flecha-roja {
    color: var(--color-rojo);
    margin-right: 4px;
}


==================================================
=== ARCHIVO: ./frontend/static/css/styles_trading.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
    --color-azul-activo: #0d6efd; /* Azul de Bootstrap para botones activos */
    --color-fondo-base: #343a40; /* Un gris oscuro para fondos de input/select */
    --color-borde: #6c757d; /* Un gris más claro para bordes */
    --color-texto: #f8f9fa; /* Texto casi blanco */
    --border-radius-suave: 0.375rem; /* El radio de borde por defecto de Bootstrap */
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #1e1e1e !important; /* Un fondo un poco más oscuro que antes */
    color: #f0c000;
}

#chart {
    display: block;
    overflow: hidden;
    width: 100%;
    max-width: 100%;
    min-height: 500px;
}

/* --- ESTILOS UNIFICADOS PARA EL FORMULARIO --- */

/* Estilo base para todos los controles de formulario */
.form-control,
.form-select,
.select2-container--bootstrap-5 .select2-selection {
    background-color: var(--color-fondo-base) !important;
    color: var(--color-texto) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave) !important;
    box-shadow: none !important; /* Eliminar sombras por defecto */
}

/* Placeholder text color */
.form-control::placeholder {
    color: #999;
}

/* Estilo para los grupos de botones (Tipo de orden, Ingresar por, Timeframes) */
.btn-group .btn-outline-primary,
.btn-group .btn-outline-secondary {
    color: var(--color-texto);
    border-color: var(--color-borde);
}

/* Estilo para el botón ACTIVO en los grupos */
.btn-group .btn-check:checked + .btn-outline-primary,
.btn-group .btn.active {
    background-color: var(--color-azul-activo);
    border-color: var(--color-azul-activo);
    color: var(--color-texto);
}
.btn-group .timeframe-btn.active {
    background-color: var(--color-azul-activo) !important;
    border-color: var(--color-azul-activo) !important;
}

/* --- ESTILOS PERSONALIZADOS PARA SELECT2 --- */

/* Contenedor principal de Select2 */
.select2-container--bootstrap-5 .select2-selection {
    height: calc(1.5em + 0.75rem + 2px); /* Altura estándar de Bootstrap */
    padding: 0.375rem 0.75rem;
    line-height: 1.5;
}

/* Flecha del dropdown de Select2 */
.select2-container--bootstrap-5 .select2-selection__arrow b {
    border-color: var(--color-texto) transparent transparent transparent !important;
}

/* Estilos para el Dropdown (la lista que se abre) */
.select2-dropdown {
    background-color: var(--color-fondo-base) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave) !important;
}

/* Campo de búsqueda dentro del dropdown */
.select2-search__field {
    background-color: #495057 !important;
    color: var(--color-texto) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave);
}

/* Opciones de la lista */
.select2-results__option {
    color: var(--color-texto) !important;
}

/* Opción seleccionada actualmente en la lista */
.select2-results__option--selected {
    background-color: #5a6268 !important;
}

/* Opción bajo el cursor del ratón (hover) */
.select2-results__option--highlighted {
    background-color: var(--color-azul-activo) !important;
    color: var(--color-texto) !important;
}

/* --- LÓGICA DE BOTONES DE COMPRA/VENTA (SIN CAMBIOS DE LÓGICA, SÓLO ESTÉTICA) --- */
.boton-comprar.active {
    background-color: var(--color-verde) !important;
    border-color: var(--color-verde) !important;
}
.boton-vender.active {
    background-color: var(--color-rojo) !important;
    border-color: var(--color-rojo) !important;
}
.btn-outline-secondary {
    background-color: transparent;
    border-color: var(--color-borde);
}
.btn-outline-secondary:hover {
    background-color: var(--color-fondo-base);
}

/* --- OVERLAY DE ERROR (SIN CAMBIOS) --- */
.chart-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(30, 30, 30, 0.85);
    color: #f0c000;
    font-size: 1.2rem;
    font-weight: 500;
    text-align: center;
    padding: 20px;
    z-index: 10;
    border-radius: 8px;
    transition: opacity 0.3s ease-in-out;
}

.select2-container--bootstrap-5 .select2-selection--single .select2-selection__rendered,
.form-control::placeholder {
    color: var(--color-texto) !important;
}


.swal2-toast .swal2-close {
    font-size: 1.5rem;
    color: #b0b0b0;
    transition: color 0.2s ease;
    
    outline: none !important;
    box-shadow: none !important;
}

.swal2-toast .swal2-close:hover {
    color: #ffffff;
    transform: none;
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/chartRenderer.js ===
==================================================

/**
 * @module chartRenderer
 * @description Gestiona la creación, inicialización y actualización del gráfico financiero
 * de velas utilizando la biblioteca Lightweight Charts™.
 * Este módulo es responsable de todas las interacciones directas con la instancia del gráfico.
 */

// Variables globales para mantener las instancias del gráfico y sus series.
let chart;
let candleSeries;
let volumeSeries;

/**
 * @typedef {object} CandleData
 * @property {string} time - Marca de tiempo en formato 'YYYY-MM-DD'.
 * @property {number} open - Precio de apertura.
 * @property {number} high - Precio máximo.
 * @property {number} low - Precio mínimo.
 * @property {number} close - Precio de cierre.
 * @property {number} volume - Volumen de la operación.
 */

/**
 * Crea e inicializa el gráfico de velas en la primera carga.
 * Configura la apariencia del gráfico, añade las series de velas y volumen,
 * y establece los listeners de eventos para la interactividad.
 *
 * @param {CandleData[]} initialData - El conjunto de datos inicial de velas para mostrar.
 * @side-effects Manipula el DOM para crear el gráfico dentro del elemento '#chart'.
 *               También adjunta un ResizeObserver para manejar el redimensionamiento responsivo.
 */
export function initializeChart(initialData) {
    const chartContainer = document.getElementById('chart');
    if (!chartContainer) {
        console.warn("Elemento #chart no encontrado. No se puede renderizar el gráfico.");
        return;
    }
    if (!window.LightweightCharts) {
        console.error("La biblioteca LightweightCharts no está cargada.");
        return;
    }

    // Crea la instancia principal del gráfico con estilos personalizados.
    chart = window.LightweightCharts.createChart(chartContainer, {
        width: chartContainer.clientWidth,
        height: 500,
        layout: { textColor: '#ccc', background: { type: 'solid', color: '#1E1E1E' } },
        grid: { vertLines: { color: '#2B2B2B' }, horzLines: { color: '#2B2B2B' } },
        priceScale: { borderColor: '#485c7b' },
        timeScale: { borderColor: '#485c7b' },
    });

    // Añade la serie principal de velas para la acción del precio.
    candleSeries = chart.addCandlestickSeries({
        upColor: 'rgb(31, 191, 113)',
        downColor: 'rgb(226, 33, 52)',
        borderDownColor: 'rgb(226, 33, 52)',
        borderUpColor: 'rgb(31, 191, 113)',
        wickDownColor: '#838ca1',
        wickUpColor: '#838ca1',
    });

    // Añade una serie secundaria de histograma para el volumen de operaciones.
    volumeSeries = chart.addHistogramSeries({
        priceFormat: { type: 'volume' },
        priceScaleId: '', // Se adjunta a una escala de precios separada.
    });
    // Ajusta la escala de precios de la serie de volumen para darle más espacio.
    volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });

    if (initialData && initialData.length > 0) {
        updateChartData(initialData);
    }

    // Añade un listener de eventos al checkbox para alternar la visibilidad del volumen.
    const volumeCheckbox = document.getElementById('toggleVolume');
    if (volumeCheckbox) {
        volumeCheckbox.addEventListener('change', (e) => {
            volumeSeries.applyOptions({ visible: e.target.checked });
        });
    }

    // Asegura que el gráfico se ajuste a su contenido y sea responsivo.
    chart.timeScale().fitContent();
    new ResizeObserver(() => chart.applyOptions({ width: chartContainer.clientWidth })).observe(chartContainer);
}

/**
 * Actualiza el gráfico con un nuevo conjunto de datos de velas.
 * Maneja tanto el caso en que hay datos disponibles como en el que no, mostrando
 * u ocultando un mensaje de error superpuesto según corresponda.
 *
 * @param {CandleData[]} data - El nuevo array de datos de velas. Si el array está vacío
 *        o es nulo, limpia el gráfico y muestra un mensaje de error.
 */
export function updateChartData(data) {
    if (!candleSeries || !volumeSeries) {
        console.warn("El gráfico no está inicializado. No se pueden actualizar los datos.");
        return;
    }

    const errorOverlay = document.getElementById('chart-error-overlay');

    if (data && data.length > 0) {
        // Oculta el mensaje de error si hay datos disponibles.
        errorOverlay.style.display = 'none';

        // Mapea los datos brutos al formato requerido por Lightweight Charts.
        const candleData = data.map(item => ({
            time: item.time,
            open: Number(item.open),
            high: Number(item.high),
            low: Number(item.low),
            close: Number(item.close)
        }));
        const volumeData = data.map(item => ({
            time: item.time,
            value: Number(item.volume),
            color: Number(item.close) > Number(item.open) ? 'rgba(31, 191, 113, 0.5)' : 'rgba(226, 33, 52, 0.5)'
        }));

        console.log(`📊 Actualizando gráfico con ${data.length} velas.`);
        candleSeries.setData(candleData);
        volumeSeries.setData(volumeData);
    } else {
        // Si no hay datos disponibles, limpia las series y muestra el overlay de error.
        console.log("📊 No hay datos de velas disponibles. Mostrando mensaje de error.");
        candleSeries.setData([]);
        volumeSeries.setData([]);
        errorOverlay.style.display = 'flex'; // Se usa 'flex' para que coincida con el centrado del CSS.
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/domElements.js ===
==================================================

/**
 * @module DOMElements
 * @description Centraliza las referencias a los elementos del DOM a los que se accede con frecuencia.
 * Este patrón mejora el rendimiento al cachear los objetos jQuery, evitando consultas
 * redundantes al DOM y facilitando el mantenimiento del código.
 */

/**
 * Un objeto que contiene referencias cacheadas de jQuery a los elementos del DOM
 * utilizados en la interfaz de trading.
 * @type {Object<string, JQuery>}
 */
export const DOMElements = {
    // Contenedor principal del formulario de trading
    form: $('#formulario-trading'),
    // Selector principal de criptomonedas (ej. BTC, ETH)
    selectorPrincipal: $('#cripto'),
    // Desplegable para seleccionar la moneda de pago (en una compra)
    selectorPagarCon: $('#moneda-pago'),
    // Desplegable para seleccionar la moneda a recibir (en una venta)
    selectorRecibirEn: $('#moneda-recibir'),
    // Botón de acción 'Comprar'
    botonComprar: $('.boton-comprar'),
    // Botón de acción 'Vender'
    botonVender: $('.boton-vender'),
    // Botón final 'Confirmar' para la transacción
    botonConfirmar: $('.boton-confirmar'),
    // Input oculto que almacena la acción actual ('comprar' o 'vender')
    inputAccion: $('#accion'),
    // Contenedor para el desplegable 'Pagar con'
    campoPagarCon: $('#campo-pagar-con'),
    // Contenedor para el desplegable 'Recibir en'
    campoRecibirEn: $('#campo-recibir-en'),
    // Span para mostrar el saldo disponible del usuario
    spanSaldoDisponible: $('#saldo-disponible'),
    // Botones de radio para cambiar entre modos de ingreso ('monto' vs 'total')
    radioModoIngreso: $('input[name="modo-ingreso"]'),
    // Etiqueta para el botón de radio 'Cantidad (Cripto)'
    labelModoMonto: $('#label-modo-monto'),
    // Etiqueta para el campo de entrada de monto
    labelMonto: $('label[for="monto"]'),
    // Campo de entrada principal para el monto
    inputMonto: $('#monto'),
    // Etiqueta para el botón de radio 'Cantidad (Cripto)'
    labelModoMonto: $('#label-modo-monto'),
    // Etiqueta para el botón de radio 'Total (USDT)'
    labelModoTotal: $('#label-modo-total'),
};


==================================================
=== ARCHIVO: ./frontend/static/js/components/formLogic.js ===
==================================================

// frontend/static/js/components/formLogic.js

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';
import { AppState } from '../services/appState.js';

export const FormLogic = {
    /**
     * Rellena un elemento <select> con una lista de opciones, SIN disparar eventos.
     */
    popularSelector(selector, lista, placeholderVacio = 'No hay opciones') {
        selector.empty();

        if (!lista || lista.length === 0) {
            selector.append(new Option(placeholderVacio, '')).prop('disabled', true);
            return;
        }

        selector.prop('disabled', false);
        lista.forEach(({ ticker, nombre }) => selector.append(new Option(`${nombre} (${ticker})`, ticker)));
    },

    /**
     * Orquesta la actualización de todos los selectores del formulario.
     */
    actualizarOpcionesDeSelectores() {
        const esCompra = UIState.esModoCompra();
        const tickerPrincipal = UIState.getTickerPrincipal();
        
        const allCryptos = AppState.getAllCryptos();
        const ownedCoins = AppState.getOwnedCoins();

        if (esCompra) {
            const opcionesPagarCon = ownedCoins.filter(c => c.ticker !== tickerPrincipal);
            FormLogic.popularSelector(DOMElements.selectorPagarCon, opcionesPagarCon, 'No tienes fondos');
            // Establecemos el valor por defecto para 'Pagar con' sin disparar el change todavía
            DOMElements.selectorPagarCon.val('USDT');

        } else {
            const opcionesRecibirEn = allCryptos.filter(c => c.ticker !== tickerPrincipal);
            FormLogic.popularSelector(DOMElements.selectorRecibirEn, opcionesRecibirEn);
            // Establecemos el valor por defecto para 'Recibir en'
            DOMElements.selectorRecibirEn.val('USDT');
        }
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/tablaCotizacionesUI.js ===
==================================================

/**
 * @module tablaCotizacionesUI
 * @description Controla la renderización y actualización de la tabla de cotizaciones de criptomonedas.
 */

import { fetchCotizaciones } from '../services/apiService.js';
import { UIUpdater } from './uiUpdater.js';

const cuerpoTabla = document.getElementById('tabla-datos');

/**
 * @typedef {object} CotizacionPresentacion
 * @property {string} logo - URL del logo de la criptomoneda.
 * @property {string} nombre - Nombre de la criptomoneda.
 * @property {string} ticker - Símbolo de la criptomoneda.
 * @property {string} precio_usd_formatted - Precio formateado en USD.
 * @property {string} '1h_formatted' - Variación porcentual formateada (1h).
 * @property {string} '24h_formatted' - Variación porcentual formateada (24h).
 * @property {string} '7d_formatted' - Variación porcentual formateada (7d).
 * @property {object} perf_1h - Objeto con {className, arrow} para rendimiento 1h.
 * @property {object} perf_24h - Objeto con {className, arrow} para rendimiento 24h.
 * @property {object} perf_7d - Objeto con {className, arrow} para rendimiento 7d.
 * @property {string} market_cap_formatted - Capitalización de mercado formateada.
 * @property {string} volumen_24h_formatted - Volumen de 24h formateado.
 * @property {string} circulating_supply_formatted - Suministro circulante formateado.
 */

/**
 * Crea el HTML para una fila de la tabla de cotizaciones a partir de datos ya procesados.
 *
 * @private
 * @param {CotizacionPresentacion} cripto - El objeto de datos de la criptomoneda, ya formateado por el backend.
 * @param {number} index - El número de fila (índice + 1).
 * @returns {string} Una cadena de texto con el HTML del `<tr>` para la criptomoneda.
 */
function createFilaCotizacionHTML(cripto, index) {
    return `
        <tr>
            <td class="text-start px-3">${index}</td>
            <td class="text-start px-3">
                <img src="${cripto.logo}" width="20" class="logo-cripto" alt="${cripto.ticker} logo">
                <span class="nombre-cripto">${cripto.nombre}</span>
                <span class="ticker-cripto">(${cripto.ticker})</span>
            </td>
            <td class="text-start px-3 fw-bold">${cripto.precio_usd_formatted}</td>
            
            <td class="text-end px-3">
                <span class="${cripto.perf_1h.className}">
                    <span class="flecha">${cripto.perf_1h.arrow}</span>
                    ${cripto['1h_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${cripto.perf_24h.className}">
                    <span class="flecha">${cripto.perf_24h.arrow}</span>
                    ${cripto['24h_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${cripto.perf_7d.className}">
                    <span class="flecha">${cripto.perf_7d.arrow}</span>
                    ${cripto['7d_formatted']}
                </span>
            </td>
            
            <td class="text-end px-3">${cripto.market_cap_formatted}</td>
            <td class="text-end px-3">${cripto.volumen_24h_formatted}</td>
            <td class="text-end px-3">${cripto.circulating_supply_formatted}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de cotizaciones y renderiza la tabla en el DOM.
 * Si no hay cotizaciones, la tabla simplemente se mostrará vacía.
 * @async
 * @side-effects Modifica el `innerHTML` del elemento '#tabla-datos'.
 *               Puede mostrar un mensaje de error si la carga de datos falla.
 */
export async function renderTabla() {
    if (!cuerpoTabla) return;
    try {
        const cotizaciones = (await fetchCotizaciones()) || [];
        cuerpoTabla.innerHTML = cotizaciones
            .map((cripto, index) => createFilaCotizacionHTML(cripto, index + 1))
            .join('');
    } catch (error) {
        console.error('❌ Error al renderizar la tabla de cotizaciones:', error);
        UIUpdater.mostrarMensajeError(
            'No se pudieron cargar las cotizaciones. La información puede estar desactualizada.'
        );
        cuerpoTabla.innerHTML =
            '<tr><td colspan="9" class="text-center text-danger py-4">Error al cargar las cotizaciones.</td></tr>';
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiManager.js ===
==================================================

// frontend/static/js/components/uiManager.js

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';
import { UIUpdater } from './uiUpdater.js';
import { FormLogic } from './formLogic.js';
import { AppState } from '../services/appState.js';
import { AppDataManager } from '../services/appDataManager.js';
import { updateChartData } from './chartRenderer.js';
import { fetchVelas } from '../services/apiService.js';
import { saveTradingState } from '../services/statePersistence.js';

export const UIManager = {
    currentTicker: 'BTC',
    currentInterval: '1d',
    isChartLoading: false,

    initialize(initialState) {
        this.currentTicker = initialState.ticker;
        this.currentInterval = initialState.interval;

        // Renderizar partes de la UI que no dependen del formulario
        UIUpdater.renderHistorial(initialState.historial);
        this.renderOrdenesAbiertas(initialState.ordenesAbiertas);
        
        // Preparar plugins y listeners de eventos
        this.setupSelect2();
        this.setupEventListeners(); // Mover aquí para que los listeners estén listos
        
        // --- SECUENCIA DE INICIALIZACIÓN CORREGIDA ---
        // 1. Establecer el modo por defecto ("comprar"). Esto muestra y oculta los campos correctos.
        this.setTradeMode('comprar'); 
        
        // 2. Ahora que los campos son visibles, poblamos y seleccionamos los valores.
        this.actualizarFormularioCompleto();
        
        // 3. Ajustamos el resto de los elementos.
        this.handleTipoOrdenChange();
        $('#timeframe-selector .timeframe-btn').removeClass('active').filter(`[data-interval="${this.currentInterval}"]`).addClass('active');
    },

    setupSelect2() {
        [DOMElements.selectorPrincipal, DOMElements.selectorPagarCon, DOMElements.selectorRecibirEn].forEach((sel) => {
            sel.select2({ width: '100%', dropdownCssClass: 'text-dark', theme: 'bootstrap-5' });
        });
    },

    setupEventListeners() {
        DOMElements.botonComprar.on('click', () => this.handleTradeModeChange('comprar'));
        DOMElements.botonVender.on('click', () => this.handleTradeModeChange('vender'));
        DOMElements.selectorPrincipal.on('change', () => this.handleSelectorPrincipalChange());
        
        DOMElements.selectorPagarCon.on('change', () => this.updateDynamicLabels());
        DOMElements.selectorRecibirEn.on('change', () => this.updateDynamicLabels());
        
        $('#timeframe-selector').on('click', '.timeframe-btn', (e) => this.handleTimeframeChange(e));
        $('input[name="tipo-orden"]').on('change', () => this.handleTipoOrdenChange());
        DOMElements.radioModoIngreso.on('change', () => this.updateDynamicLabels());
        
        $('#precio_disparo, #precio_limite, #monto').on('input', (e) => this.validarInputNumerico(e));

        $('#tabla-ordenes-abiertas').on('click', '.btn-cancelar-orden', (e) => this.handleCancelClick(e));
    },

    /**
     * Función que se llama cuando el usuario hace clic en Comprar/Vender.
     * @param {string} mode - 'comprar' o 'vender'.
     */
    handleTradeModeChange(mode) {
        this.setTradeMode(mode);
        this.actualizarFormularioCompleto();
    },

    /**
     * Establece el estado visual básico del modo de trading (colores y visibilidad de campos).
     * Ya no llama a la actualización completa del formulario para evitar bucles.
     * @param {string} mode - 'comprar' o 'vender'.
     */
    setTradeMode(mode) {
        DOMElements.inputAccion.val(mode);
        UIUpdater.actualizarBotones();
        UIUpdater.actualizarVisibilidadCampos();
    },

    /**
     * Rellena y actualiza todos los selectores y etiquetas del formulario.
     */
    actualizarFormularioCompleto() {
        const esCompra = UIState.esModoCompra();
        const ticker = this.currentTicker;
        
        if (esCompra) {
            FormLogic.popularSelector(DOMElements.selectorPrincipal, AppState.getAllCryptos().filter(c => c.ticker !== 'USDT'));
        } else {
            FormLogic.popularSelector(DOMElements.selectorPrincipal, AppState.getOwnedCoins().filter(c => c.ticker !== 'USDT'), 'No tienes monedas para vender');
        }
        DOMElements.selectorPrincipal.val(ticker).trigger('change.select2');
        
        FormLogic.actualizarOpcionesDeSelectores();
        this.updateDynamicLabels();
    },
    
    /**
     * Actualiza solo las etiquetas que cambian dinámicamente.
     */
    updateDynamicLabels() {
        const tickerParaBalance = UIState.esModoCompra() ? UIState.getTickerPago() : UIState.getTickerPrincipal();
        UIUpdater.mostrarSaldo(tickerParaBalance);
        UIUpdater.actualizarLabelsModoIngreso();
        UIUpdater.actualizarLabelMonto();
    },

    handleSelectorPrincipalChange() {
        const nuevoTicker = UIState.getTickerPrincipal();
        if (!nuevoTicker || nuevoTicker === this.currentTicker) return;
        this.currentTicker = nuevoTicker;
        
        this.actualizarFormularioCompleto();
        this.actualizarGrafico();
        saveTradingState(this.currentTicker, this.currentInterval);
    },

    async actualizarGrafico() {
        if (!this.currentTicker || this.isChartLoading) return;
        this.isChartLoading = true;
        try {
            const nuevosDatosVelas = await fetchVelas(this.currentTicker, this.currentInterval);
            updateChartData(nuevosDatosVelas);
        } catch (error) {
            console.error(`Error al actualizar el gráfico para ${this.currentTicker}/${this.currentInterval}:`, error);
            updateChartData([]);
        } finally {
            this.isChartLoading = false;
        }
    },
    
    handleTimeframeChange(event) {
        this.currentInterval = $(event.currentTarget).data('interval');
        $(event.currentTarget).addClass('active').siblings().removeClass('active');
        this.actualizarGrafico();
        saveTradingState(this.currentTicker, this.currentInterval);
    },

    handleTipoOrdenChange() {
        const tipoOrden = $('input[name="tipo-orden"]:checked').val();
        const [campoStop, inputStop, labelStop] = [$('#campo-precio-disparo'), $('#precio_disparo'), $('#label-precio-disparo')];
        const [campoLimit, inputLimit] = [$('#campo-precio-limite'), $('#precio_limite')];

        [campoStop, campoLimit].forEach(f => f.hide());
        [inputStop, inputLimit].forEach(i => i.prop('required', false));
    
        if (tipoOrden === 'limit') {
            labelStop.text('Precio Límite');
            campoStop.show();
            inputStop.prop('required', true);
        } else if (tipoOrden === 'stop-limit') {
            labelStop.text('Precio Stop');
            campoStop.show();
            campoLimit.show();
            inputStop.prop('required', true);
            inputLimit.prop('required', true);
        }
        this.updateDynamicLabels();
    },

    renderOrdenesAbiertas(ordenes) {
        const tablaBody = $('#tabla-ordenes-abiertas tbody');
        if (!ordenes || ordenes.length === 0) {
            tablaBody.html('<tr><td colspan="7" class="text-center text-muted py-3">No hay órdenes abiertas.</td></tr>');
            return;
        } 
        
        const createOrdenAbiertaRowHTML = (orden) => {
            const fechaCreacion = new Date(orden.timestamp_creacion).toLocaleString('es-AR', { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' });
            const tipoOrdenClase = orden.accion === 'comprar' ? 'text-success' : 'text-danger';
            const cantidad = orden.cantidad_cripto_principal;
            const tickerCantidad = orden.accion === 'vender' ? orden.moneda_origen : orden.moneda_destino;
            const tipoOrdenFormatted = orden.tipo_orden.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            return `
                <tr>
                    <td class="text-start ps-3 small">${fechaCreacion}</td>
                    <td class="fw-bold">${orden.par}</td>
                    <td>${tipoOrdenFormatted}</td>
                    <td class="${tipoOrdenClase}">${orden.accion.charAt(0).toUpperCase() + orden.accion.slice(1)}</td>
                    <td>${orden.precio_disparo}</td>
                    <td>${cantidad} ${tickerCantidad}</td>
                    <td><button class="btn btn-sm btn-outline-danger btn-cancelar-orden" data-id-orden="${orden.id_orden}">Cancelar</button></td>
                </tr>`;
        };
        tablaBody.html(ordenes.map(createOrdenAbiertaRowHTML).join(''));
    },
    
    async handleCancelClick(event) {
        const orderId = $(event.currentTarget).data('id-orden');
        const result = await Swal.fire({
            title: '¿Estás seguro?', text: "No podrás revertir esta acción.",
            icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33',
            cancelButtonColor: '#3085d6', confirmButtonText: 'Sí, ¡cancelar orden!',
            cancelButtonText: 'No', background: '#212529', color: '#f8f9fa'
        });

        if (result.isConfirmed) {
            try {
                const respuesta = await AppDataManager.handleCancelOrder(orderId);
                Toast.fire({ icon: 'success', html: respuesta.mensaje });
                $(event.currentTarget).closest('tr').fadeOut(400, function() { $(this).remove(); });
                this.updateDynamicLabels();
            } catch (error) {
                Swal.fire({ icon: 'error', title: 'Error', text: 'No se pudo cancelar la orden.', background: '#212529', color: '#f8f9fa' });
            }
        }
    },

    validarInputNumerico(event, maxDecimales = 8) {
        const input = event.target;
        let value = input.value.replace(/[^0-9.]/g, '').replace(/(\..*)\./g, '$1');
        const parts = value.split('.');
        if (parts[1] && parts[1].length > maxDecimales) {
            value = parts[0] + '.' + parts[1].substring(0, maxDecimales);
        }
        input.value = value;
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiState.js ===
==================================================

/**
 * @module uiState
 * @description Proporciona un objeto centralizado para consultar el estado actual de la interfaz de usuario.
 * Este módulo abstrae la lógica de acceso a los valores de los elementos del DOM, facilitando
 * la obtención de información sobre el estado de la UI sin interactuar directamente con `DOMElements`.
 */

import { DOMElements } from './domElements.js';

/**
 * @description Un objeto que agrupa funciones para obtener diferentes aspectos del estado de la UI.
 * Cada método consulta un elemento del DOM a través de `DOMElements` y devuelve su estado actual.
 * @exports UIState
 */
export const UIState = {
    /**
     * Comprueba si el modo de operación actual es 'comprar'.
     * @returns {boolean} `true` si la acción seleccionada es 'comprar', de lo contrario `false`.
     */
    esModoCompra() {
        return DOMElements.inputAccion.val() === 'comprar';
    },

    /**
     * Obtiene el modo de ingreso seleccionado (ej. 'cantidad' o 'monto').
     * @returns {string} El valor del radio button seleccionado para el modo de ingreso.
     */
    getModoIngreso() {
        return DOMElements.radioModoIngreso.filter(':checked').val();
    },

    /**
     * Obtiene el ticker de la criptomoneda principal seleccionada.
     * @returns {string} El ticker de la criptomoneda en el selector principal.
     */
    getTickerPrincipal() {
        return DOMElements.selectorPrincipal.val();
    },

    /**
     * Obtiene el ticker de la moneda utilizada para pagar.
     * @returns {string} El ticker de la moneda en el selector 'pagar con'.
     */
    getTickerPago() {
        return DOMElements.selectorPagarCon.val();
    },

    /**
     * Obtiene el ticker de la moneda que se recibirá.
     * @returns {string} El ticker de la moneda en el selector 'recibir en'.
     */
    getTickerRecibo() {
        return DOMElements.selectorRecibirEn.val();
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiUpdater.js ===
==================================================

/**
 * @module uiUpdater
 * @description Centraliza todas las funciones que actualizan dinámicamente la interfaz de usuario.
 * Este módulo es responsable de cambiar la apariencia y el contenido de los elementos del DOM
 * en respuesta a las acciones del usuario y los datos de la aplicación.
 */

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';
import { AppState } from '../services/appState.js';


export const UIUpdater = {
    actualizarBotones() {
        const esCompra = UIState.esModoCompra();
        DOMElements.botonConfirmar
            .text(esCompra ? 'COMPRAR' : 'VENDER')
            .toggleClass('btn-success', esCompra)
            .toggleClass('btn-danger', !esCompra);
        DOMElements.botonComprar
            .toggleClass('active btn-success', esCompra)
            .toggleClass('btn-outline-secondary', !esCompra);
        DOMElements.botonVender
            .toggleClass('active btn-danger', !esCompra)
            .toggleClass('btn-outline-secondary', esCompra);
    },

    actualizarVisibilidadCampos() {
        const esCompra = UIState.esModoCompra();
        DOMElements.campoPagarCon.toggle(esCompra);
        DOMElements.campoRecibirEn.toggle(!esCompra);
        DOMElements.selectorPagarCon.prop('disabled', !esCompra);
        DOMElements.selectorRecibirEn.prop('disabled', esCompra);
    },

    actualizarLabelMonto() {
        const esModoMonto = UIState.getModoIngreso() === 'monto';
        const esCompra = UIState.esModoCompra();
        let tickerRelevante = '';

        if (esCompra) {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerPago();
        } else {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerRecibo();
        }

        const etiqueta = esModoMonto ? 'Cantidad' : 'Total';
        DOMElements.labelMonto.text(`${etiqueta} (${tickerRelevante || '...'})`);
    },

    actualizarLabelsModoIngreso() {
        const tickerPrincipal = UIState.getTickerPrincipal();
        let tickerSecundario;

        if (UIState.esModoCompra()) {
            // Si compramos, el "Total" se refiere a la moneda con la que pagamos.
            tickerSecundario = UIState.getTickerPago();
        } else {
            // Si vendemos, el "Total" se refiere a la moneda que recibimos.
            tickerSecundario = UIState.getTickerRecibo();
        }
        
        // El modo "Cantidad" siempre se refiere a la criptomoneda principal de la operación.
        DOMElements.labelModoMonto.text(`Cantidad (${tickerPrincipal || 'Cripto'})`);
        
        // El modo "Total" se refiere a la otra moneda del par.
        DOMElements.labelModoTotal.text(`Total (${tickerSecundario || 'USDT'})`);
    },

    mostrarSaldo(ticker) {
        if (!ticker) {
            DOMElements.spanSaldoDisponible.text('--');
            return;
        }

        // Usamos AppState en lugar de 'window'
        const moneda = AppState.getOwnedCoinByTicker(ticker);



        // Simplemente usa el valor formateado que ya tienes.
        const saldoFormateado = moneda ? moneda.cantidad_disponible_formatted : '0.00';
        
        DOMElements.spanSaldoDisponible.text(`${saldoFormateado} ${ticker}`); 
    },
    
    setInputMonto(valor) {
        DOMElements.inputMonto.val(valor);
    },

    renderHistorial(historialData) {
        const tablaHistorial = $('#tabla-historial');
        if (!tablaHistorial.length) return;

        if (historialData.length === 0) {
            tablaHistorial.html(
                '<tr><td colspan="5" class="text-center text-muted py-3">No hay transacciones en el historial.</td></tr>'
            );
            return;
        }

        const historialHTML = historialData
            .map((item) => {
                const claseTipo = item.tipo.toLowerCase() === 'compra' ? 'text-success' : 'text-danger';

                return `
                <tr>
                    <td class="text-start ps-3">${item.fecha_formatted}</td>
                    <td class="fw-bold">${item.par_formatted}</td>
                    <td class="${claseTipo}">${item.tipo_formatted}</td>
                    <td>${item.cantidad_formatted}</td>
                    <td>${item.valor_total_formatted}</td>
                </tr>
            `;
            })
            .join('');

        tablaHistorial.html(historialHTML);
    },

    mostrarMensajeError(mensaje, containerSelector = '#error-container') {
        const errorContainer = $(containerSelector);
        if (!errorContainer.length) {
            console.error(`Error container '${containerSelector}' not found.`);
            return;
        }
        const alertHTML = `
            <div class="alert alert-danger alert-dismissible fade show" role="alert">
                ${mensaje}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        `;
        errorContainer.html(alertHTML);
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/pages/billeteraPage.js ===
==================================================

/**
 * @module pages/billeteraPage
 * @description Orquesta la inicialización y la lógica principal de la página de la billetera.
 */

import { fetchEstadoBilletera, fetchComisiones } from '../services/apiService.js';
import { UIUpdater } from '../components/uiUpdater.js';

/**
 * @typedef {object} ActivoBilletera
 * @property {string} ticker - El símbolo de la criptomoneda.
 * @property {boolean} es_polvo - Indica si la cantidad es considerada "polvo".
 * @property {string} ganancia_perdida_cruda - El valor numérico de la ganancia o pérdida (como string).
 * @property {string} cantidad_formatted - La cantidad formateada.
 * @property {string} precio_actual_formatted - El precio actual formateado.
 * @property {string} valor_usdt_formatted - El valor total en USDT formateado.
 * @property {string} ganancia_perdida_formatted - La ganancia o pérdida formateada.
 * @property {string} porcentaje_ganancia_formatted - El porcentaje de G/P formateado.
 * @property {string} porcentaje_formatted - El % que representa en la billetera.
 */

/**
 * Crea una fila HTML (`<tr>`) para la tabla de la billetera.
 * @param {ActivoBilletera} cripto - El objeto que contiene los datos del activo.
 * @returns {string} Una cadena de texto con el HTML de la fila de la tabla.
 */
function createBilleteraRowHTML(cripto) {
    const colorGanancia = parseFloat(cripto.ganancia_perdida_cruda) >= 0 ? 'text-success' : 'text-danger';
    const claseFila = cripto.es_polvo ? 'fila-polvo' : '';
    const reservadoClase = parseFloat(cripto.cantidad_reservada) > 0 ? 'text-warning' : '';

    return `
        <tr class="${claseFila}">
            <td class="text-start ps-3">
                <img src="${cripto.logo}" width="24" class="me-3" style="vertical-align: middle;" alt="${cripto.ticker} logo">
                <span class="fw-bold fs-6">${cripto.nombre}</span>
                <span class="text-white-50 ms-2">(${cripto.ticker})</span>
            </td>
            <td class="text-end pe-3">${cripto.cantidad_total_formatted}</td>
            <td class="text-end pe-3">${cripto.cantidad_disponible_formatted}</td>
            <td class="text-end pe-3 ${reservadoClase}">${cripto.cantidad_reservada_formatted}</td>
            <td class="text-end pe-3">${cripto.precio_actual_formatted}</td>
            <td class="text-end pe-3 fw-bold">${cripto.valor_usdt_formatted}</td>
            <td class="text-end pe-3 ${colorGanancia}">${cripto.ganancia_perdida_formatted}</td>
            <td class="text-end pe-3 ${colorGanancia}">${cripto.porcentaje_ganancia_formatted}</td>
            <td class="text-end pe-3">${cripto.porcentaje_formatted}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de la billetera desde la API y los renderiza en la tabla.
 */
async function renderBilletera() {
    const cuerpoTabla = document.getElementById('tabla-billetera');
    if (!cuerpoTabla) {
        console.warn("El elemento #tabla-billetera no fue encontrado en el DOM.");
        return;
    }

    try {
        const datosBilletera = await fetchEstadoBilletera();
        if (!datosBilletera || datosBilletera.length === 0) {
            cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-muted py-4">Tu billetera está vacía.</td></tr>';
        } else {
            cuerpoTabla.innerHTML = datosBilletera.map(createBilleteraRowHTML).join('');
        }
    } catch (error) {
        console.error('Error al renderizar la billetera:', error);
        UIUpdater.mostrarMensajeError('No se pudieron cargar los datos de la billetera.');
        cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-danger py-4">Error al cargar los datos.</td></tr>';
    }
}

/**
 * Crea una fila HTML para la tabla de historial de comisiones.
 * @param {object} comision - El objeto de datos de la comisión.
 * @returns {string} Una cadena de texto con el HTML de la fila.
 */
function createComisionRowHTML(comision) {
    const fecha = new Date(comision.timestamp).toLocaleString('es-AR', {
        day: '2-digit', month: '2-digit', year: 'numeric',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
    });

    return `
        <tr>
            <td>${fecha}</td>
            <td>${comision.ticker}</td>
            <td>${parseFloat(comision.cantidad).toFixed(8)}</td>
            <td>$${parseFloat(comision.valor_usd).toFixed(2)}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de comisiones desde la API y los renderiza en la tabla.
 */
async function renderComisiones() {
    const cuerpoTabla = document.getElementById('tabla-comisiones');
    if (!cuerpoTabla) {
        console.warn("El elemento #tabla-comisiones no fue encontrado en el DOM.");
        return;
    }

    try {
        const datosComisiones = await fetchComisiones();
        if (!datosComisiones || datosComisiones.length === 0) {
            cuerpoTabla.innerHTML = '<tr><td colspan="4" class="text-center text-muted py-3">No se han cobrado comisiones.</td></tr>';
        } else {
            cuerpoTabla.innerHTML = datosComisiones.map(createComisionRowHTML).join('');
        }
    } catch (error) {
        console.error('Error al renderizar las comisiones:', error);
        cuerpoTabla.innerHTML = '<tr><td colspan="4" class="text-center text-danger py-4">Error al cargar las comisiones.</td></tr>';
    }
}

/**
 * ### NUEVO: Configura la lógica para el switch de ocultar polvo.
 */
function setupEventListeners() {
    const switchOcultarPolvo = document.getElementById('ocultar-polvo-switch');
    if (switchOcultarPolvo) {
        switchOcultarPolvo.addEventListener('change', (event) => {
            const filasPolvo = document.querySelectorAll('.fila-polvo');
            const estaActivado = event.target.checked;
            
            filasPolvo.forEach(fila => {
                // Ocultamos la fila si el switch está activado, la mostramos si no.
                fila.style.display = estaActivado ? 'none' : 'table-row';
            });
        });
    }
}


/**
 * Listener que se ejecuta cuando el DOM está completamente cargado.
 */
document.addEventListener('DOMContentLoaded', () => {
    console.log("Página de Billetera cargada. Obteniendo datos...");
    
    // Promise.all espera a que ambas funciones de renderizado terminen.
    Promise.all([
        renderBilletera(),
        renderComisiones()
    ]).then(() => {
        // Una vez que las tablas están renderizadas, configuramos los event listeners.
        setupEventListeners();
    });
});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/indexPage.js ===
==================================================

/**
 * @module pages/indexPage
 * @description Lógica para la página principal de cotizaciones.
 * Se encarga de inicializar y gestionar la actualización periódica de la tabla de cotizaciones.
 */

import { triggerActualizacionDatos } from '../services/apiService.js';
import { renderTabla } from '../components/tablaCotizacionesUI.js';

/**
 * @const {number} UPDATE_INTERVAL_MS
 * @description Intervalo en milisegundos para la actualización automática de la tabla de cotizaciones.
 * @default 15000
 */
const UPDATE_INTERVAL_MS = 15000; // 15 segundos

/**
 * Orquesta el ciclo completo de actualización de datos y renderizado de la tabla.
 * Primero, solicita al backend que actualice sus datos desde la fuente externa.
 * Una vez completado, renderiza la tabla de cotizaciones con la información más reciente.
 * @async
 * @function actualizarYRenderizar
 * @throws {Error} Si alguna de las operaciones (actualización o renderizado) falla.
 */
async function actualizarYRenderizar() {
    console.log("Iniciando ciclo de actualización de cotizaciones...");
    try {
        await triggerActualizacionDatos();
        await renderTabla();
        console.log("Tabla de cotizaciones actualizada exitosamente.");
    } catch (error) {
        console.error("Falló el ciclo de actualización de la tabla de cotizaciones:", error);
    }
}

/**
 * @description Listener que se ejecuta cuando el DOM está completamente cargado.
 * Verifica si la tabla de cotizaciones existe en la página actual y, si es así,
 * inicia el ciclo de actualización inmediata y periódica.
 * @event DOMContentLoaded
 */
document.addEventListener('DOMContentLoaded', () => {
    // Asegurarse de que el script solo se ejecute en la página correcta.
    if (document.getElementById('tabla-datos')) {
        console.log("Página de cotizaciones detectada. Iniciando actualizaciones.");
        
        // Ejecuta la actualización inmediatamente al cargar la página.
        actualizarYRenderizar();
        
        // Establece el intervalo para futuras actualizaciones automáticas.
        setInterval(actualizarYRenderizar, UPDATE_INTERVAL_MS);
    }
});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/tradingPage.js ===
==================================================

// frontend/static/js/pages/tradingPage.js

import { AppDataManager } from '../services/appDataManager.js';
import { UIManager } from '../components/uiManager.js';
import { initializeChart, updateChartData } from '../components/chartRenderer.js';
import { loadTradingState, saveTradingState } from '../services/statePersistence.js';
import { fetchVelas } from '../services/apiService.js';

const POLLING_INTERVAL_MS = 20000; // 20 segundos

/**
 * Función principal que orquesta la inicialización de la página.
 */
async function initialize() {
    console.log('Inicializando página de trading...');

    const urlParams = new URLSearchParams(window.location.search);
    const tickerDesdeUrl = urlParams.get('ticker');
    const savedState = loadTradingState();
    const initialTicker = tickerDesdeUrl || savedState?.ticker || 'BTC';
    const initialInterval = savedState?.interval || '1d';
    if (tickerDesdeUrl) saveTradingState(initialTicker, initialInterval);

    try {
        const { historial, ordenesAbiertas } = await AppDataManager.loadInitialData();
        
        UIManager.initialize({
            ticker: initialTicker,
            interval: initialInterval,
            historial,
            ordenesAbiertas
        });
        
        const datosVelas = await fetchVelas(initialTicker, initialInterval);
        initializeChart(datosVelas);
        
        UIManager.setupEventListeners();

        setInterval(async () => {
            const data = await AppDataManager.pollData();
            if (data) {
                UIManager.renderOrdenesAbiertas(data.nuevasOrdenesAbiertas);
                UIManager.updateDynamicLabels();
            }
        }, POLLING_INTERVAL_MS);

        console.log('Página de trading inicializada correctamente.');

    } catch (error) {
        Swal.fire({
            icon: 'error', title: 'Error de Conexión',
            text: 'No se pudieron cargar los datos esenciales. Por favor, recarga la página.',
            background: '#212529', color: '#f8f9fa'
        });
    }
}

// Punto de entrada
document.addEventListener('DOMContentLoaded', initialize);

==================================================
=== ARCHIVO: ./frontend/static/js/services/apiService.js ===
==================================================

// frontend/static/js/services/apiService.js

/**
 * ### REFACTORIZADO ###
 * Realiza una solicitud `fetch` y maneja respuestas de éxito y de error estructuradas.
 */
async function _fetchData(url, options = {}, errorMessage = 'Error en la solicitud a la API') {
    try {
        const response = await fetch(url, options);

        if (!response.ok) {
            // Si la respuesta no es OK, intentamos leer el cuerpo del error.
            const errorData = await response.json().catch(() => null); // Si el cuerpo no es JSON, devuelve null.
            const message = errorData?.mensaje || response.statusText; // Usa el mensaje del backend o el texto de estado HTTP.
            
            // Creamos un error que contiene los datos estructurados.
            const error = new Error(message);
            error.datos = errorData; // Adjuntamos todos los datos del error.
            error.status = response.status;
            throw error;
        }

        return await response.json();
    } catch (error) {
        console.error(`Error en la llamada a la API [${url}]:`, error);
        throw error; // Re-lanzamos el error para que el código que llama pueda manejarlo.
    }
}

// El resto de las funciones (fetchCotizaciones, fetchEstadoBilletera, etc.) NO CAMBIAN.
// Siguen usando _fetchData, que ahora es más potente.

export const fetchCotizaciones = () => 
    _fetchData('/api/cotizaciones', {}, 'No se pudieron cargar las cotizaciones');

export const fetchEstadoBilletera = () => 
    _fetchData('/api/billetera/estado-completo', {}, 'No se pudo cargar el estado de la billetera');

export const fetchHistorial = () => 
    _fetchData('/api/historial', {}, 'No se pudo cargar el historial de transacciones');

export const fetchVelas = (ticker, interval) => 
    _fetchData(`/api/velas/${ticker}/${interval}`, {}, `No se pudieron cargar los datos de velas para ${ticker} (${interval})`);

export const triggerActualizacionDatos = () => 
    _fetchData('/api/actualizar', {}, 'La solicitud para actualizar los datos falló');

export const fetchComisiones = () => 
    _fetchData('/api/comisiones', {}, 'No se pudo cargar el historial de comisiones');

export const fetchOrdenesAbiertas = () =>
    _fetchData('/api/ordenes-abiertas', {}, 'No se pudo cargar la lista de órdenes abiertas');

export const cancelarOrden = (idOrden) => 
    _fetchData(`/api/orden/cancelar/${idOrden}`, {
        method: 'POST'
    }, 'No se pudo cancelar la orden');

==================================================
=== ARCHIVO: ./frontend/static/js/services/appDataManager.js ===
==================================================

// frontend/static/js/services/appDataManager.js

import {
    fetchCotizaciones,
    fetchEstadoBilletera,
    fetchHistorial,
    fetchOrdenesAbiertas,
    cancelarOrden
} from './apiService.js';
import { AppState } from './appState.js';

export const AppDataManager = {
    /**
     * Carga todos los datos iniciales necesarios para la página de trading.
     * Devuelve los datos que son necesarios para el renderizado inicial de la UI.
     */
    async loadInitialData() {
        console.log("Cargando datos iniciales...");
        try {
            const [cotizaciones, estadoBilletera, historial, ordenesAbiertas] = await Promise.all([
                fetchCotizaciones(),
                fetchEstadoBilletera(),
                fetchHistorial(),
                fetchOrdenesAbiertas()
            ]);

            AppState.setAllCryptos(cotizaciones);
            AppState.setOwnedCoins(estadoBilletera);

            return { historial, ordenesAbiertas };
        } catch (error) {
            console.error("Error fatal al cargar datos iniciales:", error);
            throw error; // Re-lanzar para que el orquestador lo maneje
        }
    },

    /**
     * Realiza un sondeo periódico para actualizar los datos dinámicos.
     * Devuelve los datos que la UI necesita para refrescarse.
     */
    async pollData() {
        console.log("🔄 Realizando sondeo de datos en vivo...");
        try {
            const [nuevoEstadoBilletera, nuevasOrdenesAbiertas] = await Promise.all([
                fetchEstadoBilletera(),
                fetchOrdenesAbiertas()
            ]);

            AppState.setOwnedCoins(nuevoEstadoBilletera);

            return { nuevasOrdenesAbiertas };
        } catch (error) {
            console.error("❌ Error durante el sondeo de datos:", error);
            return null;
        }
    },
    
    /**
     * Gestiona la cancelación de una orden, actualiza el estado y devuelve la respuesta.
     * @param {string} orderId - El ID de la orden a cancelar.
     * @returns {Promise<object>} - La respuesta de la API.
     */
    async handleCancelOrder(orderId) {
        const respuesta = await cancelarOrden(orderId);
        if (respuesta.datos && respuesta.datos.activo_actualizado) {
            const activo = respuesta.datos.activo_actualizado;
            const billeteraActual = AppState.getOwnedCoins();
            const indice = billeteraActual.findIndex(a => a.ticker === activo.ticker);
            if (indice !== -1) {
                billeteraActual[indice] = activo;
                AppState.setOwnedCoins(billeteraActual);
            }
        }
        return respuesta;
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/services/appState.js ===
==================================================

/**
 * @module services/appState
 * @description Centraliza el estado de la aplicación para evitar el uso de variables globales.
 * Proporciona métodos seguros para leer y escribir en el estado.
 */

const state = {
    allCryptos: [],
    ownedCoins: []
};

export const AppState = {
    /**
     * Establece la lista completa de cotizaciones.
     * @param {Array<object>} cryptos - La lista de criptomonedas.
     */
    setAllCryptos: (cryptos) => {
        state.allCryptos = cryptos || [];
    },

    /**
     * Establece la lista de monedas que el usuario posee.
     * @param {Array<object>} coins - La lista de monedas en la billetera.
     */
    setOwnedCoins: (coins) => {
        state.ownedCoins = coins || [];
    },

    /**
     * Obtiene la lista completa de cotizaciones.
     * @returns {Array<object>}
     */
    getAllCryptos: () => state.allCryptos,

    /**
     * Obtiene la lista de monedas que el usuario posee.
     * @returns {Array<object>}
     */
    getOwnedCoins: () => state.ownedCoins,

    /**
     * Busca una moneda específica que el usuario posee por su ticker.
     * @param {string} ticker - El ticker de la moneda.
     * @returns {object | undefined} El objeto de la moneda o undefined si no se encuentra.
     */
    getOwnedCoinByTicker: (ticker) => {
        return state.ownedCoins.find(coin => coin.ticker === ticker);
    },

    /**
     * Busca el precio de una criptomoneda específica por su ticker.
     * @param {string} ticker - El ticker de la moneda.
     * @returns {number | null} El precio de la moneda o null si no se encuentra.
     */
    getPriceByTicker: (ticker) => {
        const crypto = state.allCryptos.find(c => c.ticker === ticker);
        // La propiedad 'precio_usd' viene del backend como un string, lo convertimos a número.
        return crypto ? parseFloat(crypto.precio_usd) : null;
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/services/statePersistence.js ===
==================================================

/**
 * @module services/statePersistence
 * @description Gestiona el guardado y la carga del estado de la aplicación
 * en el Almacenamiento Local (LocalStorage) del navegador.
 */

// Usamos una clave constante para evitar errores de tipeo.
const TRADING_STATE_KEY = 'tradingViewState';

/**
 * Guarda el estado actual de la vista de trading (ticker e intervalo).
 * @param {string} ticker - El ticker de la criptomoneda actual.
 * @param {string} interval - El intervalo de tiempo actual.
 */
export function saveTradingState(ticker, interval) {
    if (!ticker || !interval) {
        console.warn("Intento de guardar estado de trading inválido.");
        return;
    }
    const state = { ticker, interval };
    try {
        // Los objetos deben ser convertidos a string (JSON) para guardarse en LocalStorage.
        localStorage.setItem(TRADING_STATE_KEY, JSON.stringify(state));
    } catch (error) {
        console.error("Error al guardar el estado en LocalStorage:", error);
    }
}

/**
 * Carga el estado de la vista de trading desde LocalStorage.
 * @returns {{ticker: string, interval: string} | null} El estado guardado o null si no se encuentra nada.
 */
export function loadTradingState() {
    try {
        const savedStateJSON = localStorage.getItem(TRADING_STATE_KEY);
        if (savedStateJSON) {
            // Si encontramos datos, los convertimos de nuevo a un objeto JavaScript.
            return JSON.parse(savedStateJSON);
        }
        return null; // No hay estado guardado.
    } catch (error) {
        console.error("Error al cargar el estado desde LocalStorage:", error);
        return null;
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/utils/sweetalert-init.js ===
==================================================

/**
 * @file sweetalert-init.js
 * @description Inicializa y configura globalmente la librería SweetAlert2.
 * Define un objeto 'Toast' personalizado para notificaciones no intrusivas.
 */

// Se define 'Toast' en el ámbito global para que sea accesible
// desde otros scripts, como los flashes de Flask en el HTML.
const Toast = Swal.mixin({
    toast: true,
    position: 'top-end',
    showConfirmButton: false,
    timer: 8000,
    customClass: {
        popup: 'custom-toast-position'
    },
    timerProgressBar: true,
    showCloseButton: true,
    didOpen: (toast) => {
        toast.addEventListener('mouseenter', Swal.stopTimer);
        toast.addEventListener('mouseleave', Swal.resumeTimer);
    },
    background: '#343a40', // Fondo oscuro
    color: '#f8f9fa'       // Texto claro
});


==================================================
=== ARCHIVO: ./frontend/templates/_flashes.html ===
==================================================

<!-- frontend/templates/_flashes.html -->
<!-- ### REFACTORIZADO ### - Ahora es un componente inteligente que construye el HTML. -->

{% with messages = get_flashed_messages(with_categories=true) %}
{% if messages %}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        /**
         * Construye el contenido HTML para la notificación Toast a partir de los datos
         * estructurados que envía el backend.
         * @param {object} data - El objeto de datos parseado desde el JSON.
         * @returns {string} El HTML para el cuerpo de la notificación.
         */
        function buildFlashMessageHTML(data) {
            // Estilo común para el cuerpo del mensaje
            const baseStyle = 'text-align: left; font-size: 0.9rem;';
            const hr = "<hr style='margin: 4px 0; border-color: #555;'>";

            if (data.tipo === 'mercado') {
                const d = data.detalles;
                return `
                    <div style="${baseStyle}">
                        <span>Recibiste: <strong style='color: #1FB371;'>${d.recibiste.cantidad} ${d.recibiste.ticker}</strong></span><br>
                        <span>Pagaste: <strong style='color: #FFA500;'>${d.pagaste.cantidad} ${d.pagaste.ticker}</strong></span><br>
                        <span style='font-size: 0.8rem; color: #999;'>Comisión: ${d.comision.cantidad} ${d.comision.ticker}</span>
                    </div>
                `;
            } else if (data.tipo === 'limit' || data.tipo === 'stop-loss') {
                const d = data.detalles;
                return `
                    <div style="${baseStyle}">
                        <span>Acción: <strong>${d.accion}</strong></span><br>
                        <span>Precio Disparo: <strong>${d.precio_disparo}</strong></span><br>
                        <span style='font-size: 0.8rem; color: #999;'>Los fondos han sido reservados.</span>
                    </div>
                `;
            }
            return 'Detalles no disponibles.'; // Fallback
        }

        const flashedMessages = {{ messages|tojson|safe }};

        if (typeof Toast !== 'undefined') {
            flashedMessages.forEach(([category, message]) => {
                const iconType = category === 'danger' ? 'error' : 'success';
                let title, htmlContent;

                if (category === 'success') {
                    try {
                        // El mensaje de éxito es un JSON, lo parseamos
                        const data = JSON.parse(message);
                        title = data.titulo || 'Operación Procesada';
                        htmlContent = buildFlashMessageHTML(data);
                    } catch (e) {
                        // Si falla el parseo, lo mostramos como texto plano
                        console.error("Error al parsear el mensaje flash JSON:", e);
                        title = 'Operación Exitosa';
                        htmlContent = message;
                    }
                } else {
                    // El mensaje de error es un string simple
                    title = 'Error en la operación';
                    htmlContent = message;
                }
                
                Toast.fire({
                    icon: iconType,
                    title: title,
                    html: htmlContent
                });
            });
        } else {
            console.error("SweetAlert Toast no está definido.");
        }
    });
</script>
{% endif %}
{% endwith %}

==================================================
=== ARCHIVO: ./frontend/templates/billetera.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Billetera</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.webp') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="bg-dark text-white">
    <!-- ========== BARRA DE NAVEGACIÓN ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.webp') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white active"
                            href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes de error (si se necesita) -->
    <div id="error-container" class="container-fluid mt-3"></div>

    <!-- ========== CONTENIDO PRINCIPAL ========== -->
    <main class="container my-4">
        <div class="text-center">
            <h2 class="text-warning mb-4">Mi Billetera</h2>
        </div>

        <!-- Switch para ocultar saldos pequeños (polvo) -->
        <div class="d-flex justify-content-end mb-3">
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="ocultar-polvo-switch">
                <label class="form-check-label text-white-50" for="ocultar-polvo-switch">Ocultar saldos pequeños</label>
            </div>
        </div>

        <!-- Tabla de Activos en la Billetera -->
        <table class="table table-dark table-striped align-middle"> <!-- Quitamos table-bordered -->
            <thead>
                <!-- Añadimos clases de alineación a las cabeceras -->
                <tr>
                    <th class="text-start ps-3">Activo</th>
                    <th class="text-end pe-3">Total</th>
                    <th class="text-end pe-3">Disponible</th>
                    <th class="text-end pe-3">En Órdenes</th>
                    <th class="text-end pe-3">Precio Actual</th>
                    <th class="text-end pe-3">Valor Total (USD)</th>
                    <th class="text-end pe-3">G/P (USD)</th>
                    <th class="text-end pe-3">G/P (%)</th>
                    <th class="text-end pe-3">% Billetera</th>
                </tr>
            </thead>
            <tbody id="tabla-billetera">
                <!-- El colspan sigue siendo 9, así que no cambia -->
                <tr>
                    <td colspan="9" class="text-center text-muted py-4">Cargando billetera...</td>
                </tr>
            </tbody>
        </table>

        <!-- Historial de Comisiones -->
        <div class="text-center mt-5">
            <h4 class="text-warning mb-4">Historial de Comisiones</h4>
        </div>

        <div class="table-responsive mt-4">
            <table class="table table-dark table-striped align-middle text-center">
                <thead class="table-secondary">
                    <tr class="table-dark">
                        <th>Fecha</th>
                        <th>Moneda (Fee)</th>
                        <th>Cantidad Cobrada</th>
                        <th>Valor (USD)</th>
                    </tr>
                </thead>
                <tbody id="tabla-comisiones">
                    <!-- El contenido será renderizado aquí por billeteraPage.js -->
                    <tr>
                        <td colspan="4" class="text-center text-muted py-4">Cargando historial de comisiones...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </main>

    <!-- ========== SCRIPTS ========== -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/billeteraPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/index.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BlocX</title>
	<link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.webp') }}" type="image/x-icon">
	<link rel="stylesheet" href="{{ url_for('static', filename='css/styles_index.css') }}">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
</head>

<body class="bg-dark text-white">


	<nav class="navbar navbar-expand-lg bg-black shadow">
		<div class="container-fluid">
			<a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
				<img src="{{ url_for('static', filename='img/logo_BlocX.webp') }}" alt="Logo" width="40" height="40">
				<span>BlocX</span>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
				<span class="navbar-toggler-icon bg-light"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarNav">
				<ul class="navbar-nav ms-auto">
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Contenedor para mensajes de error -->
	<div id="error-container" class="container-fluid mt-3"></div>

	<!-- Contenedor principal -->
	<main class="container-fluid mt-4">
		<div class="row">
			<div class="col-12">
				<div class="p-2 shadow text-center">
					<h3 class="text-warning">Cotizaciones</h3>
					<table class="table table-dark table-striped mt-4">
						<thead>
							<tr>
								<th class="text-start px-3">#</th>
								<th class="text-start px-3">Nombre</th>
								<th class="text-start px-3">Precio</th>
								<th class="text-end px-3">1h</th>
								<th class="text-end px-3">24h</th>
								<th class="text-end px-3">7d</th>
								<th class="text-end px-3">Cap. Mercado</th>
								<th class="text-end px-3">Volumen</th>
								<th class="text-end px-3">Suministro</th>
							</tr>
						</thead>
						<tbody id="tabla-datos" class="align-middle">
							<!-- Aquí se insertarán las filas con JS -->
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</main>

	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
	<script type="module" src="{{ url_for('static', filename='js/pages/indexPage.js') }}"></script>

</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/trading.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Trading</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.webp') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/select2-bootstrap-5-theme@1.3.0/dist/select2-bootstrap-5-theme.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
</head>

<body class="bg-dark text-white">

    <!-- ========== BARRA DE NAVEGACIÓN ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.webp') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes flash de Flask (ahora en un archivo parcial) -->
    {% include '_flashes.html' %}

    <!-- ========== CONTENIDO PRINCIPAL ========== -->
    <div class="container mt-4">
        <div class="row">
            <div class="col-md-7">
                <h3 class="text-light">Gráfico velas</h3>

                <div class="btn-group btn-group-sm mb-2" role="group" id="timeframe-selector">
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="5m">5m</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn"
                        data-interval="15m">15m</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="1h">1h</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="4h">4h</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn active"
                        data-interval="1d">1D</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="1w">1S</button>
                </div>

                <div class="form-check form-switch mb-2 d-inline-block ms-3">
                    <input class="form-check-input" type="checkbox" id="toggleVolume" checked>
                    <label class="form-check-label text-light" for="toggleVolume">Mostrar volumen</label>
                </div>

                <div class="py-3" style="position: relative;">
                    <div id="chart-error-overlay" class="chart-overlay" style="display: none;">
                        <span>No hay datos de gráfico disponibles para este par y temporalidad.</span>
                    </div>
                    <div id="chart"></div>
                </div>
            </div>

            <form class="col-md-5 p-3" id="formulario-trading" method="POST"
                action="{{ url_for('trading.procesar_trading_form') }}">
                <h2 class="text-warning">Trading</h2>
                <div class="row g-2 mb-3">
                    <div class="col-6">
                        <label for="cripto" class="form-label">Criptomoneda</label>
                        <select class="form-select" id="cripto" name="ticker" required></select>
                    </div>
                    <div class="col-6">
                        <div id="campo-pagar-con" style="display: none;">
                            <label for="moneda-pago" class="form-label">Pagar con</label>
                            <select class="form-select" id="moneda-pago" name="moneda-pago"></select>
                        </div>
                        <div id="campo-recibir-en" style="display: none;">
                            <label for="moneda-recibir" class="form-label">Recibir en</label>
                            <select class="form-select" id="moneda-recibir" name="moneda-recibir"></select>
                        </div>
                    </div>
                </div>
                <div class="btn-group mb-3 w-100" role="group" id="toggle-trade-type">
                    <input type="hidden" name="accion" id="accion" value="comprar">
                    <button type="button" class="btn w-50 btn-success active boton-comprar"
                        data-action="comprar">Comprar</button>
                    <button type="button" class="btn w-50 btn-outline-secondary boton-vender"
                        data-action="vender">Vender</button>
                </div>
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Tipo de orden</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-mercado" value="market"
                            autocomplete="off" checked>
                        <label class="btn btn-outline-primary rounded-start-pill" for="tipo-mercado">Mercado</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-limite" value="limit"
                            autocomplete="off">
                        <label class="btn btn-outline-primary" for="tipo-limite">Límite</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-stop-limit" value="stop-limit"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="tipo-stop-limit">Stop-Limit</label>
                    </div>
                </div>

                <!-- CAMPO NUEVO: Precio de Disparo -->
                <div class="mb-3" id="campo-precio-disparo" style="display: none;">
                    <label for="precio_disparo" class="form-label" id="label-precio-disparo">Precio Límite</label>
                    <input type="text" class="form-control" id="precio_disparo" placeholder="0.00" name="precio_disparo"
                        inputmode="decimal">
                </div>

                <div class="mb-3" id="campo-precio-limite" style="display: none;">
                    <label for="precio_limite" class="form-label">Precio Límite</label>
                    <input type="text" class="form-control" id="precio_limite" placeholder="0.00" name="precio_limite"
                        inputmode="decimal">
                </div>

                <div class="mb-3" id="campo-modo-ingreso">
                    <label class="form-label d-block mb-2">Ingresar por</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-monto" value="monto"
                            autocomplete="off" checked>
                        <label class="btn btn-outline-primary rounded-start-pill" for="modo-monto"
                            id="label-modo-monto">Cantidad (Cripto)</label>
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-total" value="total"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="modo-total"
                            id="label-modo-total">Total (USDT)</label>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="monto" class="form-label" id="label-monto">Cantidad</label>
                    <input type="text" class="form-control" id="monto" name="monto" placeholder="0.00" required
                        inputmode="decimal">
                </div>
                <div class="mb-3">


                </div>
                <div class="mb-3 text-end text-secondary">
                    <small>Disponible: <span id="saldo-disponible">--</span></small>
                </div>
                <button type="submit" class="btn w-100 btn-success boton-confirmar"
                    id="boton-confirmar">CONFIRMAR</button>
            </form>
        </div>

        <!-- SECCIÓN NUEVA: Órdenes Abiertas -->
        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">Órdenes Abiertas</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha Creación</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Acción</th>
                                <th>Precio Disparo</th>
                                <th>Cantidad</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-ordenes-abiertas">
                            <!-- El contenido será renderizado por JS -->
                            <tr>
                                <td colspan="7" class="text-center text-muted py-3">Cargando órdenes abiertas...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">Historial de transacciones</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Cantidad</th>
                                <th>Valor Total</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-historial">
                            <tr>
                                <td colspan="5" class="text-center text-muted py-3">Cargando historial...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== SECCIÓN SCRIPTS ===== -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js" defer></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.all.min.js" defer></script>
    <script src="{{ url_for('static', filename='js/utils/sweetalert-init.js') }}" defer></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/tradingPage.js') }}"></script>
</body>
</html>

==================================================
=== ARCHIVO: ./pytest.ini ===
==================================================

[pytest]
python_files = test_*.py
python_classes = Test*
python_functions = test_*
testpaths = tests


==================================================
=== ARCHIVO: ./README.md ===
==================================================

# Simulador Exchange - **BlokX**

Este proyecto educativo fue desarrollado en el marco de la materia "Algoritmos y Estructuras de Datos I" de UADE, bajo la supervisión de la profesora Julia Monasterio.  
Su objetivo es aplicar los conocimientos de la cátedra simulando el funcionamiento básico de un exchange de criptomonedas.  
El sistema permite a los usuarios operar con saldo ficticio utilizando datos reales de cotización obtenidos de CoinGecko y Binance.

## 🎯 Objetivos del proyecto

- Familiarizar a los usuarios con el entorno de un exchange de criptomonedas.
- Simular operaciones de compra y venta mediante distintos tipos de órdenes: Market, Limit y Stop-Loss.
- Calcular y visualizar ganancias, pérdidas y balances del portafolio.
- Almacenar toda la información de manera local utilizando archivos `.json`.
- Comprender la interacción entre frontend y backend mediante una arquitectura moderna (HTML, CSS, Flask y Python).

## ⚙️ Funcionalidades

### Panel general de cotizaciones
- Visualización del top de criptomonedas con:
  - Nombre, ticker, precio, market cap, volumen, supply.
  - Variación en 1h, 24h y 7 días.
- Actualización automática de precios cada 15 segundos.

### Panel de trading
En este panel se verán tres secciones diferentes que contemplan lo necesario para ejecutar las ordenes de compra/venta.

#### Gráfico de velas japonesas
- Grafico en el cual se va a poder visualizar los diferentes pares de criptos usando Lightweight Charts (Libreria de JavaScript), en diferentes time frames: 1m, 5m, 15m, 1h, 4hs, 1d y 1w.

#### Órdenes
- Compra y venta de activos con órdenes:
  - Market
  - Limit
  - Stop-loss
- Comisión fija del 0.5% por transacción.
- Validaciones de saldo y tenencias disponibles.

#### Historial
- Registro de todas las operaciones realizadas.
- Incluye tipo de orden, precio, cantidad, fecha y fee aplicado.
  
### Billetera
- Visualización de tenencias actuales:
  - Cantidad, precio promedio, valor actual, ganancia/pérdida por activo.
- Balance total del portafolio en USDT.

## 🧠 Cómo funciona el sistema

El sistema está diseñado bajo una arquitectura desacoplada que separa claramente las responsabilidades del backend y del frontend:

- **Backend (Python/Flask)**: Actúa como una API pura de JSON. Sus responsabilidades son:
    - **`rutas/`**: Define los endpoints de la API (`/api/...`) que exponen los datos y la lógica de negocio en formato JSON. También sirve el contenedor HTML inicial de cada página.
    - **`servicios/`**: Contiene toda la lógica de negocio (cálculos de billetera, procesamiento de órdenes, formato de datos) y prepara los datos para ser enviados como JSON.
    - **`acceso_datos/`**: Gestiona la lectura y escritura de los archivos `.json` que actúan como base de datos.
    - **`utils/`**: Proporciona funciones de utilidad, como formateadores de datos que se aplican en el backend.

- **Frontend (JavaScript)**: Es un cliente dinámico que consume la API del backend.
    - **Autónomo**: Cada página carga su propio HTML y luego utiliza JavaScript para buscar todos los datos que necesita de los endpoints `/api/...`.
    - **Renderizado en el cliente**: Todo el renderizado y la manipulación del DOM (actualización de tablas, saldos, gráficos) se realiza en el navegador, creando una experiencia de usuario fluida y rápida sin recargas de página.
    - **Estructura modular en `js/`**:
        - **`pages/`**: Contiene la lógica de inicialización y orquestación para cada página principal (ej. `tradingPage.js`).
        - **`components/`**: Módulos encargados de actualizar partes específicas de la interfaz (ej. `uiUpdater.js`, `tablaCotizacionesUI.js`).
        - **`services/`**: Gestiona la comunicación con la API del backend.

### Flujo desacoplado

1.  El usuario navega a una URL (ej. `/trading`).
2.  Flask sirve un archivo HTML mínimo (`trading.html`) que actúa como un esqueleto.
3.  El archivo JavaScript asociado a esa página (`tradingPage.js`) se ejecuta.
4.  El script de JS realiza llamadas a los endpoints de la API del backend (`/api/cotizaciones`, `/api/historial`, etc.) para obtener los datos en formato JSON.
5.  Una vez recibidos los datos, JavaScript actualiza dinámicamente el DOM para mostrar la información al usuario.

## 🗃️ Estructura del proyecto

```
simulador_exchange/
├── backend/
│   ├── app.py                      # Servidor Flask y punto de entrada
│   ├── config.py                   # Configuración del sistema y constantes globales
│   ├── rutas/                      # Blueprints que definen las vistas y API endpoints
│   │   ├── __init__.py
│   │   ├── home.py
│   │   ├── trading_vista.py
│   │   ├── billetera_vista.py
│   │   └── api_externa.py
│   ├── servicios/                  # Lógica de negocio de cada módulo
│   │   ├── api_cotizaciones.py
│   │   ├── estado_billetera.py
│   │   ├── transacciones.py
│   │   └── trading/                # Lógica de ejecución de órdenes
│   │       ├── gestor.py         # Orquesta la creación y validación
│   │       ├── procesador.py     # Procesa y guarda las órdenes
│   │       ├── motor.py          # Verifica y ejecuta órdenes pendientes
│   │       └── ejecutar_orden.py # Lógica final de transacción
│   ├── acceso_datos/               # Acceso y manipulación de archivos .json
│   │   ├── datos_billetera.py
│   │   ├── datos_cotizaciones.py
│   │   └── datos_historial.py
│   └── utils/                      # Utilidades auxiliares
│       └── formatters.py
│
├── frontend/
│   ├── templates/                  # Plantillas HTML (contenedores iniciales)
│   │   ├── index.html
│   │   ├── billetera.html
│   │   └── trading.html
│   └── static/                     # Archivos estáticos
│       ├── css/
│       │   ├── styles_index.css
│       │   └── styles_trading.css
│       ├── img/
│       │   └── logo_BlocX.webp
│       └── js/                     # Lógica del cliente
│           ├── components/         # Módulos para actualizar la UI
│           ├── pages/              # Scripts de orquestación por página
│           └── services/           # Servicios de comunicación con la API
│
├── datos/                          # Archivos de persistencia
│   ├── billetera.json
│   ├── datos_cotizaciones.json
│   ├── datos_velas.json
│   └── historial_operaciones.json
│
├── requirements.txt
├── .gitignore
└── README.md
```

## 🚀 Cómo ejecutar el proyecto

### 1. Crear entorno virtual (recomendado)
```bash
python3 -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

### 2. Instalar dependencias
```bash
pip install -r requirements.txt
```

### 3. Iniciar la app
```bash
python3 app.py
```

Y luego acceder desde el navegador a:  
```
http://localhost:5000
```

## 📦 Tecnologías utilizadas

- Python 3.13
- Flask
- HTML, CSS, JavaScript
- Lightweight Charts (TradingView)

## 📌 Notas

- Todos los datos se almacenan localmente en formato JSON.
- No se requiere conexión a bases de datos externas.
- El sistema está pensado para ser didáctico y extensible.

---

**Grupo 12**  
Fausto Lovera — Patricio Menta — Andrei Veis


==================================================
=== ARCHIVO: ./requirements.txt ===
==================================================

# Backend
Flask==3.1.0
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
requests==2.32.3
Werkzeug==3.1.3
python-dotenv==1.0.1

# Pruebas
pytest-xdist==3.6.1


==================================================
=== ARCHIVO: ./run.py ===
==================================================

# run.py

from backend import crear_app

# Crear la instancia de la aplicación Flask utilizando la factory.
app = crear_app()

if __name__ == '__main__':
    # Ejecutar la aplicación.
    # El host '0.0.0.0' hace que el servidor sea accesible desde otras máquinas en la misma red.
    # El modo de depuración se activa para facilitar el desarrollo.
    app.run(host='0.0.0.0', port=5001, debug=True)


==================================================
=== ARCHIVO: ./tests/__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./tests/conftest.py ===
==================================================

import pytest
import os
import json
import config

@pytest.fixture
def test_environment(tmp_path, monkeypatch):
    """
    Crea un entorno de prueba aislado con archivos de datos temporales.

    Este fixture crea un directorio temporal y redirige las constantes de ruta
    del módulo `config` para que apunten a archivos dentro de ese directorio.
    Esto asegura que los tests no lean ni modifiquen los datos reales de la aplicación.

    Uso:
        def mi_test(test_environment):
            # Ahora las funciones del backend usarán los archivos temporales.
            # ...
    """
    # Crear un subdirectorio para los datos de prueba para mayor orden
    datos_dir = tmp_path / "datos_test"
    datos_dir.mkdir()

    # Rutas a los archivos temporales
    billetera_path = datos_dir / "billetera.json"
    historial_path = datos_dir / "historial.json"
    ordenes_path = datos_dir / "ordenes_pendientes.json"
    cotizaciones_path = datos_dir / "cotizaciones.json"
    comisiones_path = datos_dir / "comisiones.json"

    # Redirigir las constantes del módulo config usando monkeypatch
    monkeypatch.setattr(config, 'BILLETERA_PATH', str(billetera_path))
    monkeypatch.setattr(config, 'HISTORIAL_PATH', str(historial_path))
    monkeypatch.setattr(config, 'ORDENES_PENDIENTES_PATH', str(ordenes_path))
    monkeypatch.setattr(config, 'COTIZACIONES_PATH', str(cotizaciones_path))
    monkeypatch.setattr(config, 'COMISIONES_PATH', str(comisiones_path))

    # Se puede inicializar archivos si es necesario, por ejemplo:
    with open(billetera_path, 'w') as f:
        json.dump({}, f)
    with open(historial_path, 'w') as f:
        json.dump([], f)
    with open(ordenes_path, 'w') as f:
        json.dump([], f)
    with open(cotizaciones_path, 'w') as f:
        json.dump([], f)
    with open(comisiones_path, 'w') as f:
        json.dump({}, f)

    # El fixture puede devolver las rutas si algún test las necesita
    yield {
        "billetera": str(billetera_path),
        "historial": str(historial_path),
        "ordenes": str(ordenes_path),
        "cotizaciones": str(cotizaciones_path),
        "comisiones": str(comisiones_path)
    }

    # La limpieza es automática gracias a tmp_path


==================================================
=== ARCHIVO: ./tests/test_datos_cotizaciones.py ===
==================================================

import json
from decimal import Decimal

# La importación se corrige para apuntar al móduloimport json
import pytest
import config
from pathlib import Path

from backend.acceso_datos.datos_cotizaciones import (
    cargar_datos_cotizaciones,
    guardar_datos_cotizaciones,
    obtener_precio,
    recargar_cache_precios
)

def test_guardar_y_cargar_datos_cotizaciones_con_ruta_temporal(test_environment):
    """
    Prueba que se puedan guardar y luego cargar datos de cotizaciones
    usando un archivo temporal gestionado por el fixture.
    """
    # 1. Preparación: Los datos se guardarán en la ruta gestionada por el fixture.
    datos_a_guardar = [
        {'ticker': 'BTC', 'nombre': 'Bitcoin', 'precio_usd': "50000.12345678"},
        {'ticker': 'ETH', 'nombre': 'Ethereum', 'precio_usd': "3000.87654321"}
    ]

    # 2. Ejecución (Guardar): la función usará la ruta parcheada por el fixture.
    guardar_datos_cotizaciones(datos_a_guardar)

    # 3. Verificación (Guardar): comprobamos que el archivo se escribió correctamente.
    ruta_temporal = Path(test_environment['cotizaciones'])
    assert ruta_temporal.exists()
    datos_leidos_raw = json.loads(ruta_temporal.read_text(encoding='utf-8'))
    
    assert len(datos_leidos_raw) == 2
    assert datos_leidos_raw[0]['precio_usd'] == "50000.12345678"

    # 4. Ejecución (Cargar): leemos desde la misma ruta temporal.
    datos_cargados = cargar_datos_cotizaciones()

    # 5. Verificación (Cargar): comprobamos que los datos se cargaron correctamente.
    assert datos_cargados == datos_leidos_raw

def test_cargar_datos_cotizaciones_archivo_no_existente(monkeypatch):
    """
    Prueba que `cargar_datos_cotizaciones` devuelva una lista vacía si el
    archivo especificado no existe.
    """
    # Forzamos que la ruta apunte a un archivo que no existe
    monkeypatch.setattr(config, 'COTIZACIONES_PATH', './ruta/inexistente.json')
    resultado = cargar_datos_cotizaciones()
    assert resultado == []

def test_guardar_datos_actualiza_cache_correctamente(test_environment):
    """
    Verifica que guardar nuevas cotizaciones en un archivo actualiza 
    correctamente el caché de precios global que usa `obtener_precio`.
    """
    # 1. Preparación:
    # El fixture `test_environment` ya ha redirigido la ruta a un archivo temporal
    # y lo ha creado vacío. Forzamos una recarga para asegurar que el caché esté vacío.
    recargar_cache_precios()
    assert obtener_precio('TESTCOIN') is None

    # 2. Ejecución:
    # Guardamos datos de prueba. El fixture asegura que se usa el archivo temporal.
    datos_test = [{'ticker': 'TESTCOIN', 'nombre': 'Test Coin', 'precio_usd': "9999"}]
    guardar_datos_cotizaciones(datos_test)

    # 3. Verificación:
    # La función `guardar_datos_cotizaciones` debe haber recargado el caché global.
    # Ahora, `obtener_precio` debe devolver el nuevo valor.
    assert obtener_precio('TESTCOIN') == Decimal("9999")

==================================================
=== ARCHIVO: ./tests/test_ejecutar_orden.py ===
==================================================

# --- FILENAME: tests/test_ejecutar_orden.py ---

import pytest
import json
from decimal import Decimal

from backend.servicios.trading.ejecutar_orden import ejecutar_transaccion
from backend.acceso_datos.datos_billetera import cargar_billetera
from config import TASA_COMISION, BILLETERA_PATH, COTIZACIONES_PATH, HISTORIAL_PATH, COMISIONES_PATH

def test_ejecucion_exitosa_orden_mercado(test_environment):
    """
    Prueba un flujo de compra de mercado completo, verificando los archivos resultantes.
    """
    # ARRANGE: Crear los archivos necesarios en el directorio temporal
    # 1. Crear billetera.json inicial
    billetera_inicial_dict = {
        "USDT": {"nombre": "Tether", "saldos": {"disponible": "10000.0", "reservado": "0.0"}},
        "BTC": {"nombre": "Bitcoin", "saldos": {"disponible": "1.0", "reservado": "0.5"}}
    }
    with open(BILLETERA_PATH, 'w') as f:
        json.dump(billetera_inicial_dict, f)

    # 2. Crear cotizaciones.json con precios
    cotizaciones_dict = [
        {"ticker": "USDT", "precio_usd": "1.0"},
        {"ticker": "BTC", "precio_usd": "50000.0"}
    ]
    with open(COTIZACIONES_PATH, 'w') as f:
        json.dump(cotizaciones_dict, f)
        
    # ACT: Ejecutar la transacción
    cantidad_a_gastar_bruta = Decimal('1000')
    billetera_cargada = cargar_billetera() # La función a probar necesita el objeto billetera

    exito, detalles = ejecutar_transaccion(
        billetera=billetera_cargada,
        moneda_origen='USDT',
        cantidad_origen_bruta=cantidad_a_gastar_bruta,
        moneda_destino='BTC',
        tipo_operacion_historial='Compra Mercado',
        es_orden_pendiente=False
    )

    # ASSERT: Verificar el estado final de los archivos
    assert exito is True

    # 1. Verificar el diccionario de detalles devuelto
    comision_esperada = cantidad_a_gastar_bruta * TASA_COMISION
    cantidad_neta_esperada = cantidad_a_gastar_bruta - comision_esperada
    cantidad_destino_esperada = cantidad_neta_esperada / Decimal('50000')
    assert detalles['cantidad_comision'] == comision_esperada
    assert detalles['cantidad_destino_final'] == cantidad_destino_esperada

    # 2. Verificar el archivo de historial
    with open(HISTORIAL_PATH, 'r') as f:
        historial = json.load(f)
    assert len(historial) == 1
    assert historial[0]['tipo'] == 'Compra Mercado'
    assert historial[0]['destino']['ticker'] == 'BTC'

    # 3. Verificar el archivo de comisiones
    with open(COMISIONES_PATH, 'r') as f:
        comisiones = json.load(f)
    assert len(comisiones) == 1
    assert comisiones[0]['ticker'] == 'USDT'
    assert Decimal(comisiones[0]['cantidad']) == comision_esperada.quantize(Decimal("0.00000001"))

    # 4. Verificar el estado final de la billetera (leyendo el objeto modificado)
    assert billetera_cargada['USDT']['saldos']['disponible'] == Decimal('9000') # 10000 - 1000
    assert billetera_cargada['BTC']['saldos']['disponible'] == Decimal('1') + cantidad_destino_esperada
    assert billetera_cargada['BTC']['saldos']['reservado'] == Decimal('0.5') # No debe cambiar

==================================================
=== ARCHIVO: ./tests/test_estado_billetera.py ===
==================================================

import pytest
import json
from decimal import Decimal

# Importamos las funciones a probar, ahora refactorizadas
from backend.servicios.estado_billetera import (
    _calcular_metricas_activo,
    _preparar_datos_compra,
    estado_actual_completo,
    obtener_historial_formateado
)

# --- Fixtures: Datos de prueba reutilizables ---

@pytest.fixture
def datos_compra_btc():
    """Fixture que proporciona datos de compra para Bitcoin."""
    return {
        "total_invertido": Decimal("45000"),
        "cantidad_comprada": Decimal("1.5")
    }

# --- Tests para las funciones puras (sin cambios, no dependen de I/O) ---

def test_preparar_datos_compra_mixto():
    """
    Prueba que solo se suman compras (ignora ventas y USDT) y agrupa por ticker.
    """
    historial = [
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "venta", "destino": {"ticker": "BTC", "cantidad": "0.5"}, "valor_usd": "15000"},
        {"tipo": "compra", "destino": {"ticker": "ETH", "cantidad": "2.0"}, "valor_usd": "20000"},
        {"tipo": "compra", "destino": {"ticker": "USDT", "cantidad": "1000"}, "valor_usd": "1000"},
    ]
    resultado = _preparar_datos_compra(historial)
    assert set(resultado.keys()) == {"BTC", "ETH"}
    assert resultado["BTC"]["total_invertido"] == Decimal("30000")
    assert resultado["BTC"]["cantidad_comprada"] == Decimal("1.0")
    assert resultado["ETH"]["total_invertido"] == Decimal("20000")
    assert resultado["ETH"]["cantidad_comprada"] == Decimal("2.0")

def test_preparar_datos_compra_vacio():
    """
    Prueba que un historial vacío retorna un diccionario vacío.
    """
    resultado = _preparar_datos_compra([])
    assert resultado == {}

def test_preparar_datos_compra_sin_compras():
    """
    Prueba que un historial sin compras retorna un diccionario vacío.
    """
    historial = [
        {"tipo": "venta", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "transferencia", "destino": {"ticker": "ETH", "cantidad": "2.0"}, "valor_usd": "20000"},
    ]
    resultado = _preparar_datos_compra(historial)
    assert resultado == {}

def test_preparar_datos_compra_agrupa_multiples_compras():
    """
    Prueba que agrupa correctamente múltiples compras del mismo activo.
    """
    historial = [
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "0.5"}, "valor_usd": "15000"},
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "0.25"}, "valor_usd": "7000"},
    ]
    resultado = _preparar_datos_compra(historial)
    assert set(resultado.keys()) == {"BTC"}
    assert resultado["BTC"]["total_invertido"] == Decimal("52000")
    assert resultado["BTC"]["cantidad_comprada"] == Decimal("1.75")


def test_calcular_metricas_activo(datos_compra_btc):
    """Prueba la función de cálculo de métricas para un activo."""
    ticker = "BTC"
    cantidad_actual = Decimal("1.5")
    precio_actual = Decimal("40000")
    
    resultado = _calcular_metricas_activo(ticker, cantidad_actual, precio_actual, datos_compra_btc)

    assert resultado["ticker"] == "BTC"
    assert resultado["cantidad"] == cantidad_actual
    assert resultado["precio_actual"] == precio_actual
    assert resultado["valor_usdt"] == cantidad_actual * precio_actual
    assert resultado["precio_promedio_compra"] == Decimal("30000")
    assert resultado["costo_base_actual"] == cantidad_actual * Decimal("30000")
    assert resultado["ganancia_perdida"] == (cantidad_actual * precio_actual) - (cantidad_actual * Decimal("30000"))

# --- Tests para las funciones con I/O (refactorizados) ---

def test_estado_actual_completo_con_archivos_temporales(tmp_path):
    """
    Prueba [estado_actual_completo](cci:1://file:///Users/andreiveis/UADE/2do%20cuatrimestre/05_Algoritmos%20y%20Estructura%20de%20datos%20I/Trabajo_Simulador_Exchange/backend/servicios/estado_billetera.py:76:0-132:36) usando archivos temporales reales,
    eliminando la necesidad de mocks y fixtures de datos.
    """
    # 1. Preparación: Crear archivos de datos temporales
    ruta_billetera = tmp_path / "billetera.json"
    ruta_historial = tmp_path / "historial.json"
    ruta_cotizaciones = tmp_path / "cotizaciones.json"

    billetera_data = {
        "BTC": {"saldos": {"disponible": "1.5", "reservado": "0"}},
        "ETH": {"saldos": {"disponible": "2.0", "reservado": "0"}},
        "DOGE": {"saldos": {"disponible": "0", "reservado": "0"}}
    }
    historial_data = [
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "0.5"}, "valor_usd": "15000"},
        {"tipo": "compra", "destino": {"ticker": "ETH", "cantidad": "2.0"}, "valor_usd": "20000"}
    ]
    cotizaciones_data = [
        {"ticker": "BTC", "nombre": "Bitcoin", "precio_usd": "40000", "logo": "logo_btc.png"},
        {"ticker": "ETH", "nombre": "Ethereum", "precio_usd": "1500", "logo": "logo_eth.png"}
    ]

    ruta_billetera.write_text(json.dumps(billetera_data), encoding='utf-8')
    ruta_historial.write_text(json.dumps(historial_data), encoding='utf-8')
    ruta_cotizaciones.write_text(json.dumps(cotizaciones_data), encoding='utf-8')

    # 2. Ejecución
    resultado_lista = estado_actual_completo(
        ruta_billetera=str(ruta_billetera),
        ruta_historial=str(ruta_historial),
        ruta_cotizaciones=str(ruta_cotizaciones)
    )

    # 3. Verificación
    assert isinstance(resultado_lista, list)
    assert len(resultado_lista) == 2
    assert resultado_lista[0]['ticker'] == 'BTC'
    assert resultado_lista[1]['ticker'] == 'ETH'
    assert not any(activo['ticker'] == 'DOGE' for activo in resultado_lista)

    btc = resultado_lista[0]
    eth = resultado_lista[1]

    assert btc["ticker"] == "BTC"
    assert btc["cantidad_total"] == "1.5"
    assert btc["valor_usdt_formatted"] == "$60,000.00"
    assert btc["logo"] == "logo_btc.png"
    assert btc["ganancia_perdida_formatted"] == "+$15,000.00"

    assert eth["ticker"] == "ETH"
    assert eth["cantidad_total"] == "2.0"
    assert eth["valor_usdt_formatted"] == "$3,000.00"
    assert eth["logo"] == "logo_eth.png"
    assert eth["ganancia_perdida_formatted"] == "-$17,000.00"

def test_obtener_historial_formateado_con_archivo_temporal(tmp_path):
    """
    Prueba que obtener_historial_formateado procese correctamente un
    archivo de historial temporal.
    """
    ruta_historial = tmp_path / "historial_test.json"
    historial_data = [
        {
            "id": "123", "tipo": "compra", "timestamp": "2023-10-27T10:00:00Z",
            "origen": {"ticker": "USDT"},
            "destino": {"ticker": "BTC", "cantidad": "0.5"},
            "valor_usd": "25000"
        }
    ]
    ruta_historial.write_text(json.dumps(historial_data), encoding='utf-8')

    resultado = obtener_historial_formateado(ruta_historial=str(ruta_historial))

    assert len(resultado) == 1
    item = resultado[0]
    assert item["id"] == "123"
    assert item["tipo_formatted"] == "Compra"
    assert item["par_formatted"] == "BTC/USDT"
    assert "27/10/2023" in item["fecha_formatted"]
    assert item["cantidad_formatted"] == "0.50000000 BTC"
    assert item["valor_total_formatted"] == "$25,000.00"

==================================================
=== ARCHIVO: ./tests/test_trading_gestor.py ===
==================================================

# --- FILENAME: tests/test_trading_gestor.py (VERSIÓN SIMPLIFICADA) ---
import pytest
import json
from decimal import Decimal

# Importar la función a probar
from backend.servicios.trading.gestor import cancelar_orden_pendiente
# Importar funciones de acceso a datos para verificar
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes
# Importar el módulo config para redirigir las rutas temporalmente
import config

def crear_archivo_json(ruta, contenido):
    """Función de ayuda para crear archivos JSON en los tests."""
    with open(ruta, 'w') as f:
        json.dump(contenido, f, indent=4)

def test_cancelacion_exitosa_con_archivos(tmp_path):
    """
    Prueba que una orden pendiente se cancela y los fondos se liberan,
    interactuando con archivos temporales.
    """
    # Arrange: Preparar el entorno de archivos temporales
    datos_dir = tmp_path / "datos"
    datos_dir.mkdir()
    config.BILLETERA_PATH = str(datos_dir / "billetera.json")
    config.ORDENES_PENDIENTES_PATH = str(datos_dir / "ordenes.json")
    # Para la llamada a estado_actual_completo
    config.HISTORIAL_PATH = str(datos_dir / "historial.json")
    config.COTIZACIONES_PATH = str(datos_dir / "cotizaciones.json")
    
    crear_archivo_json(config.BILLETERA_PATH, {
        "USDT": {"saldos": {"disponible": "10000.0", "reservado": "0.0"}},
        "BTC": {"saldos": {"disponible": "1.0", "reservado": "0.5"}}
    })
    crear_archivo_json(config.ORDENES_PENDIENTES_PATH, [
        {"id_orden": "btc_venta_1", "estado": "pendiente", "moneda_reservada": "BTC", "cantidad_reservada": "0.5", "par": "BTC/USDT"},
        {"id_orden": "eth_compra_1", "estado": "ejecutada", "moneda_reservada": "USDT", "cantidad_reservada": "1000"}
    ])
    # Archivos vacíos necesarios para estado_actual_completo
    crear_archivo_json(config.HISTORIAL_PATH, [])
    crear_archivo_json(config.COTIZACIONES_PATH, [])

    # Act
    resultado = cancelar_orden_pendiente("btc_venta_1")

    # Assert
    assert "error" not in resultado
    assert "Orden BTC/USDT cancelada" in resultado["mensaje"]
    
    # Verificar leyendo directamente los archivos modificados
    billetera_final = cargar_billetera(config.BILLETERA_PATH)
    ordenes_finales = cargar_ordenes_pendientes(config.ORDENES_PENDIENTES_PATH)
    
    # Fondos liberados
    assert billetera_final["BTC"]["saldos"]["reservado"] == Decimal("0")
    assert billetera_final["BTC"]["saldos"]["disponible"] == Decimal("1.5")
    
    # Estado de la orden cambiado
    orden_cancelada = next(o for o in ordenes_finales if o["id_orden"] == "btc_venta_1")
    assert orden_cancelada["estado"] == "cancelada"

def test_cancelar_orden_inexistente(tmp_path):
    """Prueba que falla al intentar cancelar una orden que no existe."""
    # Arrange: Solo necesitamos un archivo de órdenes vacío
    datos_dir = tmp_path / "datos"
    datos_dir.mkdir()
    config.ORDENES_PENDIENTES_PATH = str(datos_dir / "ordenes.json")
    crear_archivo_json(config.ORDENES_PENDIENTES_PATH, [])

    # Act
    resultado = cancelar_orden_pendiente("id_invalido")

    # Assert
    assert "error" in resultado
    assert "No se encontró una orden" in resultado["error"]

==================================================
=== ARCHIVO: ./tests/test_trading_motor.py ===
==================================================

# --- FILENAME: tests/test_trading_motor.py (VERSIÓN SIMPLIFICADA) ---
import pytest
import json
from decimal import Decimal

# Funciones puras a probar
from backend.servicios.trading.motor import _verificar_condicion_orden
# Función principal de integración a probar
from backend.servicios.trading.motor import verificar_y_ejecutar_ordenes_pendientes

# Funciones de acceso a datos para verificar resultados
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes

# Módulo de configuración para redirigir rutas
import config

# --- Tests para la lógica pura de verificación (sin cambios) ---

@pytest.mark.parametrize("accion, tipo, precio_limite, precio_mercado, esperado", [
    ("compra", "limit", "40000", "39000", True),
    ("compra", "limit", "40000", "40001", False),
    ("venta", "limit", "60000", "61000", True),
    ("venta", "limit", "60000", "59999", False),
    ("compra", "stop-limit", "55000", "56000", True),
    ("compra", "stop-limit", "55000", "54999", False),
    ("venta", "stop-limit", "45000", "44000", True),
    ("venta", "stop-limit", "45000", "45001", False),
])
def test_verificar_condicion_orden(accion, tipo, precio_limite, precio_mercado, esperado):
    orden = {"accion": accion, "tipo_orden": tipo, "precio_disparo": precio_limite}
    assert _verificar_condicion_orden(orden, Decimal(precio_mercado)) is esperado

# --- Tests para la función principal del motor (simplificados) ---

def crear_archivo_json(ruta, contenido):
    """Función de ayuda para crear archivos JSON en los tests."""
    with open(ruta, 'w') as f:
        json.dump(contenido, f, indent=4)

def test_motor_ejecuta_orden_favorable_con_archivos(tmp_path):
    """
    Prueba que el motor ejecuta una orden si el precio es favorable,
    interactuando con archivos temporales.
    """
    # Arrange: Preparar el entorno de archivos temporales
    datos_dir = tmp_path / "datos"
    datos_dir.mkdir()
    config.BILLETERA_PATH = str(datos_dir / "billetera.json")
    config.ORDENES_PENDIENTES_PATH = str(datos_dir / "ordenes.json")
    config.COTIZACIONES_PATH = str(datos_dir / "cotizaciones.json")
    config.HISTORIAL_PATH = str(datos_dir / "historial.json") # Necesario para ejecutar_transaccion
    config.COMISIONES_PATH = str(datos_dir / "comisiones.json") # Necesario para ejecutar_transaccion

    # Datos de prueba
    crear_archivo_json(config.BILLETERA_PATH, {
        "USDT": {"saldos": {"disponible": "0", "reservado": "4000"}}
    })
    crear_archivo_json(config.ORDENES_PENDIENTES_PATH, [{
        "id_orden": "1", "par": "BTC/USDT", "estado": "pendiente", "accion": "compra", 
        "tipo_orden": "limit", "precio_disparo": "40000", "moneda_reservada": "USDT",
        "cantidad_reservada": "4000", "moneda_destino": "BTC", "moneda_origen": "USDT",
        "cantidad_cripto_principal": "0.1"
    }])
    # Precio favorable para la compra límite
    crear_archivo_json(config.COTIZACIONES_PATH, [
        {"ticker": "BTC", "precio_usd": "39000"},
        {"ticker": "USDT", "precio_usd": "1"}
    ])

    # Act: Ejecutar el motor
    verificar_y_ejecutar_ordenes_pendientes()

    # Assert: Verificar el estado final de los archivos
    ordenes_finales = cargar_ordenes_pendientes(config.ORDENES_PENDIENTES_PATH)
    billetera_final = cargar_billetera(config.BILLETERA_PATH)

    assert ordenes_finales[0]["estado"] == "ejecutada"
    assert billetera_final["USDT"]["saldos"]["reservado"] == Decimal("0")
    assert "BTC" in billetera_final
    assert billetera_final["BTC"]["saldos"]["disponible"] > 0

==================================================
=== ARCHIVO: ./tests/test_trading_procesador.py ===
==================================================

# --- FILENAME: tests/test_trading_procesador.py ---

import pytest
from decimal import Decimal
import json

# Las funciones de bajo nivel son "puras", sus tests no necesitan mocks
from backend.servicios.trading.procesador import _validar_saldo_disponible, _calcular_detalles_intercambio
# Probaremos esta función que sí interactúa con archivos
from backend.servicios.trading.procesador import _crear_orden_pendiente
from config import BILLETERA_PATH, ORDENES_PENDIENTES_PATH

# --- Tests para funciones puras (sin cambios) ---

def test_validar_saldo_suficiente():
    billetera_fake = {"BTC": {"saldos": {"disponible": Decimal("2.5")}}}
    exito, mensaje = _validar_saldo_disponible(billetera_fake, "BTC", Decimal("1.0"))
    assert exito is True

def test_validar_saldo_insuficiente():
    billetera_fake = {"BTC": {"saldos": {"disponible": Decimal("2.5")}}}
    exito, mensaje = _validar_saldo_disponible(billetera_fake, "BTC", Decimal("3.0"))
    assert exito is False
    assert "Saldo insuficiente" in mensaje

# ... (puedes mantener el test parametrizado de _calcular_detalles_intercambio si quieres) ...

# --- Test para _crear_orden_pendiente (estilo básico) ---

def test_crear_orden_limite_reserva_fondos_correctamente(test_environment):
    """
    Prueba que se crea una orden pendiente y se reservan los fondos en la billetera.
    """
    # ARRANGE: Crear el archivo de billetera inicial
    billetera_inicial_dict = {
        "USDT": {"nombre": "Tether", "saldos": {"disponible": "10000.0", "reservado": "0.0"}},
        "BTC": {"nombre": "Bitcoin", "saldos": {"disponible": "2.5", "reservado": "0.0"}}
    }
    with open(BILLETERA_PATH, 'w') as f:
        json.dump(billetera_inicial_dict, f)

    # ACT: Llamar a la función para crear una orden de compra límite gastando 1000 USDT
    exito, resultado = _crear_orden_pendiente(
        moneda_origen='USDT', 
        moneda_destino='BTC', 
        monto_form=Decimal('1000'), 
        modo_ingreso='total', 
        precio_disparo=Decimal('40000'), 
        tipo_orden='limit', 
        accion='comprar',
        precio_limite=None
    )

    # ASSERT
    assert exito is True
    assert "Orden Limit Creada" in resultado["titulo"]

    # 1. Verificar el archivo de órdenes pendientes
    with open(ORDENES_PENDIENTES_PATH, 'r') as f:
        ordenes = json.load(f)
    assert len(ordenes) == 1
    orden_creada = ordenes[0]
    assert orden_creada['estado'] == 'pendiente'
    assert orden_creada['accion'] == 'comprar'
    assert orden_creada['par'] == 'BTC/USDT' # Corregido: El par debe ser MonedaPrincipal/MonedaCotizada (BTC/USDT)
    assert orden_creada['moneda_reservada'] == 'USDT'
    assert Decimal(orden_creada['cantidad_reservada']) == Decimal('1000')

    # 2. Verificar el archivo de billetera modificado
    with open(BILLETERA_PATH, 'r') as f:
        billetera_final = json.load(f)
    assert Decimal(billetera_final['USDT']['saldos']['disponible']) == Decimal('9000')
    assert Decimal(billetera_final['USDT']['saldos']['reservado']) == Decimal('1000')

==================================================
=== ARCHIVO: ./tests/test_utilidades_numericas.py ===
==================================================

import pytest
from decimal import Decimal
from backend.utils.utilidades_numericas import a_decimal, cuantizar_cripto, cuantizar_usd

# --- Tests para a_decimal ---

def test_a_decimal_str():
    """
    Prueba que convierte un string válido a Decimal.
    """
    assert a_decimal("123.45") == Decimal("123.45")

def test_a_decimal_int():
    """
    Prueba que convierte un int a Decimal.
    """
    assert a_decimal(123) == Decimal("123")

def test_a_decimal_float():
    """
    Prueba que convierte un float a Decimal.
    """
    assert a_decimal(123.45) == Decimal("123.45")

def test_a_decimal_none():
    """
    Prueba que None devuelve Decimal('0').
    """
    assert a_decimal(None) == Decimal("0")

def test_a_decimal_invalid_str():
    """
    Prueba que un string inválido devuelve Decimal('0').
    """
    assert a_decimal("hola") == Decimal("0")

# --- Tests para cuantizar_cripto ---

def test_cuantizar_cripto_redondeo():
    """
    Prueba que cuantizar_cripto redondea correctamente a 8 decimales.
    """
    valor = Decimal("0.123456789")
    assert cuantizar_cripto(valor) == Decimal("0.12345679")

# --- Tests para cuantizar_usd ---

def test_cuantizar_usd_redondeo():
    """
    Prueba que cuantizar_usd redondea correctamente a 4 decimales.
    """
    valor = Decimal("123.45678")
    assert cuantizar_usd(valor) == Decimal("123.4568")

# --- Tests para formato_cantidad_cripto ---

def test_formato_cantidad_cripto_entero():
    """
    Prueba que un número entero se formatea correctamente con separador de miles.
    """
    from backend.utils.utilidades_numericas import formato_cantidad_cripto
    assert formato_cantidad_cripto(Decimal('10000')) == "10,000"

def test_formato_cantidad_cripto_decimales():
    """
    Prueba que un número con decimales se formatea correctamente.
    """
    from backend.utils.utilidades_numericas import formato_cantidad_cripto
    assert formato_cantidad_cripto(Decimal('12345.67')) == "12,345.67"

def test_formato_cantidad_cripto_elimina_ceros():
    """
    Prueba que elimina ceros decimales sobrantes.
    """
    from backend.utils.utilidades_numericas import formato_cantidad_cripto
    assert formato_cantidad_cripto(Decimal('12.1200')) == "12.12"

# --- Tests para formato_cantidad_usd ---

def test_formato_cantidad_usd_basico():
    """
    Prueba que un valor se formatea como USD con símbolo y formato correcto.
    """
    from backend.utils.utilidades_numericas import formato_cantidad_usd
    assert formato_cantidad_usd(Decimal('12345.67')) == "$12,345.67"

def test_formato_cantidad_usd_elimina_ceros():
    """
    Prueba que elimina ceros decimales sobrantes en USD.
    """
    from backend.utils.utilidades_numericas import formato_cantidad_usd
    assert formato_cantidad_usd(Decimal('10.1000')) == "$10.1"

# --- Tests para formato_numero_grande ---

def test_formato_numero_grande_millon():
    """
    Prueba que un valor en millones se formatea con 'M'.
    """
    from backend.utils.utilidades_numericas import formato_numero_grande
    assert formato_numero_grande(Decimal('1500000')) == "$1.50M"

def test_formato_numero_grande_billones():
    """
    Prueba que un valor en miles de millones se formatea con 'B'.
    """
    from backend.utils.utilidades_numericas import formato_numero_grande
    assert formato_numero_grande(Decimal('2500000000')) == "$2.50B"

def test_formato_numero_grande_menor_millon():
    """
    Prueba que un valor menor a un millón usa el formato de formato_cantidad_usd.
    """
    from backend.utils.utilidades_numericas import formato_numero_grande
    assert formato_numero_grande(Decimal('1234.56')) == "$1,234.56"


==================================================
=== FIN DEL REPORTE ===
==================================================
