==================================================
=== REPORTE DE C√ìDIGO CONSOLIDADO ===
Proyecto: Trabajo_Simulador_Exchange
Ruta: /Users/andreiveis/UADE/2do cuatrimestre/05_Algoritmos y Estructura de datos I/Trabajo_Simulador_Exchange
Generado el: Sat Jun 21 18:02:22 -03 2025
==================================================

--- INFORMACI√ìN DEL REPOSITORIO GIT ---
Rama actual: dev
√öltimo commit: 53e6765 - trading.html est√° roto el JS. (andreiveisuade, 3 minutes ago)
---

--- ESTRUCTURA DEL DIRECTORIO ---
.
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ backend
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ acceso_datos
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ datos_billetera.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ datos_cotizaciones.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datos_historial.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ rutas
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api_externa.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ billetera_vista.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ home.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ trading_vista.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ servicios
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api_cotizaciones.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ estado_billetera.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ trading_logica.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ velas_logica.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ utilidades
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ formatters.py
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ frontend
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ static
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ css
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ img
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ templates
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ billetera.html
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ index.html
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ trading.html
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ requirements.txt

13 directories, 23 files
---

==================================================
=== ARCHIVO: ./.gitignore ===
==================================================

# ARCHIVOS PROPIOS NUESTROS
/datos/datos_cotizaciones.json
/datos/datos_velas.json
/datos/billetera.json
/datos/historial_operaciones.json


# Python
__pycache__/
backend/__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.env
.venv
env/
venv/
ENV/
.pytest_cache/
.coverage
coverage.xml
*.cover
.hypothesis/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
__MACOSX/

# IDEs and editors
.idea/
.vscode/
*.swp
*.swo
.project
.classpath
*.sublime-workspace
*.sublime-project

# Frontend
node_modules/
/dist
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env.local
.env.*.local
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
*.sqlite
*.sqlite3
*.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Backup files
*.bak
*.backup
*~

# Environment variables
.env
.env.*
!.env.example

# System Files
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
datos/billetera.json
datos/datos_cotizaciones.json
datos/datos_velas.json
*.pyc
# D2 files
*.d2
diagrama.png


==================================================
=== ARCHIVO: ./backend/__init__.py ===
==================================================

from flask import Flask
from config import FLASK_SECRET_KEY
from backend.rutas import registrar_rutas

def crear_app():
    """
    Crea y configura la instancia de la aplicaci√≥n Flask.
    Este es el patr√≥n de 'Application Factory'.
    """
    app = Flask(
        __name__,
        static_folder="../frontend/static",
        template_folder="../frontend/templates",
    )

    # Configura la clave secreta, necesaria para mensajes flash
    app.secret_key = FLASK_SECRET_KEY

    # Registra todos los blueprints (rutas) de la aplicaci√≥n
    registrar_rutas(app)

    return app

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_billetera.py ===
==================================================

import json
import os
from decimal import Decimal, InvalidOperation
from config import BILLETERA_PATH, BALANCE_INICIAL_USDT


def cargar_billetera():
    """
    Carga la billetera desde el archivo JSON de forma segura.
    Si el archivo no existe, est√° vac√≠o o corrupto, crea una billetera inicial.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    if not os.path.exists(BILLETERA_PATH) or os.path.getsize(BILLETERA_PATH) == 0:
        billetera_inicial = {"USDT": Decimal(BALANCE_INICIAL_USDT)}
        guardar_billetera(billetera_inicial)
        return billetera_inicial

    try:
        with open(BILLETERA_PATH, "r", encoding="utf-8") as f:
            datos_cargados = json.load(f)
            # Convierte todos los valores a Decimal, manejando posibles errores
            billetera = {}
            for ticker, cantidad_str in datos_cargados.items():
                try:
                    billetera[ticker] = Decimal(str(cantidad_str))
                except InvalidOperation:
                    print(
                        f"Advertencia: Valor inv√°lido para {ticker} en billetera.json. Se usar√° 0."
                    )
                    billetera[ticker] = Decimal("0")
            return billetera
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: Archivo '{BILLETERA_PATH}' corrupto. Se reiniciar√° la billetera."
        )
        billetera_inicial = {"USDT": Decimal(BALANCE_INICIAL_USDT)}
        guardar_billetera(billetera_inicial)
        return billetera_inicial


def guardar_billetera(billetera):
    """
    Guarda el estado de la billetera en el archivo JSON.
    Convierte los valores Decimal a string para preservar la precisi√≥n.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    # Prepara la billetera para ser guardada, convirtiendo Decimal a string
    billetera_serializable = {
        ticker: str(cantidad) for ticker, cantidad in billetera.items()
    }

    with open(BILLETERA_PATH, "w", encoding="utf-8") as f:
        json.dump(billetera_serializable, f, indent=4)


==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_cotizaciones.py ===
==================================================

import json
import os
from decimal import Decimal
from config import COTIZACIONES_PATH

precios_cache = {}

def cargar_datos_cotizaciones():
    """
    Funci√≥n interna y segura para cargar todas las cotizaciones del archivo JSON.
    Maneja archivos inexistentes o corruptos.
    """
    if not os.path.exists(COTIZACIONES_PATH) or os.path.getsize(COTIZACIONES_PATH) == 0:
        return []

    try:
        with open(COTIZACIONES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return []

def recargar_cache_precios():
    """
    Actualiza el diccionario de cach√© de precios en memoria desde el archivo JSON.
    Debe ser llamada despu√©s de que los datos de cotizaciones se actualizan.
    """
    global precios_cache
    print("üîÑ Recargando cach√© de precios...")
    lista_criptos = cargar_datos_cotizaciones()
    
    precios_cache = {
        cripto.get("ticker", "").upper(): Decimal(str(cripto.get("precio_usd", "0")))
        for cripto in lista_criptos
    }
    print("‚úÖ Cach√© de precios actualizado.")


def obtener_precio(ticker):
    """
    Obtiene el precio de un ticker espec√≠fico desde el cach√© en memoria.
    Si el cach√© est√° vac√≠o, lo carga por primera vez.
    """
    if not precios_cache:
        recargar_cache_precios()
    
    return precios_cache.get(ticker.upper())

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_historial.py ===
==================================================

import json
import os
from datetime import datetime
from decimal import Decimal
from config import HISTORIAL_PATH


def cargar_historial():
    """
    Carga el historial de transacciones desde el archivo JSON.
    Si el archivo no existe, est√° vac√≠o o corrupto, devuelve una lista vac√≠a.
    """
    if not os.path.exists(HISTORIAL_PATH) or os.path.getsize(HISTORIAL_PATH) == 0:
        return []

    try:
        with open(HISTORIAL_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: No se pudo leer o el archivo '{HISTORIAL_PATH}' est√° corrupto."
        )
        return []


def guardar_en_historial(
    tipo_operacion,
    moneda_origen,
    cantidad_origen,
    moneda_destino,
    cantidad_destino,
    valor_usd,
):
    """
    Guarda una nueva operaci√≥n en el historial de transacciones.
    """
    # Asegurarse de que el directorio de datos exista
    os.makedirs(os.path.dirname(HISTORIAL_PATH), exist_ok=True)

    historial = cargar_historial()

    # Crear el diccionario para la nueva operaci√≥n
    operacion = {
        "id": len(historial) + 1,
        "timestamp": datetime.now().isoformat(),
        "tipo": tipo_operacion,
        "origen": {"ticker": moneda_origen, "cantidad": str(cantidad_origen)},
        "destino": {"ticker": moneda_destino, "cantidad": str(cantidad_destino)},
        "valor_usd": str(valor_usd.quantize(Decimal("0.01"))),
    }

    # A√±adir la nueva operaci√≥n al principio de la lista
    historial.insert(0, operacion)

    # Escribir la lista completa de nuevo en el archivo
    with open(HISTORIAL_PATH, "w", encoding="utf-8") as f:
        json.dump(historial, f, indent=4)


==================================================
=== ARCHIVO: ./backend/app.py ===
==================================================

from . import crear_app

app = crear_app()

if __name__ == "__main__":
    app.run(debug=True)

==================================================
=== ARCHIVO: ./backend/rutas/__init__.py ===
==================================================

from .home import bp as home_bp
from .trading_vista import bp as trading_bp
from .billetera_vista import bp as billetera_bp
from .api_externa import bp as api_ruta_bp


def registrar_rutas(app):
    app.register_blueprint(home_bp)
    app.register_blueprint(trading_bp)
    app.register_blueprint(billetera_bp)
    app.register_blueprint(api_ruta_bp)


==================================================
=== ARCHIVO: ./backend/rutas/api_externa.py ===
==================================================

from flask import Blueprint, jsonify, render_template
import os 
import json
from backend.servicios.api_cotizaciones import obtener_datos_criptos_coingecko, obtener_velas_binance
from backend.acceso_datos.datos_cotizaciones import cargar_datos_cotizaciones
from config import VELAS_PATH


bp = Blueprint("api_externa", __name__, url_prefix="/api")


@bp.route("/actualizar")
def actualizar():
    """Actualiza los datos de criptomonedas y velas desde las APIs externas."""
    # ---> A√ëADE ESTA L√çNEA EXACTAMENTE AQU√ç <---
    print("--- PING: Endpoint /api/actualizar ALCANZADO ---") 
    
    datos_criptos = obtener_datos_criptos_coingecko()
    obtener_velas_binance()
    return jsonify({"estado": "ok", "cantidad_criptos": len(datos_criptos)})


@bp.route("/cotizaciones")
def get_cotizaciones():
    """Retorna la lista completa de cotizaciones en formato JSON."""
    return jsonify(cargar_datos_cotizaciones())


@bp.route("/velas")
def obtener_datos_velas():
    """Retorna los datos de velas desde un archivo JSON de forma segura."""
    try:
        if not os.path.exists(VELAS_PATH) or os.path.getsize(VELAS_PATH) == 0:
            return jsonify([])

        with open(VELAS_PATH, "r", encoding="utf-8") as archivo:
            datos = json.load(archivo)
        return jsonify(datos)
    except (IOError, json.JSONDecodeError) as e:
        print("‚ùå Error leyendo datos_velas.json:", e)
        return jsonify({"error": "No se pudo leer el archivo de velas"}), 500

==================================================
=== ARCHIVO: ./backend/rutas/billetera_vista.py ===
==================================================

from flask import Blueprint, render_template, jsonify
from backend.servicios.estado_billetera import estado_actual_completo, obtener_historial_formateado
from backend.acceso_datos.datos_historial import cargar_historial
from backend.acceso_datos.datos_billetera import cargar_billetera

bp = Blueprint("billetera", __name__)


@bp.route("/billetera")
def mostrar_billetera():
    """Renderiza la p√°gina principal de la billetera (el contenedor HTML)."""
    # Ya no pasamos datos porque JS los cargar√°.
    return render_template("billetera.html")


@bp.route("/api/billetera/estado-completo")
def get_estado_billetera_completo():
    """Devuelve el estado financiero detallado de la billetera en JSON."""
    datos = estado_actual_completo()
    # La conversi√≥n de Decimal a string ya se realiza en la capa de servicio.
    return jsonify(datos)


@bp.route("/api/historial")
def get_historial_transacciones():
    """Devuelve el historial completo y formateado de transacciones en JSON."""
    return jsonify(obtener_historial_formateado())

==================================================
=== ARCHIVO: ./backend/rutas/home.py ===
==================================================

from flask import Blueprint, render_template

bp = Blueprint("home", __name__)

@bp.route("/")
def index():
    """
    Sirve el esqueleto de la p√°gina principal. 
    La carga y actualizaci√≥n de datos se maneja en el frontend.
    """
    return render_template("index.html")

==================================================
=== ARCHIVO: ./backend/rutas/trading_vista.py ===
==================================================

# backend/rutas/trading_vista.py (VERSI√ìN CON RUTAS SEPARADAS)

from flask import Blueprint, request, redirect, url_for, render_template, flash

from backend.servicios.trading_logica import procesar_operacion_trading

bp = Blueprint("trading", __name__)


# RUTA GET para MOSTRAR la p√°gina de trading
@bp.route("/trading", methods=["GET"])
def mostrar_trading_page():
    return render_template("trading.html")


# RUTA POST para PROCESAR la operaci√≥n de trading
@bp.route("/trading/operar", methods=["POST"])
def procesar_trading_form():
    """Procesa los datos del formulario de trading."""
    
    print(">>> DATOS RECIBIDOS DEL FORMULARIO:", request.form)
    
    exito, mensaje = procesar_operacion_trading(request.form)
    flash(mensaje, "success" if exito else "danger")

    # Siempre redirige de vuelta a la p√°gina principal de trading
    return redirect(url_for("trading.mostrar_trading_page"))


==================================================
=== ARCHIVO: ./backend/servicios/__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./backend/servicios/api_cotizaciones.py ===
==================================================

from decimal import Decimal
import requests
from backend.servicios.velas_logica import guardar_datos_cotizaciones, guardar_datos_velas
from config import COINGECKO_URL, BINANCE_URL, CANTIDAD_CRIPTOMONEDAS, CANTIDAD_VELAS
from backend.utils.formatters import formato_numero_grande, formato_porcentaje, formato_valor_monetario

def obtener_datos_criptos_coingecko():
    """
    Obtiene informaci√≥n del mercado de criptomonedas desde la API p√∫blica de CoinGecko.
    A√±ade campos formateados para que la UI pueda renderizarlos directamente.
    """
    params = {
        "vs_currency": "usd",
        "order": "market_cap_desc",
        "per_page": CANTIDAD_CRIPTOMONEDAS,
        "page": 1,
        "sparkline": "false",
        "price_change_percentage": "1h,24h,7d",
    }

    try:
        respuesta = requests.get(COINGECKO_URL, params)
        respuesta.raise_for_status()  # Lanza una excepci√≥n para errores HTTP (4xx o 5xx)
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Error al obtener datos de CoinGecko: {str(e)}")
        return []

    print(f"‚úÖ Estado de la respuesta CoinGecko: {respuesta.status_code}")

    try:
        datos = respuesta.json()
        resultado = [
            {
                "id": i,
                "nombre": dato.get("name"),
                "ticker": dato.get('symbol', '').upper(),
                "logo": dato.get("image"),
                
                # Datos crudos
                "precio_usd": str(Decimal(str(dato.get("current_price", 0)))),
                "1h_%": str(Decimal(str(dato.get("price_change_percentage_1h_in_currency", 0)))),
                "24h_%": str(Decimal(str(dato.get("price_change_percentage_24h_in_currency", 0)))),
                "7d_%": str(Decimal(str(dato.get("price_change_percentage_7d_in_currency", 0)))),
                "market_cap": str(Decimal(str(dato.get("market_cap", 0)))),
                "volumen_24h": str(Decimal(str(dato.get("total_volume", 0)))),
                "circulating_supply": str(Decimal(str(dato.get("circulating_supply", 0)))),

                # Datos pre-formateados para la UI
                "precio_usd_formatted": formato_valor_monetario(Decimal(str(dato.get("current_price", 0))), decimales=2),
                "1h_%_formatted": formato_porcentaje(Decimal(str(dato.get("price_change_percentage_1h_in_currency", 0)))),
                "24h_%_formatted": formato_porcentaje(Decimal(str(dato.get("price_change_percentage_24h_in_currency", 0)))),
                "7d_%_formatted": formato_porcentaje(Decimal(str(dato.get("price_change_percentage_7d_in_currency", 0)))),
                "market_cap_formatted": formato_numero_grande(Decimal(str(dato.get("market_cap", 0)))),
                "volumen_24h_formatted": formato_numero_grande(Decimal(str(dato.get("total_volume", 0)))),
                "circulating_supply_formatted": f"{Decimal(str(dato.get('circulating_supply', 0))):,.0f} {dato.get('symbol', '').upper()}"
            }
            for i, dato in enumerate(datos, start=1)
        ]
    except (KeyError, TypeError, ValueError) as e:
        print(f"‚ùå Error al procesar los datos de CoinGecko: {str(e)}")
        return []

    print(f"üí° Total de criptos procesadas: {len(resultado)}")
    guardar_datos_cotizaciones(resultado)
    return resultado


def obtener_velas_binance():
    """
    Obtiene datos hist√≥ricos de velas (Klines) diarias del par BTC/USDT.
    """
    params = {
        "symbol": "BTCUSDT",
        "interval": "1d",
        "limit": CANTIDAD_VELAS,
    }
    try:
        respuesta = requests.get(BINANCE_URL, params)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Error al obtener datos de Binance: {str(e)}")
        return []

    print(f"‚úÖ Estado de la respuesta Binance: {respuesta.status_code}")

    datos = respuesta.json()
    resultado = [
        {
            "time": int(vela[0] / 1000),
            "open": str(Decimal(vela[1])),
            "high": str(Decimal(vela[2])),
            "low": str(Decimal(vela[3])),
            "close": str(Decimal(vela[4])),
            "volume": str(Decimal(vela[5])),
        }
        for vela in datos
    ]
    
    print(f"üí° Total de velas procesadas: {len(resultado)}")
    guardar_datos_velas(resultado)
    return resultado

==================================================
=== ARCHIVO: ./backend/servicios/estado_billetera.py ===
==================================================

from decimal import Decimal
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_historial import cargar_historial
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.utils.formatters import formato_valor_monetario, formato_cantidad_cripto, formato_porcentaje, formato_fecha_hora

def calcular_detalle_cripto(ticker, cantidad_actual, precios, historial):
    """
    Calcula el estado financiero de una criptomoneda en base a su cantidad actual,
    el precio de mercado y el historial de compras.
    """
    cantidad_actual = Decimal(str(cantidad_actual))
    precio_actual = precios.get(ticker, Decimal("0"))
    valor_usdt = (cantidad_actual * precio_actual)

    compras = [
        op for op in historial
        if op.get("tipo") == "compra" and op.get("destino", {}).get("ticker") == ticker
    ]

    cantidad_comprada = sum(Decimal(str(op.get("destino", {}).get("cantidad", "0"))) for op in compras)
    total_invertido = sum(Decimal(str(op.get("valor_usd", "0"))) for op in compras)

    division_por_cero_segura = lambda num, den: num / den if den != 0 else Decimal("0")

    precio_promedio = division_por_cero_segura(total_invertido, cantidad_comprada)
    invertido_actual = cantidad_actual * precio_promedio
    ganancia = valor_usdt - invertido_actual
    porcentaje_ganancia = division_por_cero_segura(ganancia, invertido_actual) * Decimal("100")

    return {
        "ticker": ticker,
        "cantidad": cantidad_actual,
        "valor_usdt": valor_usdt,
        "precio_actual": precio_actual,
        "precio_promedio": precio_promedio,
        "invertido": invertido_actual,
        "ganancia_perdida": ganancia,
        "porcentaje_ganancia": porcentaje_ganancia,
    }

def estado_actual_completo():
    """
    Calcula un resumen financiero completo del portafolio, incluyendo campos
    pre-formateados para la UI.
    """
    billetera = cargar_billetera()
    precios = {ticker: obtener_precio(ticker) or Decimal("0") for ticker in billetera.keys()}
    historial = cargar_historial()

    detalles = [
        calcular_detalle_cripto(ticker, cantidad, precios, historial)
        for ticker, cantidad in billetera.items()
    ]

    total_usdt = sum(d["valor_usdt"] for d in detalles)
    division_por_cero_segura = lambda num, den: num / den if den != 0 else Decimal("0")
    
    for detalle in detalles:
        porcentaje_billetera = division_por_cero_segura(detalle["valor_usdt"], total_usdt) * Decimal("100")
        
        # A√±adir campos de datos crudos adicionales
        detalle["porcentaje"] = porcentaje_billetera
        detalle["es_polvo"] = detalle["valor_usdt"] < Decimal("0.001")
        
        # A√±adir campos formateados para la UI
        if detalle["ticker"] == 'USDT':
            detalle["cantidad_formatted"] = formato_valor_monetario(detalle["cantidad"], simbolo="")
        else:
            detalle["cantidad_formatted"] = formato_cantidad_cripto(detalle["cantidad"])
        
        detalle["precio_actual_formatted"] = formato_valor_monetario(detalle["precio_actual"], decimales=4)
        detalle["valor_usdt_formatted"] = formato_valor_monetario(detalle["valor_usdt"])
        detalle["ganancia_perdida_formatted"] = formato_valor_monetario(detalle["ganancia_perdida"])
        detalle["porcentaje_ganancia_formatted"] = formato_porcentaje(detalle["porcentaje_ganancia"])
        detalle["porcentaje_formatted"] = formato_porcentaje(porcentaje_billetera)

        # Convertir todos los Decimal a string para serializaci√≥n JSON segura
        for k, v in detalle.items():
            if isinstance(v, Decimal):
                detalle[k] = str(v)
    
    return detalles

def obtener_historial_formateado():
    """
    Carga el historial de transacciones y le a√±ade campos formateados para la UI.
    """
    historial = cargar_historial()
    historial_formateado = []

    for item in historial:
        # Determinar detalles de la transacci√≥n
        if item.get('tipo') == 'compra':
            cantidad = Decimal(str(item.get('destino', {}).get('cantidad', '0')))
            par = f"{item.get('destino', {}).get('ticker', '?')}/{item.get('origen', {}).get('ticker', '?')}"
        else:  # Venta
            cantidad = Decimal(str(item.get('origen', {}).get('cantidad', '0')))
            par = f"{item.get('origen', {}).get('ticker', '?')}/{item.get('destino', {}).get('ticker', '?')}"

        item_formateado = item.copy()

        # A√±adir campos formateados para la UI
        item_formateado['fecha_formatted'] = formato_fecha_hora(item.get('timestamp'))
        item_formateado['par_formatted'] = par
        item_formateado['tipo_formatted'] = item.get('tipo', '').capitalize()
        item_formateado['cantidad_formatted'] = formato_cantidad_cripto(cantidad)
        item_formateado['valor_total_formatted'] = formato_valor_monetario(Decimal(str(item.get('valor_usd', '0'))))

        # Convertir todos los Decimal a string para serializaci√≥n JSON segura
        for k, v in item_formateado.items():
            if isinstance(v, Decimal):
                item_formateado[k] = str(v)
            elif isinstance(v, dict):
                v_copy = v.copy()
                for sub_k, sub_v in v_copy.items():
                    if isinstance(sub_v, Decimal):
                        v_copy[sub_k] = str(sub_v)
                item_formateado[k] = v_copy

        historial_formateado.append(item_formateado)

    return historial_formateado

==================================================
=== ARCHIVO: ./backend/servicios/trading_logica.py ===
==================================================

from decimal import Decimal, InvalidOperation
from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_historial import guardar_en_historial

# --- FUNCI√ìN DE PROCESAMIENTO DEL FORMULARIO ---

def procesar_operacion_trading(formulario):
    """
    TRADUCTOR: Recibe el formulario, lo valida y lo convierte en una llamada
    a la l√≥gica de negocio principal (`realizar_swap`).
    """
    try:
        ticker_principal = formulario["ticker"].upper()
        accion = formulario["accion"]
        monto_form = Decimal(formulario["monto"])
        modo_ingreso = formulario["modo-ingreso"]
    except (KeyError, InvalidOperation, TypeError):
        return False, "‚ùå Error en los datos del formulario."

    if monto_form <= 0:
        return False, "‚ùå El monto debe ser un n√∫mero positivo."

    # Determina las monedas de la operaci√≥n bas√°ndose en la acci√≥n
    if accion == "comprar":
        moneda_origen = formulario.get("moneda-pago", "USDT").upper()
        moneda_destino = ticker_principal
    elif accion == "vender":
        moneda_origen = ticker_principal
        moneda_destino = formulario.get("moneda-recibir", "USDT").upper()
    else:
        return False, "‚ùå Acci√≥n no v√°lida."

    if moneda_origen == moneda_destino:
        return False, "‚ùå La moneda de origen y destino no pueden ser la misma."

    # Llama a la l√≥gica principal con los datos ya limpios y preparados
    return realizar_swap(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion)


# --- FUNCIONES AUXILIARES INTERNAS (L√ìGICA DE NEGOCIO) ---

def _calcular_detalles_swap(accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt):
    """
    Calcula las cantidades de origen, destino y el valor total en USD del swap.
    Esta es una funci√≥n interna y pura que solo realiza c√°lculos.

    Returns:
        tuple: (True, {'origen': cant, 'destino': cant, 'valor_usd': val}) o (False, "error").
    """
    # Validaci√≥n de entrada espec√≠fica para esta l√≥gica
    if accion == 'vender' and modo_ingreso == 'total':
        return False, "‚ùå Al vender, debe ingresar la cantidad en modo 'Monto' (Cripto)."

    if accion not in ['comprar', 'vender']:
        return False, "‚ùå Acci√≥n de trading desconocida."

    # L√≥gica de c√°lculo
    if accion == 'comprar':
        if modo_ingreso == 'monto':  # Usuario ingresa la cantidad de CRIPTO a recibir
            cantidad_destino = monto_form
            valor_total_usd = cantidad_destino * precio_destino_usdt
            cantidad_origen = valor_total_usd / precio_origen_usdt
        else:  # 'total', usuario ingresa la cantidad de FIAT a gastar
            cantidad_origen = monto_form
            valor_total_usd = cantidad_origen * precio_origen_usdt
            cantidad_destino = valor_total_usd / precio_destino_usdt
    else:  # accion == 'vender'
        cantidad_origen = monto_form
        valor_total_usd = cantidad_origen * precio_origen_usdt
        cantidad_destino = valor_total_usd / precio_destino_usdt

    detalles = {
        "origen": cantidad_origen,
        "destino": cantidad_destino,
        "valor_usd": valor_total_usd
    }
    return True, detalles


def _validar_saldo_suficiente(billetera, moneda_origen, cantidad_requerida):
    """Verifica si hay suficiente saldo en la billetera para la operaci√≥n."""
    saldo_disponible = billetera.get(moneda_origen, Decimal("0"))
    if cantidad_requerida > saldo_disponible:
        mensaje_error = f"‚ùå Saldo insuficiente. Tienes {saldo_disponible:.8f} {moneda_origen}."
        return False, mensaje_error
    return True, None


def _actualizar_billetera_y_guardar(billetera, moneda_origen, cantidad_origen, moneda_destino, cantidad_destino):
    """Resta la moneda de origen, suma la de destino y guarda el estado final."""
    billetera[moneda_origen] -= cantidad_origen
    
    # Si el saldo es muy peque√±o ("polvo"), se elimina la moneda de la billetera
    if billetera[moneda_origen] <= Decimal("1e-8"):
        billetera.pop(moneda_origen, None)

    billetera[moneda_destino] = billetera.get(moneda_destino, Decimal("0")) + cantidad_destino
    
    guardar_billetera(billetera)


def _registrar_operacion_historial(moneda_origen, cantidad_origen, moneda_destino, cantidad_destino, valor_usd):
    """Determina el tipo de operaci√≥n y la guarda en el historial."""
    if moneda_origen == "USDT":
        tipo_operacion = "compra"
    elif moneda_destino == "USDT":
        tipo_operacion = "venta"
    else:
        tipo_operacion = "intercambio"
        
    guardar_en_historial(
        tipo_operacion,
        moneda_origen,
        cantidad_origen.quantize(Decimal("0.00000001")),
        moneda_destino,
        cantidad_destino.quantize(Decimal("0.00000001")),
        valor_usd,
    )


# --- FUNCI√ìN ORQUESTADORA PRINCIPAL ---

def realizar_swap(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion):
    """
    Orquesta la operaci√≥n de swap completa: obtiene precios, calcula, valida y ejecuta.
    """
    # 1. Obtener precios
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)

    if precio_origen_usdt is None or precio_destino_usdt is None or precio_destino_usdt.is_zero():
        return False, "‚ùå No se pudo obtener la cotizaci√≥n para realizar el swap."

    # 2. Calcular los detalles del swap
    exito_calculo, resultado = _calcular_detalles_swap(
        accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt
    )
    if not exito_calculo:
        return False, resultado  # resultado aqu√≠ es el mensaje de error

    cantidad_origen = resultado["origen"]
    cantidad_destino = resultado["destino"]
    valor_total_usd = resultado["valor_usd"]

    # 3. Cargar billetera y validar saldo
    billetera = cargar_billetera()
    exito_validacion, mensaje_error = _validar_saldo_suficiente(billetera, moneda_origen, cantidad_origen)
    if not exito_validacion:
        return False, mensaje_error

    # 4. Ejecutar la operaci√≥n (si todo es v√°lido hasta ahora)
    _actualizar_billetera_y_guardar(billetera, moneda_origen, cantidad_origen, moneda_destino, cantidad_destino)
    
    # 5. Registrar en el historial
    _registrar_operacion_historial(moneda_origen, cantidad_origen, moneda_destino, cantidad_destino, valor_total_usd)

    # 6. Devolver mensaje de √©xito
    mensaje_exito = f"‚úÖ Swap exitoso: {cantidad_origen:.8f} {moneda_origen} ‚Üí {cantidad_destino:.8f} {moneda_destino}."
    return True, mensaje_exito

==================================================
=== ARCHIVO: ./backend/servicios/velas_logica.py ===
==================================================

import json
import os
from decimal import Decimal
from config import COTIZACIONES_PATH, VELAS_PATH


def guardar_datos_cotizaciones(data):
    os.makedirs(os.path.dirname(COTIZACIONES_PATH), exist_ok=True)
    print("üíæ Guardando datos en datos_cotizaciones.json...")
    print(f"Cantidad de criptos a guardar: {len(data)}")
    print("üìÅ Guardando en:", os.path.abspath(COTIZACIONES_PATH))

    try:
        with open(COTIZACIONES_PATH, "w") as archivo:
            json.dump(
                data,
                archivo,
                indent=4,
                default=lambda o: float(o) if isinstance(o, Decimal) else o,
            )
        print("‚úÖ Datos guardados correctamente")
    except (IOError, TypeError) as e:
        print("‚ùå Error al guardar el archivo:", e)


def cargar_datos_cotizaciones():
    if not os.path.exists(COTIZACIONES_PATH):
        return []
    with open(COTIZACIONES_PATH, "r") as archivo:
        return json.load(archivo)


def guardar_datos_velas(data):
    os.makedirs(os.path.dirname(VELAS_PATH), exist_ok=True)
    print("üíæ Guardando datos en datos_velas.json...")
    print(f"Cantidad de velas a guardar: {len(data)}")
    print("üìÅ Guardando en:", os.path.abspath(VELAS_PATH))

    try:
        with open(VELAS_PATH, "w") as archivo:
            json.dump(
                data,
                archivo,
                indent=4,
                default=lambda o: float(o) if isinstance(o, Decimal) else o,
            )
        print("‚úÖ Datos guardados correctamente")
    except (IOError, TypeError) as e:
        print("‚ùå Error al guardar el archivo:", e)


==================================================
=== ARCHIVO: ./backend/utils/formatters.py ===
==================================================

# backend/utils/formatters.py
from datetime import datetime
from decimal import Decimal

def formato_numero_grande(valor, simbolo="$"):
    """Formatea n√∫meros grandes con abreviaturas y s√≠mbolo de moneda."""
    if not isinstance(valor, (int, float, Decimal)):
        return "-"
    num = Decimal(valor)
    
    if num >= 1_000_000_000_000:
        return f"{simbolo}{(num / Decimal('1e12')).quantize(Decimal('0.01'))}T"
    if num >= 1_000_000_000:
        return f"{simbolo}{(num / Decimal('1e9')).quantize(Decimal('0.01'))}B"
    if num >= 1_000_000:
        return f"{simbolo}{(num / Decimal('1e6')).quantize(Decimal('0.01'))}M"
    return f"{simbolo}{num:,.0f}"

def formato_porcentaje(valor):
    """Formatea un porcentaje con 2 decimales y el signo %."""
    if not isinstance(valor, (int, float, Decimal)):
        return "-%"
    return f"{Decimal(valor):.2f}%"

# ===> FUNCI√ìN CORREGIDA <===
def formato_valor_monetario(valor, simbolo="$", decimales=2):
    """Formatea un valor como moneda con N decimales."""
    if not isinstance(valor, (int, float, Decimal)):
        return "-"
    # Usamos un f-string con una expresi√≥n para formatear din√°micamente los decimales
    return f"{simbolo}{Decimal(valor):,.{decimales}f}"

def formato_cantidad_cripto(valor, decimales=8):
    """Formatea una cantidad de cripto con N decimales."""
    if not isinstance(valor, (int, float, Decimal)):
        return "-"
    return f"{Decimal(valor):.{decimales}f}"

def formato_fecha_hora(timestamp):
    """Formatea un timestamp UNIX a un string de fecha y hora local."""
    if not isinstance(timestamp, (int, float)):
        return "--:--"
    try:
        # Convierte el timestamp a un objeto datetime
        dt_object = datetime.fromtimestamp(timestamp)
        # Formatea la fecha y la hora en un formato legible
        return dt_object.strftime("%d/%m/%Y %H:%M:%S")
    except (ValueError, TypeError):
        return "--:--"

==================================================
=== ARCHIVO: ./config.py ===
==================================================

import os
from decimal import getcontext, ROUND_HALF_DOWN

# Base del proyecto y carpeta de datos
PROYECTO_DIR = os.path.dirname(os.path.abspath(__file__))
BASE_DATA_DIR = os.path.join(PROYECTO_DIR, "datos")
os.makedirs(BASE_DATA_DIR, exist_ok=True)

# Rutas de archivos JSON
COTIZACIONES_PATH = os.path.join(BASE_DATA_DIR, "cotizaciones.json")
BILLETERA_PATH = os.path.join(BASE_DATA_DIR, "billetera.json")
HISTORIAL_PATH = os.path.join(BASE_DATA_DIR, "historial.json")
VELAS_PATH = os.path.join(BASE_DATA_DIR, "velas.json")

# Configuraci√≥n general
BALANCE_INICIAL_USDT = "10000"
FLASK_SECRET_KEY = os.environ.get("FLASK_SECRET_KEY", "clave_por_defecto_insegura")

# URLs de APIs
COINGECKO_URL = "https://api.coingecko.com/api/v3/coins/markets"
BINANCE_URL = "https://api.binance.com/api/v3/klines"

# Par√°metros de scraping
CANTIDAD_CRIPTOMONEDAS = 100
CANTIDAD_VELAS = 250

# Decimal global
getcontext().prec = 28
getcontext().rounding = ROUND_HALF_DOWN


==================================================
=== ARCHIVO: ./frontend/static/css/styles_index.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030;
    color: #f0c000;
}

.logo-cripto {
    margin-right: 1.5rem;
    vertical-align: middle;
}

.nombre-cripto {
    padding-left: 0.75rem;
    font-weight: bold;
    font-size: 1.05rem;
}

.logo-cripto {
    margin-right: 10px;
    vertical-align: middle;
}

.ticker-cripto {
    color: #aaaaaa;
    font-size: 0.85rem;
    margin-left: 4px;
}

table thead th {
    font-size: 0.85rem;
    font-weight: 500;
    text-transform: uppercase;
}

td,
th {
    white-space: nowrap;
}

/* PRECIO */
table td:nth-child(3),
table th:nth-child(3) {
    min-width: 100px;
    font-weight: bold;
}
table td:nth-child(4),
table th:nth-child(4),
table td:nth-child(5),
table th:nth-child(5),
table td:nth-child(6),
table th:nth-child(6) {
    min-width: 80px; /* 1H, 24H, 7D */
}
table td:nth-child(8),
table th:nth-child(8),
table td:nth-child(9),
table th:nth-child(9) {
    min-width: 100px; /* VOLUME, SUPPLY */
}

/* Limita el ancho de la columna Name (columna 2) */
table td:nth-child(2),
table th:nth-child(2) {
    max-width: 220px; /* prob√° ajustar este valor */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.positivo {
    color: var(--color-verde);
    font-weight: 500;
}

.negativo {
    color: var(--color-rojo);
    font-weight: 500;
}

.flecha-verde,
.flecha-roja {
    font-size: 0.7em; /* m√°s peque√±o que el texto base */
    vertical-align: middle;
    margin-right: 4px;
}

.flecha-verde {
    color: var(--color-verde);
    margin-right: 4px;
}

.flecha-roja {
    color: var(--color-rojo);
    margin-right: 4px;
}


==================================================
=== ARCHIVO: ./frontend/static/css/styles_trading.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
    /* --bs-dark-rgb: 30, 30, 30 !important;
    --bs-body-bg: 44, 44, 44 !important;
    --bs-border-width: 1px solid rgb(219, 71, 71) !important; */
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030 !important;
    color: #f0c000;
}

#chart {
    display: block;
    overflow: hidden;
    width: 100%;
    max-width: 100%;
}

.text-verde {
    color: var(--color-verde);
}

.text-rojo {
    color: var(--color-rojo);
}

/* FORMULARIO TRADING */

.form-control {
    background-color: 44, 44, 44 !important;
}

/* CAMBIO DE COLOR DEL PUNTO DEL SLIDER THUMB DIN√ÅMICO */

/* Chrome/Safari */
input[type='range'].slider-compra::-webkit-slider-thumb {
    background-color: rgb(31, 191, 113) !important; /* verde */
}

input[type='range'].slider-venta::-webkit-slider-thumb {
    background-color: rgb(226, 33, 52) !important; /* rojo */
}

/* Firefox */
input[type='range'].slider-compra::-moz-range-thumb {
    background-color: rgb(31, 191, 113) !important;
}

input[type='range'].slider-venta::-moz-range-thumb {
    background-color: rgb(226, 33, 52) !important;
}


==================================================
=== ARCHIVO: ./frontend/static/js/components/chartRenderer.js ===
==================================================

// Manages the creation and updating of the candlestick chart.
export function initializeChart(data) {
    console.log('üìà Initializing candlestick chart...');
    const chartContainer = document.getElementById('chart');
    if (!chartContainer) {
        console.warn("Element #chart not found. Cannot render chart.");
        return;
    }

    if (!window.LightweightCharts) {
        console.error("LightweightCharts library is not loaded. Make sure it loads before this script.");
        return;
    }

    const chart = window.LightweightCharts.createChart(chartContainer, {
        width: chartContainer.clientWidth,
        height: 500,
        layout: { textColor: '#ccc', background: { type: 'solid', color: '#1E1E1E' } },
        grid: { vertLines: { color: '#2B2B2B' }, horzLines: { color: '#2B2B2B' } },
        priceScale: { borderColor: '#485c7b' },
        timeScale: { borderColor: '#485c7b' },
    });

    const candleSeries = chart.addCandlestickSeries({
        upColor: 'rgb(31, 191, 113)',
        downColor: 'rgb(226, 33, 52)',
        borderDownColor: 'rgb(226, 33, 52)',
        borderUpColor: 'rgb(31, 191, 113)',
        wickDownColor: '#838ca1',
        wickUpColor: '#838ca1',
    });

    const volumeSeries = chart.addHistogramSeries({
        priceFormat: { type: 'volume' },
        priceScaleId: '',
    });
    volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });

    if (data && data.length > 0) {
        const candleData = data.map(item => ({
            time: item.time, open: Number(item.open), high: Number(item.high), low: Number(item.low), close: Number(item.close)
        }));
        const volumeData = data.map(item => ({
            time: item.time, value: Number(item.volume), color: Number(item.close) > Number(item.open) ? 'rgba(31, 191, 113, 0.5)' : 'rgba(226, 33, 52, 0.5)'
        }));
        candleSeries.setData(candleData);
        volumeSeries.setData(volumeData);
    }
    
    const volumeCheckbox = document.getElementById('toggleVolume');
    if (volumeCheckbox) {
        volumeCheckbox.addEventListener('change', (e) => {
            volumeSeries.applyOptions({ visible: e.target.checked });
        });
    }

    chart.timeScale().fitContent();
    new ResizeObserver(() => chart.applyOptions({ width: chartContainer.clientWidth })).observe(chartContainer);
}


==================================================
=== ARCHIVO: ./frontend/static/js/components/domElements.js ===
==================================================

// Almacena referencias a los elementos del DOM para un acceso r√°pido y centralizado.
export const DOMElements = {
    form: $('#formulario-trading'),
    selectorPrincipal: $('#cripto'),
    selectorPagarCon: $('#moneda-pago'),
    selectorRecibirEn: $('#moneda-recibir'),
    botonComprar: $('.boton-comprar'),
    botonVender: $('.boton-vender'),
    botonConfirmar: $('.boton-confirmar'),
    inputAccion: $('#accion'),
    campoPagarCon: $('#campo-pagar-con'),
    campoRecibirEn: $('#campo-recibir-en'),
    spanSaldoDisponible: $('#saldo-disponible'),
    radioModoIngreso: $('input[name="modo-ingreso"]'),
    labelMonto: $('label[for="monto"]'),
    inputMonto: $('#monto'),
    sliderMonto: $('#slider-monto'),
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/formLogic.js ===
==================================================

// frontend/static/js/components/formLogic.js

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';

export const FormLogic = {
    /**
     * Llena un selector de Bootstrap con opciones y selecciona un valor por defecto.
     * @param {jQuery} selector - El elemento selector de jQuery.
     * @param {Array<Object>} lista - Lista de objetos para poblar el selector (cada objeto debe tener 'ticker' y 'nombre').
     * @param {string} valorPorDefecto - El valor a seleccionar por defecto.
     * @returns {string|null} El ticker seleccionado o null si la lista est√° vac√≠a.
     */
    popularSelector(selector, lista, valorPorDefecto) {
        selector.empty();
        // CORRECCI√ìN: Asegurarse de que se usan las propiedades correctas (ticker, nombre)
        lista.forEach(({ ticker, nombre }) => selector.append(new Option(`${nombre} (${ticker})`, ticker)));
        const valorFinal = (valorPorDefecto && lista.some(m => m.ticker === valorPorDefecto)) ? valorPorDefecto : (lista.length > 0 ? lista[0].ticker : null);
        if (valorFinal) {
            selector.val(valorFinal).trigger('change');
        }
        return valorFinal;
    },

    /**
     * Calcula el monto basado en el valor del slider y el saldo disponible.
     * Protegido contra el caso donde window.ownedCoins a√∫n no est√° cargado.
     * @returns {number} El monto calculado.
     */
    calcularMontoSlider() {
        // A√±ade este log para verificar si la funci√≥n se llama
        console.log("DEBUG: Se ha llamado a calcularMontoSlider()"); 

        // ----> CORRECCI√ìN DEFENSIVA CLAVE <----
        // Si window.ownedCoins a√∫n no se ha cargado desde la API, no hagas nada y devuelve 0.
        // Esto evita el crash durante la inicializaci√≥n.
        if (!window.ownedCoins) {
             console.log("DEBUG: window.ownedCoins es undefined. Saliendo de calcularMontoSlider.");
             return 0;
        }
        
        const porcentaje = parseFloat(DOMElements.sliderMonto.val());
        const esCompra = UIState.esModoCompra();
        
        const tickerDeSaldo = esCompra ? UIState.getTickerPago() : UIState.getTickerPrincipal();
        
        // Ahora que sabemos que window.ownedCoins existe, podemos usarlo de forma segura.
        const moneda = window.ownedCoins.find(m => m.ticker === tickerDeSaldo);
        const saldoDisponible = moneda ? parseFloat(moneda.cantidad) : 0; // Usar .cantidad
        
        if (!tickerDeSaldo) return 0;

        return (saldoDisponible * porcentaje) / 100.0;
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/tablaCotizacionesUI.js ===
==================================================

// Controla la renderizaci√≥n y actualizaci√≥n de la tabla de cotizaciones.

import { fetchCotizaciones } from '../services/apiService.js';
import { UIUpdater } from './uiUpdater.js';

const cuerpoTabla = document.getElementById('tabla-datos');

function createFilaCotizacionHTML(cripto, index) {
    // Helper para no repetir la l√≥gica de positivo/negativo
    const getPerfIndicator = (value) => {
        const isPositive = parseFloat(value) >= 0;
        return {
            className: isPositive ? 'positivo' : 'negativo',
            arrow: isPositive ? '‚ñ≤' : '‚ñº'
        };
    };

    const perf1h = getPerfIndicator(cripto['1h_%']);
    const perf24h = getPerfIndicator(cripto['24h_%']);
    const perf7d = getPerfIndicator(cripto['7d_%']);

    return `
        <tr>
            <td class="text-start px-3">${index}</td>
            <td class="text-start px-3">
                <img src="${cripto.logo}" width="20" class="logo-cripto" alt="${cripto.ticker} logo">
                <span class="nombre-cripto">${cripto.nombre}</span>
                <span class="ticker-cripto">(${cripto.ticker})</span>
            </td>
            <td class="text-start px-3 fw-bold">${cripto.precio_usd_formatted}</td>
            
            <td class="text-end px-3">
                <span class="${perf1h.className}">
                    <span class="flecha">${perf1h.arrow}</span>
                    ${cripto['1h_%_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${perf24h.className}">
                    <span class="flecha">${perf24h.arrow}</span>
                    ${cripto['24h_%_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${perf7d.className}">
                    <span class="flecha">${perf7d.arrow}</span>
                    ${cripto['7d_%_formatted']}
                </span>
            </td>
            
            <td class="text-end px-3">${cripto.market_cap_formatted}</td>
            <td class="text-end px-3">${cripto.volumen_24h_formatted}</td>
            <td class="text-end px-3">${cripto.circulating_supply_formatted}</td>
        </tr>
    `;
}

export async function renderTabla() {
    if (!cuerpoTabla) return;
    try {
        const cotizaciones = await fetchCotizaciones();
        if (!cotizaciones || cotizaciones.length === 0) {
            cuerpoTabla.innerHTML =
                '<tr><td colspan="9" class="text-center text-muted py-4">No hay datos disponibles.</td></tr>';
            return;
        }
        cuerpoTabla.innerHTML = cotizaciones.map((cripto, index) => createFilaCotizacionHTML(cripto, index + 1)).join('');
    } catch (error) {
        console.error('‚ùå Error al renderizar la tabla de cotizaciones:', error);
        UIUpdater.mostrarMensajeError('No se pudieron cargar las cotizaciones. La informaci√≥n puede estar desactualizada.');
        // Opcional: mostrar un estado de error en la propia tabla
        cuerpoTabla.innerHTML = '<tr><td colspan="9" class="text-center text-danger py-4">Error al cargar las cotizaciones.</td></tr>';
    }
}


==================================================
=== ARCHIVO: ./frontend/static/js/components/uiState.js ===
==================================================

// Gestiona el estado de la interfaz de usuario, como el modo de operaci√≥n (compra/venta).
import { DOMElements } from './domElements.js';

export const UIState = {
    esModoCompra() {
        return DOMElements.inputAccion.val() === 'comprar';
    },
    getModoIngreso() {
        return DOMElements.radioModoIngreso.filter(':checked').val();
    },
    getTickerPrincipal() {
        return DOMElements.selectorPrincipal.val();
    },
    getTickerPago() {
        return DOMElements.selectorPagarCon.val();
    },
    getTickerRecibo() {
        return DOMElements.selectorRecibirEn.val();
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiUpdater.js ===
==================================================

// Contiene funciones para actualizar din√°micamente la interfaz de usuario.
import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';

export const UIUpdater = {
    actualizarBotones() {
        const esCompra = UIState.esModoCompra();
        DOMElements.botonConfirmar
            .text(esCompra ? 'COMPRAR' : 'VENDER')
            .toggleClass('btn-success', esCompra)
            .toggleClass('btn-danger', !esCompra);
        DOMElements.botonComprar
            .toggleClass('active btn-success', esCompra)
            .toggleClass('btn-outline-secondary', !esCompra);
        DOMElements.botonVender
            .toggleClass('active btn-danger', !esCompra)
            .toggleClass('btn-outline-secondary', esCompra);
    },

    actualizarVisibilidadCampos() {
        const esCompra = UIState.esModoCompra();
        DOMElements.campoPagarCon.toggle(esCompra);
        DOMElements.campoRecibirEn.toggle(!esCompra);
        DOMElements.selectorPagarCon.prop('disabled', !esCompra);
        DOMElements.selectorRecibirEn.prop('disabled', esCompra);
    },

    actualizarLabelMonto() {
        const esModoMonto = UIState.getModoIngreso() === 'monto';
        const esCompra = UIState.esModoCompra();
        let tickerRelevante = '';

        if (esCompra) {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerPago();
        } else {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerRecibo();
        }

        const etiqueta = esModoMonto ? 'Monto' : 'Total';
        DOMElements.labelMonto.text(`${etiqueta} (${tickerRelevante || '...'})`);
    },

    mostrarSaldo(ticker) {
        if (!ticker) {
            DOMElements.spanSaldoDisponible.text('--');
            return;
        }
        // Busca la moneda en el estado completo para obtener el saldo formateado.
        const moneda = window.monedasPropias.find(m => m.ticker === ticker);
        const saldoFormateado = moneda ? moneda.cantidad_formatted : '0.00000000';
        DOMElements.spanSaldoDisponible.text(`${saldoFormateado} ${ticker}`);
    },

    setInputMonto(valor) {
        DOMElements.inputMonto.val(valor);
    },

    resetSlider() {
        DOMElements.sliderMonto.val(0);
    },

    renderHistorial(historialData) {
        const tablaHistorial = $('#tabla-historial');
        if (!tablaHistorial.length) return;

        if (historialData.length === 0) {
            tablaHistorial.html('<tr><td colspan="5" class="text-center text-muted py-3">No hay transacciones en el historial.</td></tr>');
            return;
        }

        const historialHTML = historialData.map((item) => {
            const claseTipo = item.tipo === 'compra' ? 'text-success' : 'text-danger';

            return `
                <tr>
                    <td class="text-start ps-3">${item.fecha_formatted}</td>
                    <td class="fw-bold">${item.par_formatted}</td>
                    <td class="${claseTipo}">${item.tipo_formatted}</td>
                    <td>${item.cantidad_formatted}</td>
                    <td>${item.valor_total_formatted}</td>
                </tr>
            `;
        }).join('');

        tablaHistorial.html(historialHTML);
    },

    /**
     * Muestra un mensaje de error en un contenedor de alertas en la parte superior de la p√°gina.
     * @param {string} mensaje - El mensaje de error a mostrar.
     * @param {string} [containerSelector='#error-container'] - El selector del contenedor donde se mostrar√° el error.
     */
    mostrarMensajeError(mensaje, containerSelector = '#error-container') {
        const errorContainer = $(containerSelector);
        if (!errorContainer.length) {
            console.error(`Error container '${containerSelector}' not found.`);
            return;
        }

        const alertHTML = `
            <div class="alert alert-danger alert-dismissible fade show" role="alert">
                ${mensaje}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        `;

        // Limpia mensajes anteriores y a√±ade el nuevo para evitar acumulaci√≥n.
        errorContainer.html(alertHTML);
    },
};

==================================================
=== ARCHIVO: ./frontend/static/js/pages/billeteraPage.js ===
==================================================

// Orquesta la inicializaci√≥n y la l√≥gica principal de la p√°gina de la billetera.
import { fetchEstadoBilletera } from '../services/apiService.js';
import { UIUpdater } from '../components/uiUpdater.js';

/**
 * Crea una fila HTML para la tabla de la billetera a partir de un objeto de cripto.
 * @param {object} cripto - El objeto que contiene los datos de la cripto.
 * @returns {string} El string HTML para la fila <tr>.
 */
function createBilleteraRowHTML(cripto) {
    // La l√≥gica de color se basa en el valor num√©rico crudo.
    const colorGanancia = parseFloat(cripto.ganancia_perdida) >= 0 ? 'positivo' : 'negativo';
    
    // Se usan directamente los campos _formatted que vienen del backend.
    return `
        <tr>
            <td class="text-center">${cripto.ticker} ${cripto.es_polvo ? '<span class="text-muted small">(polvo)</span>' : ''}</td>
            <td class="text-center">${cripto.cantidad_formatted}</td>
            <td class="text-center">${cripto.precio_actual_formatted}</td>
            <td class="text-center">${cripto.valor_usdt_formatted}</td>
            <td class="text-center ${colorGanancia}">${cripto.ganancia_perdida_formatted}</td>
            <td class="text-center ${colorGanancia}">${cripto.porcentaje_ganancia_formatted}</td>
            <td class="text-center">${cripto.porcentaje_formatted}</td>
        </tr>
    `;
}

/**
 * Renderiza la tabla completa de la billetera en el DOM.
 */
async function renderBilletera() {
    const cuerpoTabla = document.getElementById('tabla-billetera');
    if (!cuerpoTabla) {
        console.warn("Elemento #tabla-billetera no encontrado.");
        return;
    }

    console.log("üîÑ Cargando datos de la billetera...");
    try {
        const datosBilletera = await fetchEstadoBilletera();

        if (datosBilletera.length === 0) {
            cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-muted py-4">Tu billetera est√° vac√≠a.</td></tr>';
            return;
        }

        const tablaHTML = datosBilletera.map(createBilleteraRowHTML).join('');
        cuerpoTabla.innerHTML = tablaHTML;
        console.log("‚úÖ Billetera renderizada correctamente.");
    } catch (error) {
        console.error('‚ùå Error al renderizar la billetera:', error);
        // Muestra el error en la consola, en la UI global y en la tabla misma.
        UIUpdater.mostrarMensajeError('No se pudieron cargar los datos de la billetera. Por favor, intenta recargar la p√°gina.');
        cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-danger py-4">Error al cargar los datos.</td></tr>';
    }
}

// Iniciar el proceso cuando el DOM est√© listo.
document.addEventListener('DOMContentLoaded', () => {renderBilletera()});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/indexPage.js ===
==================================================

// frontend/static/js/pages/indexPage.js

import { triggerActualizacionDatos } from '../services/apiService.js';
import { renderTabla } from '../components/tablaCotizacionesUI.js';

const UPDATE_INTERVAL_MS = 15000; // 15 segundos

/**
 * Funci√≥n unificada para actualizar datos y renderizar la tabla.
 */
async function actualizarYRenderizar() {
    console.log("üîÑ Actualizando y renderizando cotizaciones...");
    try {
        // Primero, le pedimos al backend que se actualice desde la API externa.
        await triggerActualizacionDatos();
        // Luego, renderizamos la tabla con los datos frescos.
        await renderTabla();
        console.log("‚úÖ Tabla de cotizaciones actualizada.");
    } catch (error) {
        console.error("‚ùå Fall√≥ el ciclo de actualizaci√≥n:", error);
        // Opcional: podr√≠as mostrar un mensaje de error en la UI aqu√≠.
    }
}

document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('tabla-datos')) {
        console.log("üöÄ Inicializando p√°gina de cotizaciones.");
        
        // 1. Ejecuta la actualizaci√≥n INMEDIATAMENTE al cargar la p√°gina.
        actualizarYRenderizar();
        
        // 2. Luego, establece el intervalo para futuras actualizaciones.
        setInterval(actualizarYRenderizar, UPDATE_INTERVAL_MS);
    }
});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/tradingPage.js ===
==================================================

// Orquesta la inicializaci√≥n y la l√≥gica principal de la p√°gina de trading.
import { DOMElements } from '../components/domElements.js';
import { UIState } from '../components/uiState.js';
import { UIUpdater } from '../components/uiUpdater.js';
import { FormLogic } from '../components/formLogic.js';
import { initializeChart } from '../components/chartRenderer.js';
import { fetchCotizaciones, fetchEstadoBilletera, fetchHistorial, fetchVelas } from '../services/apiService.js';

console.log("1. tradingPage.js - Script cargado e importaciones OK");

document.addEventListener('DOMContentLoaded', () => {
    console.log("2. tradingPage.js - DOMContentLoaded se dispar√≥");

    // Variables globales para almacenar datos
    window.allCryptos = [];
    // Declaraci√≥n expl√≠cita de window.ownedCoins
    window.ownedCoins = []; 

    /**
     * Actualiza la interfaz de usuario seg√∫n el modo de trading (compra/venta).
     * @param {string} mode - El modo de operaci√≥n ('comprar' o 'vender').
     */
    function setTradeMode(mode) {
        DOMElements.inputAccion.val(mode); 
        
        UIUpdater.actualizarBotones();
        UIUpdater.actualizarVisibilidadCampos();
        let tickerForBalance = '';
        if (UIState.esModoCompra()) {
            const cryptosWithoutUSDT = window.allCryptos.filter(c => c.ticker !== 'USDT');
            FormLogic.popularSelector(DOMElements.selectorPrincipal, cryptosWithoutUSDT, 'BTC');
            tickerForBalance = UIState.getTickerPago();
        } else {
            // Usamos window.ownedCoins aqu√≠.
            // Si window.ownedCoins es null o undefined o vac√≠o, puede causar problemas.
            // A√±adimos una comprobaci√≥n defensiva aqu√≠.
            if (!window.ownedCoins || window.ownedCoins.length === 0) {
                console.warn("WARN: window.ownedCoins no est√° disponible o est√° vac√≠o al intentar configurar el modo de venta.");
                // Podr√≠amos intentar poblar con algo gen√©rico o simplemente no hacer nada.
                // Por ahora, si no hay ownedCoins, no poblamos el selector principal.
                tickerForBalance = null; // O manejarlo de otra forma
            } else {
                const defaultTicker = window.ownedCoins[0].ticker; // Accede al primer elemento si existe
                tickerForBalance = FormLogic.popularSelector(DOMElements.selectorPrincipal, window.ownedCoins, defaultTicker);
            }
        }
        
        UIUpdater.mostrarSaldo(tickerForBalance);
        UIUpdater.actualizarLabelMonto();
        UIUpdater.resetSlider();
    }

    /**
     * Configura todos los event listeners para los elementos interactivos del formulario y el gr√°fico.
     */
    function setupEventListeners() {
        DOMElements.botonComprar.on('click', () => setTradeMode('comprar'));
        DOMElements.botonVender.on('click', () => setTradeMode('vender'));

        DOMElements.selectorPrincipal.on('change', () => {
            UIUpdater.actualizarLabelMonto();
            if (!UIState.esModoCompra()) {
                // Aqu√≠ tambi√©n puede ser que window.ownedCoins no est√© listo si el usuario cambia a venta muy r√°pido.
                // Pero la protecci√≥n en setTradeMode deber√≠a mitigar esto.
                UIUpdater.mostrarSaldo(UIState.getTickerPrincipal());
            }
        });

        DOMElements.selectorPagarCon.on('change', () => {
            UIUpdater.actualizarLabelMonto();
            if (UIState.esModoCompra()) UIUpdater.mostrarSaldo(UIState.getTickerPago());
        });
        
        DOMElements.selectorRecibirEn.on('change', UIUpdater.actualizarLabelMonto);
        DOMElements.radioModoIngreso.on('change', UIUpdater.actualizarLabelMonto);

        DOMElements.sliderMonto.on('input', () => {
            const calculatedValue = FormLogic.calcularMontoSlider();
            UIUpdater.setInputMonto(calculatedValue.toFixed(8)); 
        });
    }

    async function initialize() {
        console.log("3. tradingPage.js - Entrando en initialize()");
        try {
            console.log("4. tradingPage.js - A punto de llamar a Promise.all");
            const [cotizaciones, estadoBilletera, historial, velas] = await Promise.all([
                fetchCotizaciones(),
                fetchEstadoBilletera(),
                fetchHistorial(),
                fetchVelas()
            ]);
            console.log("5. tradingPage.js - Promise.all completado con √âXITO");
            
            window.allCryptos = cotizaciones;
            // CORRECCI√ìN: Asegurarse de usar 'ownedCoins' y filtrar correctamente
            window.ownedCoins = estadoBilletera.filter(moneda => parseFloat(moneda.cantidad) > 0);
            console.log(`6. tradingPage.js - Variables globales pobladas: allCryptos=${window.allCryptos.length}, ownedCoins=${window.ownedCoins.length}`);

            UIUpdater.renderHistorial(historial);
            initializeChart(velas);
            console.log("7. tradingPage.js - Historial y gr√°fico renderizados");

            [DOMElements.selectorPrincipal, DOMElements.selectorPagarCon, DOMElements.selectorRecibirEn].forEach(sel => {
                sel.select2({ 
                    width: '100%', 
                    dropdownCssClass: 'text-dark', 
                    theme: 'bootstrap-5' 
                });
            });
            console.log("8. tradingPage.js - Select2 inicializado");

            // 5. Poblar los selectores con los datos ya cargados
            // Asegurarse de que window.ownedCoins est√° disponible ANTES de poblar el selector
            if (window.ownedCoins) {
                FormLogic.popularSelector(DOMElements.selectorPagarCon, window.ownedCoins, 'USDT');
            } else {
                console.warn("WARN: window.ownedCoins no est√° disponible al poblar selectorPagarCon.");
                // Poblar con un valor por defecto si ownedCoins no existe
                FormLogic.popularSelector(DOMElements.selectorPagarCon, [{ticker: 'USDT', nombre: 'USDT'}], 'USDT');
            }
            // Siempre poblar el selector Recibir en con allCryptos
            if (window.allCryptos) {
                FormLogic.popularSelector(DOMElements.selectorRecibirEn, window.allCryptos, 'USDT');
            } else {
                console.warn("WARN: window.allCryptos no est√° disponible al poblar selectorRecibirEn.");
            }
            console.log("9. tradingPage.js - Selectores poblados");
            
            setupEventListeners();
            setTradeMode('comprar'); // Iniciar en modo compra por defecto
            console.log("10. tradingPage.js - Listeners y modo de trading configurados. ¬°Inicializaci√≥n COMPLETA!");

        } catch (error) {
            console.error('--- ERROR FATAL CAPTURADO EN INITIALIZE ---', error); 
            UIUpdater.mostrarMensajeError('No se pudieron cargar los datos esenciales para la p√°gina de trading. Por favor, recarga la p√°gina.');
        }
    }

    initialize();
});

==================================================
=== ARCHIVO: ./frontend/static/js/services/apiService.js ===
==================================================

// Centraliza todas las llamadas a la API del backend en un solo lugar.

/**
 * Funci√≥n gen√©rica para realizar solicitudes fetch a la API.
 * @param {string} url - La URL del endpoint de la API.
 * @param {object} options - Opciones para la solicitud fetch (ej. method, headers, body).
 * @param {string} errorMessage - Mensaje de error personalizado para la excepci√≥n.
 * @returns {Promise<any>} - La respuesta JSON de la API.
 * @private
 */
async function _fetchData(url, options = {}, errorMessage = 'Error en la solicitud a la API') {
    try {
        const response = await fetch(url, options);
        if (!response.ok) {
            throw new Error(`${errorMessage} (status: ${response.status})`);
        }
        return await response.json();
    } catch (error) {
        console.error(`‚ùå Error en la llamada a ${url}:`, error);
        // Re-lanzar el error permite que el c√≥digo que llama lo maneje (ej. Promise.all).
        throw error;
    }
}

// --- Funciones exportadas para cada endpoint de la API ---

/**
 * Obtiene la lista completa de cotizaciones.
 */
export const fetchCotizaciones = () => 
    _fetchData('/api/cotizaciones', {}, 'No se pudo cargar las cotizaciones');

/**
 * Obtiene el estado completo y formateado de la billetera del usuario.
 */
export const fetchEstadoBilletera = () => 
    _fetchData('/api/billetera/estado-completo', {}, 'No se pudo cargar el estado de la billetera');

/**
 * Obtiene el historial de transacciones del usuario.
 */
export const fetchHistorial = () => 
    _fetchData('/api/historial', {}, 'No se pudo cargar el historial');

/**
 * Obtiene los datos de las velas (candlestick) para el gr√°fico.
 */
export const fetchVelas = () => 
    _fetchData('/api/velas', {}, 'No se pudo cargar los datos de velas');

/**
 * Solicita al backend que actualice los datos de las cotizaciones desde la fuente externa.
 */
export const triggerActualizacionDatos = () => 
    _fetchData('/api/actualizar', {}, 'La solicitud para actualizar datos fall√≥');

==================================================
=== ARCHIVO: ./frontend/templates/billetera.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Billetera</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="bg-dark text-white">
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes de error -->
    <div id="error-container" class="container-fluid mt-3"></div>

    <main class="container my-4">
        <div class="text-center">
            <h2 class="text-warning mb-4">Billetera</h2>
        </div>

        <div class="table-responsive mt-4">
            <table class="table table-dark table-bordered align-middle text-center">
                <thead class="table-secondary">
                    <tr class="table-dark">
                        <th>Nombre</th>
                        <th>Cantidad</th>
                        <th>Precio Actual</th>
                        <th>Valor USD</th>
                        <th>G&P (USD)</th>
                        <th>G&P (%)</th>
                        <th>% Billetera</th>
                    </tr>
                </thead>
                <tbody id="tabla-billetera">
                    <!-- El contenido ser√° renderizado aqu√≠ por billeteraPage.js -->
                    <tr>
                        <td colspan="7" class="text-center text-muted py-4">Cargando billetera...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </main>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/billeteraPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/index.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BlocX</title>
	<link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
	<link rel="stylesheet" href="{{ url_for('static', filename='css/styles_index.css') }}">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
</head>

<body class="bg-dark text-white">


	<nav class="navbar navbar-expand-lg bg-black shadow">
		<div class="container-fluid">
			<a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
				<img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
				<span>BlocX</span>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
				<span class="navbar-toggler-icon bg-light"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarNav">
				<ul class="navbar-nav ms-auto">
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Contenedor para mensajes de error -->
	<div id="error-container" class="container-fluid mt-3"></div>

	<!-- Contenedor principal -->
	<main class="container-fluid mt-4">
		<div class="row">
			<div class="col-12">
				<div class="p-2 shadow text-center">
					<h3 class="text-warning">Cotizaciones</h3>
					<table class="table table-dark table-striped mt-4">
						<thead>
							<tr>
								<th class="text-start px-3">#</th>
								<th class="text-start px-3">Nombre</th>
								<th class="text-start px-3">Precio</th>
								<th class="text-end px-3">1h</th>
								<th class="text-end px-3">24h</th>
								<th class="text-end px-3">7d</th>
								<th class="text-end px-3">Cap. Mercado</th>
								<th class="text-end px-3">Volumen</th>
								<th class="text-end px-3">Suministro</th>
							</tr>
						</thead>
						<tbody id="tabla-datos" class="align-middle">
							<!-- Aqu√≠ se insertar√°n las filas con JS -->
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</main>

	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
	<script type="module" src="{{ url_for('static', filename='js/pages/indexPage.js') }}"></script>

</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/trading.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Trading</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
</head>

<body class="bg-dark text-white">

    <!-- ========== BARRA DE NAVEGACI√ìN (sin cambios) ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes de error -->
    <div id="error-container" class="container-fluid mt-3"></div>

    <!-- ========== CONTENIDO PRINCIPAL (sin cambios) ========== -->
    <div class="container mt-5">
        <div class="row">
            <div class="col-md-7">
                <h3 class="text-light">Gr√°fico velas</h3>
                <div class="form-check form-switch mb-2">
                    <input class="form-check-input" type="checkbox" id="toggleVolume" checked>
                    <label class="form-check-label text-light" for="toggleVolume">Mostrar volumen</label>
                </div>
                <div class="py-3">
                    <div id="chart"></div>
                </div>
            </div>

            <form class="col-md-5 p-3" id="formulario-trading" method="POST"
                action="{{ url_for('trading.procesar_trading_form') }}">
                <h2 class="text-warning">Trading</h2>
                <div class="row g-2 mb-3">
                    <div class="col-6">
                        <label for="cripto" class="form-label">Criptomoneda</label>
                        <select class="form-select" id="cripto" name="ticker" required></select>
                    </div>
                    <div class="col-6">
                        <div id="campo-pagar-con" style="display: none;">
                            <label for="moneda-pago" class="form-label">Pagar con</label>
                            <select class="form-select" id="moneda-pago" name="moneda-pago"></select>
                        </div>
                        <div id="campo-recibir-en" style="display: none;">
                            <label for="moneda-recibir" class="form-label">Recibir en</label>
                            <select class="form-select" id="moneda-recibir" name="moneda-recibir"></select>
                        </div>
                    </div>
                </div>
                <div class="btn-group mb-3 w-100" role="group" id="toggle-trade-type">
                    <input type="hidden" name="accion" id="accion" value="comprar">
                    <button type="button" class="btn w-50 btn-success active boton-comprar"
                        data-action="comprar">Comprar</button>
                    <button type="button" class="btn w-50 btn-outline-secondary boton-vender"
                        data-action="vender">Vender</button>
                </div>
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Tipo de orden</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-mercado" value="mercado"
                            autocomplete="off" checked required>
                        <label class="btn btn-outline-primary rounded-start-pill" for="tipo-mercado">Mercado</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-limite" value="limite"
                            autocomplete="off">
                        <label class="btn btn-outline-primary" for="tipo-limite">L√≠mite</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-stop-limit" value="stop-limit"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="tipo-stop-limit">Stop-Limit</label>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Ingresar por</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-monto" value="monto"
                            autocomplete="off" checked required>
                        <label class="btn btn-outline-primary rounded-start-pill" for="modo-monto">Monto
                            (Cripto)</label>
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-total" value="total"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="modo-total">Total (USD)</label>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="monto" class="form-label">Monto</label>
                    <input type="number" class="form-control" id="monto" placeholder="0.00" name="monto" required
                        min="0.00000001" step="any">
                </div>
                <div class="mb-3">
                    <input type="range" class="form-range" min="0" max="100" step="1" id="slider-monto" value="0"
                        name="slider">
                    <div class="d-flex justify-content-between text-white-50 small">
                        <span>0%</span><span>25%</span><span>50%</span><span>75%</span><span>100%</span>
                    </div>
                </div>
                <div class="mb-3 text-end text-secondary">
                    <small>Disponible: <span id="saldo-disponible">--</span></small>
                </div>
                <button type="submit" class="btn w-100 btn-success boton-confirmar"
                    id="boton-confirmar">CONFIRMAR</button>
            </form>
        </div>

        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">Historial de transacciones</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Cantidad</th>
                                <th>Valor Total</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-historial">
                            <tr>
                                <td colspan="5" class="text-center text-muted py-3">Cargando historial...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/tradingPage.js') }}"></script>

</body>

</html>

==================================================
=== ARCHIVO: ./README.md ===
==================================================

# Simulador Exchange - **BlokX**

Este proyecto educativo fue desarrollado en el marco de la materia "Algoritmos y Estructuras de Datos I" de UADE, bajo la supervisi√≥n de la profesora Julia Monasterio.  
Su objetivo es aplicar los conocimientos de la c√°tedra simulando el funcionamiento b√°sico de un exchange de criptomonedas.  
El sistema permite a los usuarios operar con saldo ficticio utilizando datos reales de cotizaci√≥n obtenidos de CoinGecko y Binance.

## üéØ Objetivos del proyecto

- Familiarizar a los usuarios con el entorno de un exchange de criptomonedas.
- Simular operaciones de compra y venta mediante distintos tipos de √≥rdenes: Market, Limit y Stop-Loss.
- Calcular y visualizar ganancias, p√©rdidas y balances del portafolio.
- Almacenar toda la informaci√≥n de manera local utilizando archivos `.json`.
- Comprender la interacci√≥n entre frontend y backend mediante una arquitectura moderna (HTML, CSS, Flask y Python).

## ‚öôÔ∏è Funcionalidades

### Panel general de cotizaciones
- Visualizaci√≥n del top de criptomonedas con:
  - Nombre, ticker, precio, market cap, volumen, supply.
  - Variaci√≥n en 1h, 24h y 7 d√≠as.
- Actualizaci√≥n autom√°tica de precios cada 15 segundos.

### Panel de trading
En este panel se ver√°n tres secciones diferentes que contemplan lo necesario para ejecutar las ordenes de compra/venta.

#### Gr√°fico de velas japonesas
- Grafico en el cual se va a poder visualizar los diferentes pares de criptos usando Lightweight Charts (Libreria de JavaScript), en diferentes time frames: 1m, 5m, 15m, 1h, 4hs, 1d y 1w.

#### √ìrdenes
- Compra y venta de activos con √≥rdenes:
  - Market
  - Limit
  - Stop-loss
- Comisi√≥n fija del 0.5% por transacci√≥n.
- Validaciones de saldo y tenencias disponibles.

#### Historial
- Registro de todas las operaciones realizadas.
- Incluye tipo de orden, precio, cantidad, fecha y fee aplicado.
  
### Billetera
- Visualizaci√≥n de tenencias actuales:
  - Cantidad, precio promedio, valor actual, ganancia/p√©rdida por activo.
- Balance total del portafolio en USDT.

## üß† C√≥mo funciona el sistema

El sistema est√° dise√±ado bajo una arquitectura desacoplada que separa claramente las responsabilidades del backend y del frontend:

- **Backend (Python/Flask)**: Act√∫a como una API pura de JSON. Sus responsabilidades son:
    - **`rutas/`**: Define los endpoints de la API (`/api/...`) que exponen los datos y la l√≥gica de negocio en formato JSON. Tambi√©n sirve el contenedor HTML inicial de cada p√°gina.
    - **`servicios/`**: Contiene toda la l√≥gica de negocio (c√°lculos de billetera, procesamiento de √≥rdenes, formato de datos) y prepara los datos para ser enviados como JSON.
    - **`acceso_datos/`**: Gestiona la lectura y escritura de los archivos `.json` que act√∫an como base de datos.
    - **`utils/`**: Proporciona funciones de utilidad, como formateadores de datos que se aplican en el backend.

- **Frontend (JavaScript)**: Es un cliente din√°mico que consume la API del backend.
    - **Aut√≥nomo**: Cada p√°gina carga su propio HTML y luego utiliza JavaScript para buscar todos los datos que necesita de los endpoints `/api/...`.
    - **Renderizado en el cliente**: Todo el renderizado y la manipulaci√≥n del DOM (actualizaci√≥n de tablas, saldos, gr√°ficos) se realiza en el navegador, creando una experiencia de usuario fluida y r√°pida sin recargas de p√°gina.
    - **Estructura modular en `js/`**:
        - **`pages/`**: Contiene la l√≥gica de inicializaci√≥n y orquestaci√≥n para cada p√°gina principal (ej. `tradingPage.js`).
        - **`components/`**: M√≥dulos encargados de actualizar partes espec√≠ficas de la interfaz (ej. `uiUpdater.js`, `tablaCotizacionesUI.js`).
        - **`services/`**: Gestiona la comunicaci√≥n con la API del backend.

### Flujo desacoplado

1.  El usuario navega a una URL (ej. `/trading`).
2.  Flask sirve un archivo HTML m√≠nimo (`trading.html`) que act√∫a como un esqueleto.
3.  El archivo JavaScript asociado a esa p√°gina (`tradingPage.js`) se ejecuta.
4.  El script de JS realiza llamadas a los endpoints de la API del backend (`/api/cotizaciones`, `/api/historial`, etc.) para obtener los datos en formato JSON.
5.  Una vez recibidos los datos, JavaScript actualiza din√°micamente el DOM para mostrar la informaci√≥n al usuario.

## üóÉÔ∏è Estructura del proyecto

```
simulador_exchange/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ app.py                      # Servidor Flask y punto de entrada
‚îÇ   ‚îú‚îÄ‚îÄ config.py                   # Configuraci√≥n del sistema y constantes globales
‚îÇ   ‚îú‚îÄ‚îÄ rutas/                      # Blueprints que definen las vistas y API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trading_vista.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ billetera_vista.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api_cotizaciones_vista.py
‚îÇ   ‚îú‚îÄ‚îÄ servicios/                  # L√≥gica de negocio de cada m√≥dulo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_cotizaciones.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ estado_billetera.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ velas_logica.py
‚îÇ   ‚îú‚îÄ‚îÄ acceso_datos/               # Acceso y manipulaci√≥n de archivos .json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ datos_billetera.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ datos_cotizaciones.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ datos_historial.py
‚îÇ   ‚îî‚îÄ‚îÄ utils/                      # Utilidades auxiliares
‚îÇ       ‚îî‚îÄ‚îÄ formatters.py
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ templates/                  # Plantillas HTML (contenedores iniciales)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ billetera.html
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trading.html
‚îÇ   ‚îî‚îÄ‚îÄ static/                     # Archivos est√°ticos
‚îÇ       ‚îú‚îÄ‚îÄ css/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ styles_index.css
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ styles_trading.css
‚îÇ       ‚îú‚îÄ‚îÄ img/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ logo_BlocX.png
‚îÇ       ‚îî‚îÄ‚îÄ js/                     # L√≥gica del cliente
‚îÇ           ‚îú‚îÄ‚îÄ components/         # M√≥dulos para actualizar la UI
‚îÇ           ‚îú‚îÄ‚îÄ pages/              # Scripts de orquestaci√≥n por p√°gina
‚îÇ           ‚îî‚îÄ‚îÄ services/           # Servicios de comunicaci√≥n con la API
‚îÇ
‚îú‚îÄ‚îÄ datos/                          # Archivos de persistencia
‚îÇ   ‚îú‚îÄ‚îÄ billetera.json
‚îÇ   ‚îú‚îÄ‚îÄ datos_cotizaciones.json
‚îÇ   ‚îú‚îÄ‚îÄ datos_velas.json
‚îÇ   ‚îî‚îÄ‚îÄ historial_operaciones.json
‚îÇ
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ README.md
```

## üöÄ C√≥mo ejecutar el proyecto

### 1. Crear entorno virtual (recomendado)
```bash
python3 -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

### 2. Instalar dependencias
```bash
pip install -r requirements.txt
```

### 3. Iniciar la app
```bash
python3 app.py
```

Y luego acceder desde el navegador a:  
```
http://localhost:5000
```

## üì¶ Tecnolog√≠as utilizadas

- Python 3.13
- Flask
- HTML, CSS, JavaScript
- Lightweight Charts (TradingView)

## üìå Notas

- Todos los datos se almacenan localmente en formato JSON.
- No se requiere conexi√≥n a bases de datos externas.
- El sistema est√° pensado para ser did√°ctico y extensible.

---

**Grupo 12**  
Fausto Lovera ‚Äî Patricio Menta ‚Äî Andrei Veis


==================================================
=== ARCHIVO: ./requirements.txt ===
==================================================

Flask==3.1.0
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
requests==2.32.3
Werkzeug==3.1.3



==================================================
=== FIN DEL REPORTE ===
==================================================
