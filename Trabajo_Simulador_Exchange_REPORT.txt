==================================================
=== REPORTE DE C√ìDIGO CONSOLIDADO ===
Proyecto: Trabajo_Simulador_Exchange
Ruta: /Users/andreiveis/UADE/2do cuatrimestre/05_Algoritmos y Estructura de datos I/Trabajo_Simulador_Exchange
Generado el: Thu Jun 26 23:16:39 -03 2025
==================================================

--- INFORMACI√ìN DEL REPOSITORIO GIT ---
Rama actual: fix_codigo
√öltimo commit: b9bc3ad - Ordenes MARKET y LIMITE OK. Falta correcto dise√±o de stop-limit. Ahora trabajando en eso. (andreiveisuade, 6 hours ago)
---

--- ESTRUCTURA DEL DIRECTORIO ---
.
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ backend
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ acceso_datos
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ datos_billetera.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ datos_comisiones.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ datos_cotizaciones.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ datos_historial.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ datos_ordenes.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ app.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ rutas
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api_externa.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ billetera_vista.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ home.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ trading_vista.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ servicios
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api_cotizaciones.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ estado_billetera.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ presentacion_datos.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ trading
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ ejecutar_orden.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ gestor.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ motor.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ procesador.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ formatters.py
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ utilidades_numericas.py
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ documentacion.md
‚îú‚îÄ‚îÄ frontend
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ static
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ css
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ styles_index.css
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles_trading.css
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ img
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ components
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ chartRenderer.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ domElements.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ formLogic.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ tablaCotizacionesUI.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ uiState.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ uiUpdater.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ pages
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ billeteraPage.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ indexPage.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ tradingPage.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ services
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ apiService.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ appState.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ statePersistence.js
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬† ‚îÇ¬†¬†         ‚îî‚îÄ‚îÄ sweetalert-init.js
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ templates
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ _flashes.html
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ billetera.html
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ index.html
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ trading.html
‚îú‚îÄ‚îÄ pytest.ini
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ test_estado_billetera.py
    ‚îú‚îÄ‚îÄ test_trading_logica.py
    ‚îî‚îÄ‚îÄ test_velas_logica.py

18 directories, 53 files
---

==================================================
=== ARCHIVO: ./.env ===
==================================================

# Clave secreta para sesiones de Flask. ¬°NO COMPARTIR!
FLASK_SECRET_KEY='f9ce7ff641c611e7e519d1551ccdfd699929967d87528324'


==================================================
=== ARCHIVO: ./.gitignore ===
==================================================

# ARCHIVOS PROPIOS NUESTROS
/datos/datos_cotizaciones.json
/datos/datos_velas.json
/datos/billetera.json
/datos/historial_operaciones.json


# Python
__pycache__/
backend/__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.env
.venv
env/
venv/
ENV/
.pytest_cache/
.coverage
coverage.xml
*.cover
.hypothesis/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
__MACOSX/

# IDEs and editors
.idea/
.vscode/
*.swp
*.swo
.project
.classpath
*.sublime-workspace
*.sublime-project

# Frontend
node_modules/
/dist
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env.local
.env.*.local
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database
*.sqlite
*.sqlite3
*.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Backup files
*.bak
*.backup
*~

# Environment variables
.env
.env.*
!.env.example

# System Files
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
datos/billetera.json
datos/datos_cotizaciones.json
datos/datos_velas.json
*.pyc
# D2 files
*.d2
diagrama.png


==================================================
=== ARCHIVO: ./backend/__init__.py ===
==================================================

"""
Paquete principal del backend de la aplicaci√≥n.

Este archivo `__init__.py` no solo marca el directorio `backend` como un paquete de
Python, sino que tambi√©n contiene la "Application Factory" `crear_app`.
Este patr√≥n es una buena pr√°ctica en Flask que permite crear m√∫ltiples instancias
de la aplicaci√≥n con diferentes configuraciones, facilitando las pruebas y la
escalabilidad.
"""

from flask import Flask
from config import FLASK_SECRET_KEY
from backend.rutas import registrar_rutas

def crear_app() -> Flask:
    """
    Crea, configura y devuelve una instancia de la aplicaci√≥n Flask.

    Esta funci√≥n sigue el patr√≥n de dise√±o "Application Factory". Se encarga de:
    1. Crear la instancia de la aplicaci√≥n Flask.
    2. Configurar la ubicaci√≥n de las carpetas de plantillas y archivos est√°ticos.
    3. Establecer la clave secreta para la gesti√≥n de sesiones y mensajes flash.
    4. Registrar todos los blueprints (conjuntos de rutas) de la aplicaci√≥n.

    Returns:
        Flask: La instancia de la aplicaci√≥n Flask configurada y lista para usarse.
    """
    app = Flask(
        __name__,
        static_folder="../frontend/static",
        template_folder="../frontend/templates",
    )

    app.secret_key = FLASK_SECRET_KEY

    registrar_rutas(app)

    return app

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_billetera.py ===
==================================================

# backend/acceso_datos/datos_billetera.py
### MODIFICADO Y SIMPLIFICADO ###

import json
import os
from decimal import Decimal

from backend.utils.utilidades_numericas import a_decimal, cuantizar_cripto
from config import BILLETERA_PATH, BALANCE_INICIAL_USDT

def _crear_billetera_inicial() -> dict:
    """Crea el objeto de billetera inicial con la nueva estructura."""
    return {
        "USDT": {
            "nombre": "Tether",
            "saldos": {
                "disponible": a_decimal(BALANCE_INICIAL_USDT),
                "reservado": a_decimal("0")
            }
        }
    }

def cargar_billetera() -> dict[str, dict]:
    """
    Carga la billetera de criptomonedas desde un archivo JSON.
    Asume que el archivo ya est√° en el nuevo formato.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    if not os.path.exists(BILLETERA_PATH) or os.path.getsize(BILLETERA_PATH) == 0:
        billetera_inicial = _crear_billetera_inicial()
        guardar_billetera(billetera_inicial)
        return billetera_inicial

    try:
        with open(BILLETERA_PATH, "r", encoding="utf-8") as f:
            datos_cargados = json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(f"Advertencia: Archivo '{BILLETERA_PATH}' corrupto. Se reiniciar√° la billetera.")
        billetera_inicial = _crear_billetera_inicial()
        guardar_billetera(billetera_inicial)
        return billetera_inicial

    # Carga directa asumiendo el nuevo formato
    billetera_final = {}
    for ticker, activo in datos_cargados.items():
        billetera_final[ticker] = {
            "nombre": activo.get("nombre", ticker),
            "saldos": {
                "disponible": a_decimal(activo["saldos"].get("disponible", "0")),
                "reservado": a_decimal(activo["saldos"].get("reservado", "0"))
            }
        }
    return billetera_final

def guardar_billetera(billetera: dict[str, dict]):
    """
    Guarda el estado actual de la billetera en un archivo JSON.
    Usa la nueva estructura y formatea los ceros para mejorar la legibilidad.
    """
    os.makedirs(os.path.dirname(BILLETERA_PATH), exist_ok=True)

    # Renombramos 'billetera_serializable' a 'datos_para_json' para m√°s claridad
    datos_para_json = {}
    for ticker, activo in billetera.items():
        saldos = activo.get("saldos", {})
        
        saldo_disponible = saldos.get("disponible", a_decimal(0))
        saldo_reservado = saldos.get("reservado", a_decimal(0))
        
        saldo_disponible_q = cuantizar_cripto(saldo_disponible)
        saldo_reservado_q = cuantizar_cripto(saldo_reservado)
        
        # Formateo de ceros para legibilidad
        str_disponible = "0.00000000" if saldo_disponible_q.is_zero() else str(saldo_disponible_q)
        str_reservado = "0.00000000" if saldo_reservado_q.is_zero() else str(saldo_reservado_q)
        
        datos_para_json[ticker] = {
            "nombre": activo.get("nombre", ticker),
            "saldos": {
                "disponible": str_disponible,
                "reservado": str_reservado,
            }
        }

    with open(BILLETERA_PATH, "w", encoding="utf-8") as f:
        json.dump(datos_para_json, f, indent=4)

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_comisiones.py ===
==================================================

# backend/acceso_datos/datos_comisiones.py
### MODIFICADO ###

import json
import os
from datetime import datetime
from decimal import Decimal

# Importamos las nuevas utilidades num√©ricas
from backend.utils.utilidades_numericas import cuantizar_cripto, cuantizar_usd
from config import COMISIONES_PATH

def cargar_comisiones() -> list:
    """Carga el historial de comisiones desde el archivo JSON."""
    if not os.path.exists(COMISIONES_PATH) or os.path.getsize(COMISIONES_PATH) == 0:
        return []
    try:
        with open(COMISIONES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(f"Advertencia: No se pudo leer o el archivo '{COMISIONES_PATH}' est√° corrupto.")
        return []

def registrar_comision(
    ticker_comision: str,
    cantidad_comision: Decimal,
    valor_usd_comision: Decimal
):
    """
    Guarda un nuevo registro de comisi√≥n usando las utilidades de cuantizaci√≥n.
    """
    os.makedirs(os.path.dirname(COMISIONES_PATH), exist_ok=True)
    comisiones = cargar_comisiones()

    cantidad_comision_q = cuantizar_cripto(cantidad_comision)
    valor_usd_comision_q = cuantizar_usd(valor_usd_comision)

    nueva_comision = {
        "id": len(comisiones) + 1,
        "timestamp": datetime.now().isoformat(),
        "ticker": ticker_comision,
        "cantidad": str(cantidad_comision_q),
        "valor_usd": str(valor_usd_comision_q),
    }
    
    print(
        f"üí∞ COMISI√ìN REGISTRADA: "
        f"{nueva_comision['cantidad']} {nueva_comision['ticker']} "
        f"(valor: ${nueva_comision['valor_usd']})"
    )

    comisiones.insert(0, nueva_comision)

    with open(COMISIONES_PATH, "w", encoding="utf-8") as f:
        json.dump(comisiones, f, indent=4)

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_cotizaciones.py ===
==================================================

"""
M√≥dulo de acceso a datos de cotizaciones.

Este m√≥dulo utiliza un patr√≥n de f√°brica (closure) para gestionar un cach√© de precios
en memoria de forma segura, evitando el uso de variables globales expl√≠citas.

Expone p√∫blicamente:
- obtener_precio(ticker): Obtiene el precio de una cripto, usando el cach√©.
- cargar_datos_cotizaciones(): Carga la lista de cotizaciones desde el archivo.
- guardar_datos_cotizaciones(data): Guarda las cotizaciones en el archivo y
  autom√°ticamente actualiza el cach√©.
"""

import json
import os
from decimal import Decimal
from typing import Callable, Tuple, Any

from config import COTIZACIONES_PATH


# Funci√≥n f√°brica
def _crear_gestor_cache_precios() -> Tuple[Callable[[str], Decimal | None], Callable[[], None]]:
    """
    Funci√≥n de f√°brica interna que crea un gestor de cach√© de precios.

    Usa un closure para encapsular el diccionario del cach√© (_cache), protegi√©ndolo
    del acceso externo y eliminando la necesidad de variables globales o de m√≥dulo.

    Returns:
        Una tupla con dos funciones que operan sobre el mismo cach√© encapsulado:
        - La funci√≥n para obtener un precio.
        - La funci√≥n para forzar una recarga del cach√©.
    """
    _cache = {}  # Este diccionario es privado y solo vive en este m√≥dulo.

    def _recargar_desde_archivo():
        """
        Funci√≥n interna y privada que lee el archivo JSON y puebla el cach√©.
        Modifica la variable `_cache` de su closure.
        """
        nonlocal _cache
        print("üîÑ Recargando cach√© de precios desde el archivo...")
        
        if not os.path.exists(COTIZACIONES_PATH) or os.path.getsize(COTIZACIONES_PATH) == 0:
            lista_criptos = []
        else:
            try:
                with open(COTIZACIONES_PATH, "r", encoding="utf-8") as f:
                    lista_criptos = json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                lista_criptos = []
        
        _cache = {
            cripto.get("ticker", "").upper(): Decimal(str(cripto.get("precio_usd", "0")))
            for cripto in lista_criptos
        }
        print("‚úÖ Cach√© de precios actualizado en memoria.")

    def obtener_precio_desde_cache(ticker: str) -> Decimal | None:
        """
        Obtiene el precio de un ticker desde el cach√©.
        Si el cach√© est√° vac√≠o, dispara la recarga la primera vez.
        """
        if not _cache:
            _recargar_desde_archivo()
        
        return _cache.get(ticker.upper())

    def forzar_recarga_cache():
        """Funci√≥n p√∫blica para forzar la recarga del cach√©."""
        _recargar_desde_archivo()

    # La f√°brica devuelve las dos funciones que el resto de la app usar√°.
    return obtener_precio_desde_cache, forzar_recarga_cache

# --- Punto de Entrada del M√≥dulo ---

# 1. Llamamos a la f√°brica UNA SOLA VEZ cuando se importa este m√≥dulo.
# 2. Se crea un cach√© privado y dos funciones ('_obtener', '_recargar') que lo gestionan.
# 3. Asignamos esas funciones a nombres a nivel de m√≥dulo que ser√°n exportados.
_obtener, _recargar = _crear_gestor_cache_precios()


# --- API P√∫blica del M√≥dulo ---

def obtener_precio(ticker: str) -> Decimal | None:
    """
    Interfaz p√∫blica para obtener el precio de una criptomoneda desde el cach√©.
    """
    return _obtener(ticker)


def cargar_datos_cotizaciones() -> list[dict]:
    """
    Interfaz p√∫blica para cargar la lista completa de cotizaciones desde el archivo.
    Esto es necesario para el m√≥dulo de presentaci√≥n que formatea todos los datos.
    """
    if not os.path.exists(COTIZACIONES_PATH) or os.path.getsize(COTIZACIONES_PATH) == 0:
        return []
    try:
        with open(COTIZACIONES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        return []


def guardar_datos_cotizaciones(data: list[dict[str, Any]]):
    """
    Interfaz p√∫blica para guardar los datos de cotizaciones en el archivo.
    Despu√©s de guardar, fuerza autom√°ticamente la recarga del cach√© en memoria.
    """
    os.makedirs(os.path.dirname(COTIZACIONES_PATH), exist_ok=True)
    print("üíæ Guardando datos en datos_cotizaciones.json...")
    try:
        with open(COTIZACIONES_PATH, "w") as archivo:
            # Usar un default handler para convertir Decimal a float en la serializaci√≥n.
            # Esto es solo si los datos de entrada contienen Decimals, lo cual no deber√≠a ser el caso.
            json.dump(data, archivo, indent=4)
        print("‚úÖ Datos de cotizaciones guardados en archivo.")
        # Llama a la funci√≥n de recarga para mantener el cach√© sincronizado.
        _recargar()
    except (IOError, TypeError) as e:
        print(f"‚ùå Error al guardar el archivo de cotizaciones: {e}")

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_historial.py ===
==================================================

# backend/acceso_datos/datos_historial.py
### MODIFICADO ###

import json
import os
from datetime import datetime
from decimal import Decimal

# Importamos las nuevas utilidades num√©ricas
from backend.utils.utilidades_numericas import cuantizar_cripto, cuantizar_usd
from config import HISTORIAL_PATH


def cargar_historial():
    """
    Carga el historial de transacciones desde el archivo JSON.
    (Sin cambios en la carga, la conversi√≥n a Decimal se hace en la capa de servicios).
    """
    if not os.path.exists(HISTORIAL_PATH) or os.path.getsize(HISTORIAL_PATH) == 0:
        return []

    try:
        with open(HISTORIAL_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(
            f"Advertencia: No se pudo leer o el archivo '{HISTORIAL_PATH}' est√° corrupto."
        )
        return []


def guardar_en_historial(
    tipo_operacion: str,
    moneda_origen: str,
    cantidad_origen: Decimal,
    moneda_destino: str,
    cantidad_destino: Decimal,
    valor_usd: Decimal,
):
    """
    Guarda una nueva operaci√≥n en el historial de transacciones.

    Usa las utilidades de cuantizaci√≥n para asegurar la precisi√≥n correcta
    antes de guardar los datos en el archivo JSON.
    """
    os.makedirs(os.path.dirname(HISTORIAL_PATH), exist_ok=True)
    historial = cargar_historial()

    # ### ANTES: usaba .quantize() con valores m√°gicos.
    # ### DESPU√âS: usamos las utilidades centralizadas.
    cantidad_origen_q = cuantizar_cripto(cantidad_origen)
    cantidad_destino_q = cuantizar_cripto(cantidad_destino)
    valor_usd_q = cuantizar_usd(valor_usd)

    operacion = {
        "id": len(historial) + 1,
        "timestamp": datetime.now().isoformat(),
        "tipo": tipo_operacion,
        "origen": {"ticker": moneda_origen, "cantidad": str(cantidad_origen_q)},
        "destino": {"ticker": moneda_destino, "cantidad": str(cantidad_destino_q)},
        "valor_usd": str(valor_usd_q),
    }

    historial.insert(0, operacion)

    with open(HISTORIAL_PATH, "w", encoding="utf-8") as f:
        json.dump(historial, f, indent=4)

==================================================
=== ARCHIVO: ./backend/acceso_datos/datos_ordenes.py ===
==================================================

# backend/acceso_datos/datos_ordenes.py

"""
M√≥dulo de Acceso a Datos para las √ìrdenes Pendientes.

Este m√≥dulo se encarga de la persistencia de las √≥rdenes de trading que no se
ejecutan de inmediato (L√≠mite, Stop-Loss) y que est√°n a la espera de que se
cumplan ciertas condiciones de mercado.
"""
import json
import os
from config import ORDENES_PENDIENTES_PATH


def cargar_ordenes_pendientes() -> list[dict]:
    """
    Carga la lista de √≥rdenes pendientes desde el archivo JSON.

    Si el archivo no existe o est√° vac√≠o, devuelve una lista vac√≠a.

    Returns:
        list[dict]: Una lista de diccionarios, donde cada uno es una orden pendiente.
    """
    # Asegura que el directorio exista
    os.makedirs(os.path.dirname(ORDENES_PENDIENTES_PATH), exist_ok=True)
    
    if not os.path.exists(ORDENES_PENDIENTES_PATH) or os.path.getsize(ORDENES_PENDIENTES_PATH) == 0:
        return []

    try:
        with open(ORDENES_PENDIENTES_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        print(f"Advertencia: No se pudo leer o el archivo '{ORDENES_PENDIENTES_PATH}' est√° corrupto.")
        return []


def guardar_ordenes_pendientes(lista_ordenes: list[dict]):
    """
    Guarda la lista completa de √≥rdenes pendientes en el archivo JSON.

    Esta funci√≥n sobrescribe el archivo con la lista proporcionada. Se utiliza
    para actualizar el estado de las √≥rdenes (ej. de 'pendiente' a 'ejecutada').

    Args:
        lista_ordenes (list[dict]): La lista completa de √≥rdenes a guardar.
    """
    # Asegura que el directorio exista
    os.makedirs(os.path.dirname(ORDENES_PENDIENTES_PATH), exist_ok=True)

    with open(ORDENES_PENDIENTES_PATH, "w", encoding="utf-8") as f:
        json.dump(lista_ordenes, f, indent=4)


def agregar_orden_pendiente(nueva_orden: dict):
    """
    A√±ade una nueva orden a la lista de √≥rdenes pendientes y la guarda.

    Args:
        nueva_orden (dict): El diccionario que representa la nueva orden a agregar.
    """
    ordenes = cargar_ordenes_pendientes()
    ordenes.append(nueva_orden)
    guardar_ordenes_pendientes(ordenes)

==================================================
=== ARCHIVO: ./backend/app.py ===
==================================================

"""
Punto de entrada para ejecutar la aplicaci√≥n Flask en modo de desarrollo.

Este script importa la 'Application Factory' (`crear_app`), la utiliza para
crear una instancia de la aplicaci√≥n y, si se ejecuta directamente, inicia
el servidor de desarrollo de Flask.

Para iniciar la aplicaci√≥n, ejecuta el siguiente comando desde el directorio ra√≠z
del proyecto:
    python -m backend.app
"""

from flask import Flask
from . import crear_app

# Se crea la instancia global de la aplicaci√≥n llamando a la factory.
app: Flask = crear_app()

# El siguiente bloque se ejecuta solo si el script es llamado directamente
# por el int√©rprete de Python (por ejemplo, `python -m backend.app`).
if __name__ == "__main__":
    # Inicia el servidor de desarrollo de Flask.
    # `debug=True` activa el modo de depuraci√≥n, que proporciona un depurador
    # interactivo y recarga autom√°ticamente el servidor al detectar cambios.
    app.run(debug=True)

==================================================
=== ARCHIVO: ./backend/rutas/__init__.py ===
==================================================

"""
Inicializa el paquete de rutas y registra todos los Blueprints de la aplicaci√≥n.

Este archivo importa los Blueprints definidos en los diferentes m√≥dulos de vistas
(home, trading, billetera, etc.) y proporciona una funci√≥n centralizada `registrar_rutas`
para vincularlos a la instancia principal de la aplicaci√≥n Flask.
"""

from .home import bp as home_bp
from .trading_vista import bp as trading_bp
from .billetera_vista import bp as billetera_bp
from .api_externa import bp as api_ruta_bp


def registrar_rutas(app):
    """
    Registra todos los Blueprints de la aplicaci√≥n en la instancia de Flask.

    Args:
        app (Flask): La instancia principal de la aplicaci√≥n Flask a la que se
                     registrar√°n los Blueprints.

    Side Effects:
        Modifica el objeto `app` registrando las rutas definidas en los Blueprints.
    """
    app.register_blueprint(home_bp)
    app.register_blueprint(trading_bp)
    app.register_blueprint(billetera_bp)
    app.register_blueprint(api_ruta_bp)


==================================================
=== ARCHIVO: ./backend/rutas/api_externa.py ===
==================================================

# backend/rutas/api_externa.py

"""
Define los endpoints de la API externa de la aplicaci√≥n.

Este m√≥dulo contiene las rutas que exponen datos del mercado de criptomonedas,
como cotizaciones y datos de velas (candlestick), para ser consumidos por el frontend
u otros clientes.
"""

from flask import Blueprint, jsonify
from backend.servicios.api_cotizaciones import obtener_datos_criptos_coingecko, obtener_velas_de_api
from backend.servicios.presentacion_datos import obtener_cotizaciones_formateadas

from backend.servicios.trading.motor import verificar_y_ejecutar_ordenes_pendientes

bp = Blueprint("api_externa", __name__, url_prefix="/api")


@bp.route("/actualizar")
def actualizar():
    """
    Endpoint para forzar la actualizaci√≥n de los datos de cotizaciones desde CoinGecko.

    Al ser llamado, este endpoint invoca al servicio que obtiene los precios m√°s
    recientes y, crucialmente, LUEGO invoca al motor de ejecuci√≥n de √≥rdenes
    para ver si alguna orden pendiente debe dispararse con los nuevos precios.
    """
    print("--- PING: Endpoint /api/actualizar ALCANZADO ---")
    
    # 1. Obtener los datos m√°s recientes de cotizaciones y guardarlos.
    datos_criptos = obtener_datos_criptos_coingecko()
    
    # --- 2. ¬°ACTIVAR EL MOTOR DE EJECUCI√ìN DE √ìRDENES! ---
    # Con los precios frescos en memoria, verificamos si alguna orden pendiente se cumple.
    verificar_y_ejecutar_ordenes_pendientes()
    
    # 3. Devolver la respuesta al frontend.
    return jsonify({"estado": "ok", "cantidad_criptos": len(datos_criptos)})


@bp.route("/cotizaciones")
def get_cotizaciones():
    """
    Retorna la lista completa de cotizaciones, formateada para la presentaci√≥n.

    Esta ruta utiliza el servicio de presentaci√≥n para tomar los datos crudos
    y enriquecerlos con formato antes de enviarlos al frontend.

    Returns:
        Response: Un objeto JSON que contiene una lista de todas las criptomonedas
                  y sus datos de cotizaci√≥n listos para ser mostrados.
                  Ejemplo: `[{"ticker": "BTC", "precio_usd_formatted": "$65,000.10", ...}]`
    """
    return jsonify(obtener_cotizaciones_formateadas())


@bp.route("/velas/<string:ticker>/<string:interval>")
def obtener_datos_velas_por_ticker(ticker: str, interval: str):
    """
    Obtiene los datos de velas (candlestick) para un par y un intervalo espec√≠ficos.

    Esta ruta din√°mica consulta a una API externa para obtener los datos hist√≥ricos
    de precios (OHLCV) necesarios para graficar las velas.

    Args:
        ticker (str): El s√≠mbolo del par a consultar (ej. "BTCUSDT").
        interval (str): El intervalo de tiempo para las velas (ej. "1h", "4h", "1d").

    Returns:
        Response: Un objeto JSON con una lista de listas, donde cada sublista
                  representa una vela. En caso de error, retorna una lista vac√≠a.
                  Ejemplo: `[[1622505600000, "49000.00", ...], ...]`
    """
    try:
        datos = obtener_velas_de_api(ticker, interval)
        return jsonify(datos)
    except Exception as e:
        print(f"‚ùå Error en la ruta de velas para {ticker}/{interval}: {e}")
        return jsonify([])

==================================================
=== ARCHIVO: ./backend/rutas/billetera_vista.py ===
==================================================

"""
Define las rutas relacionadas con la visualizaci√≥n de la billetera y el historial.

Este m√≥dulo contiene los endpoints para renderizar la p√°gina de la billetera
y para proporcionar datos financieros (estado actual y transacciones pasadas)
 a trav√©s de una API REST al frontend.
"""

from flask import Blueprint, render_template, jsonify, request, flash, redirect, url_for
from backend.servicios.estado_billetera import estado_actual_completo, obtener_historial_formateado
from backend.acceso_datos.datos_comisiones import cargar_comisiones
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes
from backend.servicios.trading.gestor import cancelar_orden_pendiente

bp = Blueprint("billetera", __name__)


@bp.route("/billetera")
def mostrar_billetera():
    """
    Renderiza la p√°gina principal de la billetera.

    Esta ruta sirve el archivo `billetera.html`, que act√∫a como el contenedor
    principal para la interfaz de la billetera. Los datos se cargan de forma
    as√≠ncrona a trav√©s de llamadas a la API desde JavaScript.

    Returns:
        Response: El contenido HTML renderizado de la p√°gina de la billetera.
    """
    return render_template("billetera.html")


@bp.route("/api/billetera/estado-completo")
def get_estado_billetera_completo():
    """
    Endpoint de API que devuelve el estado financiero completo de la billetera.

    Proporciona un resumen detallado que incluye el balance de cada criptomoneda,
    su valor en USD, el total general, y el rendimiento.

    Returns:
        Response: Un objeto JSON con el estado completo de la billetera.
            Ejemplo: `{"total_usd": "10500.50", "rendimiento": "5.00", ...}`
    """
    datos = estado_actual_completo()
    return jsonify(datos)


@bp.route("/api/historial")
def get_historial_transacciones():
    """
    Endpoint de API que devuelve el historial completo de transacciones.

    Retorna una lista de todas las operaciones de compra y venta realizadas,
    formateadas para su visualizaci√≥n en el frontend.

    Returns:
        Response: Un objeto JSON que contiene una lista de transacciones.
            Ejemplo: `[{"id": 1, "fecha": "21/06/2025", "tipo": "compra", ...}]`
    """
    return jsonify(obtener_historial_formateado())

@bp.route("/api/comisiones")
def get_historial_comisiones():
    """
    Endpoint de API que devuelve el historial completo de comisiones cobradas.
    """
    return jsonify(cargar_comisiones())

@bp.route("/api/ordenes-abiertas")
def get_ordenes_abiertas():
    """
    Endpoint de API que devuelve la lista de √≥rdenes que est√°n pendientes de ejecuci√≥n.
    """
    todas_las_ordenes = cargar_ordenes_pendientes()
    # Filtramos para devolver solo las que est√°n activas
    ordenes_abiertas = [o for o in todas_las_ordenes if o.get("estado") == "pendiente"]
    return jsonify(ordenes_abiertas)

@bp.route("/api/orden/cancelar/<string:id_orden>", methods=["POST"])
def cancelar_orden_api(id_orden: str):
    """
    ### REFACTORIZADO ### - Endpoint de API para cancelar una orden pendiente.
    Devuelve una respuesta JSON estandarizada.
    """
    resultado = cancelar_orden_pendiente(id_orden)
    
    if "error" in resultado:
        # Si el diccionario de resultado contiene un error, devolvemos un estado 400 (Bad Request).
        return jsonify({
            "estado": "error",
            "mensaje": resultado["error"]
        }), 400
    else:
        # Si no hay error, devolvemos un estado 200 (OK).
        return jsonify({
            "estado": "ok",
            "mensaje": resultado["mensaje"],
            "datos": resultado.get("datos", {})
        }), 200

==================================================
=== ARCHIVO: ./backend/rutas/home.py ===
==================================================

"""
Define la ruta principal (landing page) de la aplicaci√≥n.

Este m√≥dulo es responsable de servir la p√°gina de inicio (index.html),
que act√∫a como el punto de entrada para los usuarios.
"""

from flask import Blueprint, render_template

bp = Blueprint("home", __name__)


@bp.route("/")
def index():
    """
    Renderiza la p√°gina de inicio de la aplicaci√≥n.

    Esta ruta sirve el archivo `index.html`, que es el esqueleto principal
    de la interfaz. El contenido din√°mico, como las cotizaciones, se carga
    posteriormente de forma as√≠ncrona mediante JavaScript.

    Returns:
        Response: El contenido HTML renderizado de la p√°gina de inicio.
    """
    return render_template("index.html")

==================================================
=== ARCHIVO: ./backend/rutas/trading_vista.py ===
==================================================

# backend/rutas/trading_vista.py
### REFACTORIZADO ###

import json # Importamos la librer√≠a json
from flask import Blueprint, request, redirect, url_for, render_template, flash
from backend.servicios.trading.procesador import procesar_operacion_trading

bp = Blueprint("trading", __name__)

@bp.route("/trading", methods=["GET"])
def mostrar_trading_page():
    """ SIN CAMBIOS - Renderiza la p√°gina de trading. """
    return render_template("trading.html")

@bp.route("/trading/operar", methods=["POST"])
def procesar_trading_form():
    """
    ### REFACTORIZADO ###
    Procesa el formulario y pasa un JSON al sistema de flash en caso de √©xito.
    """
    print(">>> DATOS RECIBIDOS DEL FORMULARIO:", request.form)

    ticker_operado = request.form.get("ticker", "BTC").upper()
    
    # Ahora 'mensaje' puede ser un diccionario o un string de error
    exito, mensaje = procesar_operacion_trading(request.form)

    if exito:
        # Si la operaci√≥n fue exitosa, 'mensaje' es un diccionario.
        # Lo convertimos a un string JSON para guardarlo en la sesi√≥n flash.
        flash(json.dumps(mensaje), "success")
    else:
        # Si fall√≥, 'mensaje' ya es un string de error.
        flash(mensaje, "danger")
    
    # La l√≥gica de redirecci√≥n no cambia.
    redirect_url = url_for("trading.mostrar_trading_page", ticker=ticker_operado)
    return redirect(redirect_url)

==================================================
=== ARCHIVO: ./backend/servicios/__init__.py ===
==================================================

"""
El paquete 'servicios' contiene la l√≥gica de negocio de la aplicaci√≥n.

Este m√≥dulo separa las operaciones complejas, los c√°lculos y las interacciones
con APIs externas de las capas de acceso a datos y de las vistas (rutas).
Su objetivo es mantener el c√≥digo organizado, reutilizable y f√°cil de mantener.
"""

==================================================
=== ARCHIVO: ./backend/servicios/api_cotizaciones.py ===
==================================================

"""
Servicio para interactuar con APIs externas de criptomonedas.

Este m√≥dulo centraliza las llamadas a las APIs de CoinGecko (para cotizaciones
generales del mercado) y Binance (para datos de velas/k-lines). Se encarga de
realizar las peticiones, procesar los datos y guardarlos localmente.
"""

from decimal import Decimal
import requests
import json

from backend.acceso_datos.datos_cotizaciones import guardar_datos_cotizaciones
from config import COINGECKO_URL, BINANCE_URL, CANTIDAD_CRIPTOMONEDAS, CANTIDAD_VELAS

def obtener_datos_criptos_coingecko() -> list[dict]:
    """
    Obtiene y procesa datos de mercado desde la API de CoinGecko.

    Realiza una petici√≥n para obtener una lista de las principales criptomonedas,
    procesa la respuesta JSON y guarda los datos crudos en un archivo local.
    El formateo para la UI se delega a otra capa de servicio.
    """
    params = {
        "vs_currency": "usd",
        "order": "market_cap_desc",
        "per_page": CANTIDAD_CRIPTOMONEDAS,
        "page": 1,
        "sparkline": "false",
        "price_change_percentage": "1h,24h,7d",
    }

    try:
        respuesta = requests.get(COINGECKO_URL, params, timeout=10)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Error al obtener datos de CoinGecko: {str(e)}")
        return []

    print(f"‚úÖ Estado de la respuesta CoinGecko: {respuesta.status_code}")

    try:
        datos = respuesta.json()
        resultado = []
        for i, dato in enumerate(datos, start=1):
            resultado.append({
                "id": i,
                "nombre": dato.get("name"),
                "ticker": dato.get('symbol', '').upper(),
                "logo": dato.get("image"),
                "precio_usd": str(Decimal(str(dato.get("current_price", 0)))),
                "1h_%": str(Decimal(str(dato.get("price_change_percentage_1h_in_currency", 0)))),
                "24h_%": str(Decimal(str(dato.get("price_change_percentage_24h_in_currency", 0)))),
                "7d_%": str(Decimal(str(dato.get("price_change_percentage_7d_in_currency", 0)))),
                "market_cap": str(Decimal(str(dato.get("market_cap", 0)))),
                "volumen_24h": str(Decimal(str(dato.get("total_volume", 0)))),
                "circulating_supply": str(Decimal(str(dato.get("circulating_supply", 0)))),
            })
    except (KeyError, TypeError, ValueError, json.JSONDecodeError) as e:
        print(f"‚ùå Error al procesar los datos de CoinGecko: {str(e)}")
        return []

    print(f"üí° Total de criptos procesadas: {len(resultado)}")
    guardar_datos_cotizaciones(resultado)
    return resultado


def obtener_velas_de_api(ticker: str, interval: str) -> list[dict]:
    """
    Obtiene datos hist√≥ricos de velas (K-lines) desde la API de Binance.
    """
    params = {
        "symbol": f"{ticker.upper()}USDT",
        "interval": interval,
        "limit": CANTIDAD_VELAS,
    }
    try:
        respuesta = requests.get(BINANCE_URL, params, timeout=10)
        respuesta.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Error al obtener datos de Binance para {ticker} ({interval}): {str(e)}")
        return []

    print(f"‚úÖ Estado de la respuesta Binance para {ticker} ({interval}): {respuesta.status_code}")

    try:
        datos = respuesta.json()
        if not isinstance(datos, list):
            print(f"‚ö†Ô∏è Respuesta inesperada de Binance para {ticker} ({interval}): {datos}")
            return []
        
        resultado = [
            {
                "time": int(vela[0] / 1000), "open": str(Decimal(vela[1])),
                "high": str(Decimal(vela[2])), "low": str(Decimal(vela[3])),
                "close": str(Decimal(vela[4])), "volume": str(Decimal(vela[5])),
            }
            for vela in datos
        ]
        return resultado
    except (json.JSONDecodeError, IndexError, TypeError) as e:
        print(f"‚ùå Error al procesar los datos de velas de Binance para {ticker}: {e}")
        return []

==================================================
=== ARCHIVO: ./backend/servicios/estado_billetera.py ===
==================================================

# backend/servicios/estado_billetera.py

from decimal import Decimal
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_historial import cargar_historial
# ### L√çNEA CORREGIDA ###
from backend.acceso_datos.datos_cotizaciones import obtener_precio, cargar_datos_cotizaciones
from backend.utils.utilidades_numericas import (
    a_decimal, formato_cantidad_usd, formato_cantidad_cripto, formato_porcentaje
)
from backend.utils.formatters import format_datetime
from config import UMBRAL_POLVO_USD, UMBRAL_CASI_CERO

def _division_segura(numerador: Decimal, denominador: Decimal) -> Decimal:
    return numerador / denominador if denominador > a_decimal(0) else a_decimal(0)

def _preparar_datos_compra(historial: list[dict]) -> dict[str, dict]:
    datos_compra_por_ticker = {}
    for operacion in historial:
        if operacion.get("tipo", "").endswith("compra"):
            destino = operacion.get("destino", {})
            ticker = destino.get("ticker")
            if not ticker or ticker == "USDT": continue
            if ticker not in datos_compra_por_ticker:
                datos_compra_por_ticker[ticker] = {"total_invertido": a_decimal(0), "cantidad_comprada": a_decimal(0)}
            datos_compra_por_ticker[ticker]["total_invertido"] += a_decimal(operacion.get("valor_usd"))
            datos_compra_por_ticker[ticker]["cantidad_comprada"] += a_decimal(destino.get("cantidad"))
    return datos_compra_por_ticker

def _calcular_metricas_activo(ticker: str, cantidad_total: Decimal, precio_actual: Decimal, datos_compra: dict) -> dict:
    valor_actual_usd = cantidad_total * precio_actual
    total_invertido = datos_compra.get("total_invertido", a_decimal(0))
    cantidad_comprada = datos_compra.get("cantidad_comprada", a_decimal(0))
    precio_promedio_compra = _division_segura(total_invertido, cantidad_comprada)
    costo_base_actual = cantidad_total * precio_promedio_compra
    ganancia_o_perdida = valor_actual_usd - costo_base_actual if costo_base_actual > 0 else a_decimal(0)
    porcentaje_ganancia = _division_segura(ganancia_o_perdida, costo_base_actual) * Decimal("100")
    return {
        "ticker": ticker, "cantidad": cantidad_total, "precio_actual": precio_actual,
        "valor_usdt": valor_actual_usd, "precio_promedio_compra": precio_promedio_compra,
        "costo_base_actual": costo_base_actual, "ganancia_perdida": ganancia_o_perdida,
        "porcentaje_ganancia": porcentaje_ganancia,
    }

def _formatear_activo_para_presentacion(activo_calculado: dict, cripto_info: dict, saldos: dict, total_billetera_usd: Decimal) -> dict:
    porcentaje_en_billetera = _division_segura(activo_calculado["valor_usdt"], total_billetera_usd) * Decimal("100")
    es_polvo = activo_calculado["valor_usdt"] < UMBRAL_POLVO_USD

    cantidad_total = activo_calculado["cantidad"]
    saldo_disponible = saldos.get("disponible", a_decimal(0))
    saldo_reservado = saldos.get("reservado", a_decimal(0))

    return {
        "ticker": activo_calculado["ticker"],
        "nombre": cripto_info.get("nombre", activo_calculado["ticker"]),
        "logo": cripto_info.get("logo", ""),
        "es_polvo": es_polvo,
        
        "cantidad_total": str(cantidad_total),
        "cantidad_disponible": str(saldo_disponible),
        "cantidad_reservada": str(saldo_reservado),

        "cantidad_total_formatted": formato_cantidad_cripto(cantidad_total),
        "cantidad_disponible_formatted": formato_cantidad_cripto(saldo_disponible),
        "cantidad_reservada_formatted": formato_cantidad_cripto(saldo_reservado),
        
        "precio_actual_formatted": formato_cantidad_usd(activo_calculado["precio_actual"]),
        "valor_usdt_formatted": formato_cantidad_usd(activo_calculado["valor_usdt"]),
        "ganancia_perdida_formatted": formato_cantidad_usd(activo_calculado["ganancia_perdida"]),
        "ganancia_perdida_cruda": str(activo_calculado["ganancia_perdida"]),
        "porcentaje_ganancia_formatted": formato_porcentaje(activo_calculado["porcentaje_ganancia"]),
        "porcentaje_formatted": formato_porcentaje(porcentaje_en_billetera),
    }

def estado_actual_completo() -> list[dict]:
    billetera = cargar_billetera()
    historial = cargar_historial()
    
    info_criptos = {c['ticker']: c for c in cargar_datos_cotizaciones()}
    
    # ### LA SOLUCI√ìN EST√Å AQU√ç ###
    # Forzamos el nombre y logo can√≥nicos para USDT, ignorando lo que venga de la API.
    # Esto asegura consistencia y evita nombres como "Polygon Bridged USDT".
    info_criptos['USDT'] = {
        'nombre': 'Tether', 
        'logo': 'https://assets.coingecko.com/coins/images/325/large/Tether.png?1696501661',
        'ticker': 'USDT'
    }

    datos_compra_por_ticker = _preparar_datos_compra(historial)
    activos_calculados = []
    
    for ticker, activo_data in billetera.items():
        saldos = activo_data.get("saldos", {})
        cantidad_total = saldos.get("disponible", a_decimal(0)) + saldos.get("reservado", a_decimal(0))

        if cantidad_total < UMBRAL_CASI_CERO:
            continue
            
        # Obtenemos la informaci√≥n de la cripto de nuestro diccionario 'curado'.
        cripto_info_actual = info_criptos.get(ticker, {"nombre": ticker, "logo": ""})

        if ticker == "USDT":
            metricas = {
                "ticker": "USDT", "cantidad": cantidad_total, "precio_actual": a_decimal(1),
                "valor_usdt": cantidad_total, "ganancia_perdida": a_decimal(0),
                "porcentaje_ganancia": a_decimal(0),
            }
        else:
            precio_actual = obtener_precio(ticker) or a_decimal(0)
            datos_compra_activo = datos_compra_por_ticker.get(ticker, {})
            metricas = _calcular_metricas_activo(ticker, cantidad_total, precio_actual, datos_compra_activo)
        
        metricas['cripto_info'] = cripto_info_actual
        metricas['saldos'] = saldos
        activos_calculados.append(metricas)

    activos_calculados.sort(key=lambda x: x['valor_usdt'], reverse=True)
    total_billetera_usd = sum(activo['valor_usdt'] for activo in activos_calculados)

    activos_para_presentacion = [
        _formatear_activo_para_presentacion(activo, activo['cripto_info'], activo['saldos'], total_billetera_usd)
        for activo in activos_calculados
    ]
    return activos_para_presentacion

def obtener_historial_formateado() -> list[dict]:
    historial_crudo = cargar_historial()
    historial_formateado = []
    for item in historial_crudo:
        tipo_op = item.get('tipo', '')
        par_origen = item.get('origen', {}).get('ticker', '?')
        par_destino = item.get('destino', {}).get('ticker', '?')
        cantidad = a_decimal(item.get('destino', {}).get('cantidad')) if tipo_op.endswith('compra') else a_decimal(item.get('origen', {}).get('cantidad'))
        item_formateado = {
            "id": item.get("id"), "tipo": tipo_op,
            "fecha_formatted": format_datetime(item.get('timestamp')),
            "par_formatted": f"{par_destino}/{par_origen}",
            "tipo_formatted": tipo_op.replace('-', ' ').capitalize(),
            "cantidad_formatted": formato_cantidad_cripto(cantidad),
            "valor_total_formatted": formato_cantidad_usd(a_decimal(item.get('valor_usd'))),
        }
        historial_formateado.append(item_formateado)
    return historial_formateado

==================================================
=== ARCHIVO: ./backend/servicios/presentacion_datos.py ===
==================================================

"""
Servicio de Presentaci√≥n de Datos.

Este m√≥dulo se encarga de tomar los datos crudos de la aplicaci√≥n (como las cotizaciones)
y enriquecerlos con formato y l√≥gica de presentaci√≥n para ser consumidos directamente
por el frontend. Utiliza el m√≥dulo `utilidades_numericas` para todo el formateo num√©rico.
"""

from backend.acceso_datos.datos_cotizaciones import cargar_datos_cotizaciones
from backend.utils.formatters import get_performance_indicator
from backend.utils.utilidades_numericas import (
    formato_cantidad_usd,
    formato_porcentaje,
    formato_numero_grande,
    a_decimal
)

def obtener_cotizaciones_formateadas() -> list[dict]:
    """
    Carga las cotizaciones crudas y las transforma en una lista de diccionarios
    listos para ser renderizados en el frontend.
    """
    cotizaciones_crudas = cargar_datos_cotizaciones()
    cotizaciones_presentacion = []

    for cripto in cotizaciones_crudas:
        precio_usd = a_decimal(cripto.get("precio_usd"))
        perf_1h = a_decimal(cripto.get("1h_%"))
        perf_24h = a_decimal(cripto.get("24h_%"))
        perf_7d = a_decimal(cripto.get("7d_%"))
        market_cap = a_decimal(cripto.get("market_cap"))
        volumen_24h = a_decimal(cripto.get("volumen_24h"))
        circulating_supply = a_decimal(cripto.get("circulating_supply"))
        ticker = cripto.get("ticker", "")

        cripto_presentacion = {
            "id": cripto.get("id"),
            "nombre": cripto.get("nombre"),
            "ticker": ticker,
            "logo": cripto.get("logo"),

            "precio_usd_formatted": formato_cantidad_usd(precio_usd),
            "market_cap_formatted": formato_numero_grande(market_cap),
            "volumen_24h_formatted": formato_numero_grande(volumen_24h),
            
            "circulating_supply_formatted": (
                f"{circulating_supply:,.0f} {ticker}"
                if circulating_supply > 0
                else "-"
            ),

            "1h_formatted": formato_porcentaje(perf_1h),
            "24h_formatted": formato_porcentaje(perf_24h),
            "7d_formatted": formato_porcentaje(perf_7d),

            "perf_1h": get_performance_indicator(perf_1h),
            "perf_24h": get_performance_indicator(perf_24h),
            "perf_7d": get_performance_indicator(perf_7d),
        }
        cotizaciones_presentacion.append(cripto_presentacion)

    return cotizaciones_presentacion

==================================================
=== ARCHIVO: ./backend/servicios/trading/__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./backend/servicios/trading/ejecutar_orden.py ===
==================================================

from decimal import Decimal
from typing import Dict

from backend.acceso_datos.datos_billetera import guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio, cargar_datos_cotizaciones
from backend.acceso_datos.datos_historial import guardar_en_historial
from backend.acceso_datos.datos_comisiones import registrar_comision
from config import TASA_COMISION
from backend.utils.utilidades_numericas import a_decimal

# --- Funciones Privadas del M√≥dulo ---

def _crear_activo_si_no_existe(billetera: dict, ticker: str):
    """Crea una entrada para un activo en la billetera si no existe."""
    if ticker not in billetera:
        info_criptos = {c['ticker']: c for c in cargar_datos_cotizaciones()}
        info_nueva_moneda = info_criptos.get(ticker, {"nombre": ticker})
        billetera[ticker] = {"nombre": info_nueva_moneda.get("nombre", ticker), "saldos": {"disponible": a_decimal("0"), "reservado": a_decimal("0")}}

# --- Punto de Entrada P√∫blico del M√≥dulo ---

def ejecutar_transaccion(
    billetera: Dict,
    moneda_origen: str,
    cantidad_origen_bruta: Decimal,
    moneda_destino: str,
    tipo_operacion_historial: str,
    es_orden_pendiente: bool = False
) -> tuple[bool, dict]:
    """
    ### NUEVO - Funci√≥n At√≥mica y Centralizada ###
    Ejecuta una transacci√≥n completa: calcula comisi√≥n, actualiza saldos,
    registra en historial y devuelve los detalles.
    
    Args:
        billetera: El objeto de la billetera actual.
        moneda_origen: Ticker de la moneda que se gasta.
        cantidad_origen_bruta: Cantidad total que se deduce del origen.
        moneda_destino: Ticker de la moneda que se recibe.
        tipo_operacion_historial: String para guardar en el historial (ej. "Compra", "limit-compra").
        es_orden_pendiente: True si los fondos vienen de 'reservado' en lugar de 'disponible'.

    Returns:
        Una tupla (√©xito, diccionario_de_resultados).
    """
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)

    if not all([precio_origen_usdt, precio_destino_usdt, not precio_destino_usdt.is_zero()]):
        return False, {"error": "No se pudo obtener la cotizaci√≥n para ejecutar la transacci√≥n."}

    # 1. Calcular comisi√≥n y cantidades netas
    cantidad_comision = cantidad_origen_bruta * TASA_COMISION
    cantidad_origen_neta = cantidad_origen_bruta - cantidad_comision
    valor_neto_usd_final = cantidad_origen_neta * precio_origen_usdt
    cantidad_destino_neta_final = valor_neto_usd_final / precio_destino_usdt

    # 2. Actualizar saldos de la billetera
    saldo_a_modificar = "reservado" if es_orden_pendiente else "disponible"
    billetera[moneda_origen]["saldos"][saldo_a_modificar] -= cantidad_origen_bruta
    
    _crear_activo_si_no_existe(billetera, moneda_destino)
    billetera[moneda_destino]["saldos"]["disponible"] += cantidad_destino_neta_final
    
    # 3. Registrar comisi√≥n e historial
    registrar_comision(moneda_origen, cantidad_comision, cantidad_comision * precio_origen_usdt)
    guardar_en_historial(
        tipo_operacion_historial,
        moneda_origen,
        cantidad_origen_neta,
        moneda_destino,
        cantidad_destino_neta_final,
        valor_neto_usd_final
    )
    
    # 4. Devolver los detalles de la ejecuci√≥n
    detalles_ejecucion = {
        "cantidad_destino_final": cantidad_destino_neta_final,
        "cantidad_origen_neta": cantidad_origen_neta,
        "cantidad_comision": cantidad_comision,
        "valor_usd_final": valor_neto_usd_final,
    }
    
    return True, detalles_ejecucion

==================================================
=== ARCHIVO: ./backend/servicios/trading/gestor.py ===
==================================================



from datetime import datetime
from typing import Dict

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes, guardar_ordenes_pendientes
from backend.utils.utilidades_numericas import a_decimal


def cancelar_orden_pendiente(id_orden_a_cancelar: str) -> Dict:
    """
    ### REFACTORIZADO ### - Devuelve un √∫nico diccionario de resultados.
    La presencia de la clave 'error' determina el fallo.
    """
    todas_las_ordenes = cargar_ordenes_pendientes()
    orden_encontrada = next((o for o in todas_las_ordenes if o.get("id_orden") == id_orden_a_cancelar), None)
            
    if not orden_encontrada:
        return {"error": f"No se encontr√≥ una orden con el ID {id_orden_a_cancelar}."}
    
    if orden_encontrada.get("estado") != "pendiente":
        return {"error": f"La orden {id_orden_a_cancelar} ya no est√° pendiente y no puede ser cancelada."}

    billetera = cargar_billetera()
    
    moneda_reservada = orden_encontrada["moneda_reservada"]
    cantidad_reservada = a_decimal(orden_encontrada["cantidad_reservada"])
    
    activo_a_liberar = billetera.get(moneda_reservada)

    if not activo_a_liberar or a_decimal(activo_a_liberar["saldos"].get("reservado")) < cantidad_reservada:
        orden_encontrada["estado"] = "error_cancelacion"
        orden_encontrada["mensaje_error"] = "Error de consistencia: los fondos a liberar no se encontraron en la billetera."
        guardar_ordenes_pendientes(todas_las_ordenes)
        return {"error": "Error de consistencia en la billetera. No se pudieron liberar los fondos."}

    activo_a_liberar["saldos"]["reservado"] -= cantidad_reservada
    activo_a_liberar["saldos"]["disponible"] += cantidad_reservada
    
    orden_encontrada.update({
        "estado": "cancelada",
        "timestamp_cancelacion": datetime.now().isoformat()
    })
    
    guardar_billetera(billetera)
    guardar_ordenes_pendientes(todas_las_ordenes)
    
    mensaje_exito = f"Orden {orden_encontrada['par']} cancelada. Se liberaron {formato_cantidad_cripto(cantidad_reservada)} {moneda_reservada}."
    
    return {"mensaje": mensaje_exito, "datos": orden_encontrada}


==================================================
=== ARCHIVO: ./backend/servicios/trading/motor.py ===
==================================================

# backend/servicios/trading/motor.py

from datetime import datetime
from decimal import Decimal

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes, guardar_ordenes_pendientes
from backend.servicios.trading.ejecutar_orden import ejecutar_transaccion
from backend.utils.utilidades_numericas import a_decimal, cuantizar_cripto

def _verificar_condicion_orden(orden: dict, precio_actual: Decimal) -> bool:
    """Verifica si el precio actual cumple la condici√≥n de DISPARO (Stop) de la orden."""
    precio_disparo = a_decimal(orden["precio_disparo"])
    tipo_orden = orden.get("tipo_orden", "limit") # Por defecto, 'limit' si no est√° definido
    
    # Para √≥rdenes L√≠mite
    if tipo_orden == "limit":
        if orden["accion"] == "compra":
            return precio_actual <= precio_disparo
        elif orden["accion"] == "venta":
            return precio_actual >= precio_disparo
            
    # Para √≥rdenes Stop-Limit (antes 'stop-loss')
    elif tipo_orden == "stop-limit":
        # Para una compra stop, queremos comprar cuando el precio SUBE a un nivel.
        if orden["accion"] == "compra":
            return precio_actual >= precio_disparo
        # Para una venta stop, queremos vender cuando el precio CAE a un nivel.
        elif orden["accion"] == "venta":
            return precio_actual <= precio_disparo

    return False

def _ejecutar_orden_pendiente(orden: dict, billetera: dict) -> dict:
    """
    Ejecuta una orden pendiente que ya ha sido disparada,
    con l√≥gica especial para la verificaci√≥n del precio l√≠mite en √≥rdenes Stop-Limit.
    """
    # ### NUEVO: VERIFICACI√ìN DEL PRECIO L√çMITE PARA √ìRDENES STOP-LIMIT ###
    if orden.get("tipo_orden") == "stop-limit":
        precio_limite = a_decimal(orden.get("precio_limite"))
        
        # Si no hay precio l√≠mite en la orden, es un error de datos.
        if not precio_limite or precio_limite.is_zero():
             print(f"‚ùå ERROR DE DATOS: Orden Stop-Limit {orden['id_orden']} no tiene precio l√≠mite v√°lido.")
             orden["estado"] = "error_datos"
             return billetera
             
        # Obtenemos el precio de mercado actual para la comprobaci√≥n del l√≠mite.
        ticker_base = orden["par"].split('/')[0]
        precio_actual_mercado = obtener_precio(ticker_base)

        if not precio_actual_mercado:
             print(f"‚ö†Ô∏è No se pudo obtener precio para la verificaci√≥n l√≠mite de la orden {orden['id_orden']}. Se reintentar√°.")
             return billetera # No hacemos nada, esperamos al siguiente ciclo

        # Condici√≥n de ejecuci√≥n para COMPRA L√çMITE (despu√©s del stop)
        if orden["accion"] == "compra" and precio_actual_mercado > precio_limite:
            print(f"üö¶ ORDEN STOP-LIMIT {orden['id_orden']} DISPARADA, PERO NO EJECUTADA: Precio actual ({precio_actual_mercado}) > Precio L√≠mite ({precio_limite}).")
            return billetera # Se mantiene pendiente hasta que el precio sea favorable
        
        # Condici√≥n de ejecuci√≥n para VENTA L√çMITE (despu√©s del stop)
        elif orden["accion"] == "venta" and precio_actual_mercado < precio_limite:
            print(f"üö¶ ORDEN STOP-LIMIT {orden['id_orden']} DISPARADA, PERO NO EJECUTADA: Precio actual ({precio_actual_mercado}) < Precio L√≠mite ({precio_limite}).")
            return billetera # Se mantiene pendiente hasta que el precio sea favorable

    # --- L√≥gica de ejecuci√≥n de la transacci√≥n (com√∫n a Limit y Stop-Limit que pasaron el filtro) ---
    moneda_origen = orden["moneda_reservada"]
    cantidad_origen_bruta = a_decimal(orden["cantidad_reservada"])
    # Para una compra, el destino es la cripto principal. Para una venta, el origen es la cripto principal.
    moneda_destino = orden["moneda_destino"] if orden["accion"] == "compra" else orden["moneda_origen"]

    # Aqu√≠ es importante determinar correctamente el destino final de la transacci√≥n
    # Si es una compra, la moneda destino es la moneda principal del par.
    # Si es una venta, la moneda destino es la moneda cotizada (quote).
    moneda_destino_final = orden["moneda_destino"]

    tipo_op_historial = f"{orden['tipo_orden'].replace('-', ' ').title()} {orden['accion'].title()}"
    
    exito_ejecucion, detalles_ejecucion = ejecutar_transaccion(
        billetera=billetera,
        moneda_origen=moneda_origen,
        cantidad_origen_bruta=cantidad_origen_bruta,
        moneda_destino=moneda_destino_final,
        tipo_operacion_historial=tipo_op_historial,
        es_orden_pendiente=True
    )
    
    if not exito_ejecucion:
        print(f"‚ùå ERROR al ejecutar orden pendiente {orden['id_orden']}: {detalles_ejecucion.get('error')}")
        orden.update({"estado": "error_ejecucion", "mensaje_error": detalles_ejecucion.get("error")})
        return billetera

    print(f"‚úÖ ORDEN EJECUTADA: {orden['id_orden']} ({orden['par']})")
    orden.update({
        "estado": "ejecutada",
        "timestamp_ejecucion": datetime.now().isoformat(),
        "cantidad_destino_final": str(cuantizar_cripto(detalles_ejecucion["cantidad_destino_final"]))
    })
    
    return billetera

def verificar_y_ejecutar_ordenes_pendientes():
    """Motor principal que itera sobre √≥rdenes pendientes y las ejecuta si cumplen la condici√≥n."""
    todas_las_ordenes = cargar_ordenes_pendientes()
    ordenes_activas = [o for o in todas_las_ordenes if o.get("estado") == "pendiente"]
    if not ordenes_activas: 
        return

    billetera = cargar_billetera()
    precios_cacheados = {}
    alguna_orden_ejecutada = False

    for orden in ordenes_activas:
        ticker_principal = orden["par"].split('/')[0]
        if ticker_principal not in precios_cacheados:
            precios_cacheados[ticker_principal] = obtener_precio(ticker_principal)
        
        precio_actual = precios_cacheados[ticker_principal]
        if precio_actual and _verificar_condicion_orden(orden, precio_actual):
            billetera = _ejecutar_orden_pendiente(orden, billetera)
            # Verificamos si la orden cambi√≥ de estado
            if orden.get("estado") != "pendiente":
                alguna_orden_ejecutada = True

    if alguna_orden_ejecutada:
        print("üíæ Guardando cambios en billetera y lista de √≥rdenes...")
        guardar_billetera(billetera)
        guardar_ordenes_pendientes(todas_las_ordenes)

==================================================
=== ARCHIVO: ./backend/servicios/trading/procesador.py ===
==================================================

# backend/servicios/trading/procesador.py

import uuid
from datetime import datetime
from decimal import Decimal
from typing import Tuple, Dict, Any

from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from backend.acceso_datos.datos_cotizaciones import obtener_precio
from backend.acceso_datos.datos_ordenes import agregar_orden_pendiente
from backend.servicios.trading.ejecutar_orden import ejecutar_transaccion
from backend.utils.utilidades_numericas import (
    a_decimal, cuantizar_cripto, cuantizar_usd, 
    formato_cantidad_cripto, formato_cantidad_usd
)

def _validar_saldo_disponible(billetera: dict, moneda_origen: str, cantidad_requerida: Decimal) -> Tuple[bool, str | None]:
    """Valida si hay suficiente saldo disponible en la billetera."""
    activo = billetera.get(moneda_origen)
    if not activo:
        return False, f"‚ùå No posees {moneda_origen} en tu billetera."
    saldo_disponible = a_decimal(activo['saldos'].get("disponible"))
    if cantidad_requerida > saldo_disponible:
        return False, f"‚ùå Saldo insuficiente. Tienes {formato_cantidad_cripto(saldo_disponible)} {moneda_origen} disponibles, pero se requieren {formato_cantidad_cripto(cantidad_requerida)}."
    return True, None

def _calcular_detalles_intercambio(
    accion: str,
    modo_ingreso: str,
    monto_form: Decimal,
    precio_origen_usdt: Decimal,
    precio_destino_usdt: Decimal
) -> Tuple[bool, Dict[str, Any] | str]:
    """
    Funci√≥n de c√°lculo pura para un intercambio.
    No modifica estado, solo realiza matem√°ticas. Devuelve las cantidades brutas.
    """
    if precio_origen_usdt.is_zero() or precio_destino_usdt.is_zero():
        return False, "No se pudo obtener una cotizaci√≥n v√°lida para el par."

    cantidad_origen_bruta = Decimal("0")
    cantidad_destino_bruta = Decimal("0")
    valor_usd = Decimal("0")
    
    if accion == "comprar":
        if modo_ingreso == "monto":
            cantidad_destino_bruta = monto_form
            valor_usd = cantidad_destino_bruta * precio_destino_usdt
            cantidad_origen_bruta = valor_usd / precio_origen_usdt
        elif modo_ingreso == "total":
            cantidad_origen_bruta = monto_form
            valor_usd = cantidad_origen_bruta * precio_origen_usdt
            cantidad_destino_bruta = valor_usd / precio_destino_usdt
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no v√°lido para una compra."
    
    elif accion == "vender":
        if modo_ingreso == "monto":
            cantidad_origen_bruta = monto_form
            valor_usd = cantidad_origen_bruta * precio_origen_usdt
            cantidad_destino_bruta = valor_usd / precio_destino_usdt
        elif modo_ingreso == "total":
            cantidad_destino_bruta = monto_form
            valor_usd = cantidad_destino_bruta * precio_destino_usdt
            cantidad_origen_bruta = valor_usd / precio_origen_usdt
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no v√°lido para una venta."
    
    else:
        return False, f"Acci√≥n de trading desconocida: '{accion}'."

    return True, {
        "cantidad_origen_bruta": cantidad_origen_bruta,
        "cantidad_destino_bruta": cantidad_destino_bruta,
        "valor_usd": valor_usd
    }
    
def _ejecutar_orden_mercado(moneda_origen: str, moneda_destino: str, monto_form: Decimal, modo_ingreso: str, accion: str) -> Tuple[bool, Dict[str, Any] | str]:
    """Orquesta la ejecuci√≥n de una orden a precio de mercado."""
    precio_origen_usdt = obtener_precio(moneda_origen)
    precio_destino_usdt = obtener_precio(moneda_destino)
    if not all([precio_origen_usdt, precio_destino_usdt]):
        return False, "‚ùå No se pudo obtener la cotizaci√≥n para realizar el swap."

    exito_calculo, detalles_brutos = _calcular_detalles_intercambio(accion, modo_ingreso, monto_form, precio_origen_usdt, precio_destino_usdt)
    if not exito_calculo:
        return False, f"‚ùå {detalles_brutos}"

    cantidad_origen_bruta = detalles_brutos["cantidad_origen_bruta"]
    billetera = cargar_billetera()
    exito_validacion, mensaje_error = _validar_saldo_disponible(billetera, moneda_origen, cantidad_origen_bruta)
    if not exito_validacion: 
        return False, mensaje_error

    tipo_op_historial = "Compra" if accion == "comprar" else "Venta"
    exito_ejecucion, detalles_ejecucion = ejecutar_transaccion(
        billetera=billetera,
        moneda_origen=moneda_origen,
        cantidad_origen_bruta=cantidad_origen_bruta,
        moneda_destino=moneda_destino,
        tipo_operacion_historial=tipo_op_historial,
        es_orden_pendiente=False
    )

    if not exito_ejecucion:
        return False, detalles_ejecucion.get("error", "Error desconocido durante la ejecuci√≥n.")

    guardar_billetera(billetera)

    resultado_operacion = {
        "titulo": "Operaci√≥n de Mercado Exitosa",
        "tipo": "mercado",
        "detalles": {
            "recibiste": {"cantidad": formato_cantidad_cripto(detalles_ejecucion["cantidad_destino_final"]), "ticker": moneda_destino},
            "pagaste": {"cantidad": formato_cantidad_cripto(cantidad_origen_bruta), "ticker": moneda_origen},
            "comision": {"cantidad": formato_cantidad_cripto(detalles_ejecucion["cantidad_comision"]), "ticker": moneda_origen}
        }
    }
    return True, resultado_operacion

def _crear_orden_pendiente(moneda_origen: str, moneda_destino: str, monto_form: Decimal, modo_ingreso: str, precio_disparo: Decimal, tipo_orden: str, accion: str, precio_limite: Decimal | None) -> Tuple[bool, Dict[str, Any] | str]:
    """Crea y guarda una orden pendiente (L√≠mite o Stop-Limit)."""
    billetera = cargar_billetera()
    
    if precio_disparo.is_zero():
        return False, "‚ùå El precio de disparo no puede ser cero."

    if accion == 'comprar':
        moneda_a_reservar = moneda_origen
        if modo_ingreso == 'monto':
            cantidad_cripto_principal = monto_form
            cantidad_a_reservar = cantidad_cripto_principal * precio_disparo
        elif modo_ingreso == 'total':
            cantidad_a_reservar = monto_form
            cantidad_cripto_principal = cantidad_a_reservar / precio_disparo
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no v√°lido para una compra l√≠mite."

    elif accion == 'vender':
        moneda_a_reservar = moneda_origen
        if modo_ingreso == 'monto':
            cantidad_cripto_principal = monto_form
            cantidad_a_reservar = cantidad_cripto_principal
        elif modo_ingreso == 'total':
            precio_destino_usdt = obtener_precio(moneda_destino)
            if not precio_destino_usdt or precio_destino_usdt.is_zero():
                return False, f"‚ùå No se pudo obtener la cotizaci√≥n actual de {moneda_destino} para calcular la reserva."
            valor_usd_objetivo = monto_form * precio_destino_usdt
            cantidad_cripto_principal = valor_usd_objetivo / precio_disparo
            cantidad_a_reservar = cantidad_cripto_principal
        else:
            return False, f"Modo de ingreso '{modo_ingreso}' no v√°lido para una venta l√≠mite."
    else:
        return False, f"Acci√≥n desconocida: {accion}"

    exito_validacion, mensaje_error = _validar_saldo_disponible(billetera, moneda_a_reservar, cantidad_a_reservar)
    if not exito_validacion: 
        return False, mensaje_error

    billetera[moneda_a_reservar]["saldos"]["disponible"] -= cantidad_a_reservar
    billetera[moneda_a_reservar]["saldos"]["reservado"] += cantidad_a_reservar
    guardar_billetera(billetera)

    nueva_orden = {
        "id_orden": str(uuid.uuid4()),
        "timestamp_creacion": datetime.now().isoformat(),
        "tipo_orden": tipo_orden,
        "accion": accion,
        "par": f"{moneda_origen}/{moneda_destino}", # Correcto: BASE/QUOTE
        "moneda_origen": moneda_origen,
        "moneda_destino": moneda_destino,
        "cantidad_cripto_principal": str(cuantizar_cripto(cantidad_cripto_principal)),
        "precio_disparo": str(cuantizar_usd(precio_disparo)),
        "precio_limite": str(cuantizar_usd(precio_limite)) if precio_limite else None, # ### NUEVO ###
        "cantidad_reservada": str(cuantizar_cripto(cantidad_a_reservar)),
        "moneda_reservada": moneda_a_reservar,
        "estado": "pendiente"
    }
    agregar_orden_pendiente(nueva_orden)
    
    accion_texto = "Compra" if accion == 'comprar' else "Venta"
    ticker_mostrado = moneda_destino if accion == 'comprar' else moneda_origen
    
    resultado_operacion = {
        "titulo": f"Orden {tipo_orden.replace('-', ' ').title()} Creada",
        "tipo": tipo_orden,
        "detalles": {
            "accion": f"{accion_texto} de {formato_cantidad_cripto(cantidad_cripto_principal)} {ticker_mostrado}",
            "precio_disparo": formato_cantidad_usd(precio_disparo)
        }
    }
    return True, resultado_operacion

def procesar_operacion_trading(formulario: dict) -> Tuple[bool, Dict[str, Any] | str]:
    """Punto de entrada principal para procesar una operaci√≥n desde el formulario."""
    try:
        ticker_principal = formulario["ticker"].upper()
        accion = formulario["accion"]
        monto_form = a_decimal(formulario["monto"])
        modo_ingreso = formulario.get("modo-ingreso", "monto")
        tipo_orden = formulario.get("tipo-orden", "market").lower()
    except (KeyError, ValueError) as e:
        return False, f"‚ùå Error en los datos del formulario: {e}"

    if monto_form <= a_decimal(0): return False, "‚ùå El monto debe ser un n√∫mero positivo."

    moneda_origen, moneda_destino = (formulario.get("moneda-pago", "USDT").upper(), ticker_principal) if accion == "comprar" else (ticker_principal, formulario.get("moneda-recibir", "USDT").upper())
    if moneda_origen == moneda_destino: return False, "‚ùå La moneda de origen y destino no pueden ser la misma."

    if tipo_orden == "market":
        return _ejecutar_orden_mercado(moneda_origen, moneda_destino, monto_form, modo_ingreso, accion)
    
    elif tipo_orden in ["limit", "stop-limit"]:
        try:
            precio_disparo = a_decimal(formulario.get("precio_disparo"))
            if precio_disparo <= a_decimal(0): 
                return False, "‚ùå Se requiere un precio de disparo v√°lido y positivo."
            
            precio_limite = None
            if tipo_orden == 'stop-limit':
                precio_limite = a_decimal(formulario.get("precio_limite"))
                if precio_limite <= a_decimal(0):
                    return False, "‚ùå Se requiere un precio l√≠mite v√°lido y positivo para una orden Stop-Limit."

        except (KeyError, ValueError, TypeError):
            return False, "‚ùå Precio de disparo o l√≠mite inv√°lido o faltante."
        
        return _crear_orden_pendiente(moneda_origen, moneda_destino, monto_form, modo_ingreso, precio_disparo, tipo_orden, accion, precio_limite)
    
    return False, f"‚ùå Tipo de orden desconocido: '{tipo_orden}'."

==================================================
=== ARCHIVO: ./backend/utils/formatters.py ===
==================================================

"""
Utilidades de formateo para la presentaci√≥n de datos no num√©ricos.

Este m√≥dulo proporciona un conjunto de funciones reutilizables para dar formato a
diversos tipos de datos como fechas y otros indicadores de UI.
La l√≥gica de formateo num√©rico se ha movido a `utils.number_utils`.
"""

from datetime import datetime
from decimal import Decimal
from typing import Union


def get_performance_indicator(value: Union[str, Decimal]) -> dict:
    """
    Analiza un valor de rendimiento y devuelve un diccionario con la clase CSS y
    el s√≠mbolo de flecha correspondiente.

    Args:
        value (Union[str, Decimal]): El valor de rendimiento.

    Returns:
        dict: Un diccionario con las claves 'className' y 'arrow'.
    """
    try:
        valor_decimal = Decimal(str(value))
        if valor_decimal >= 0:
            return {"className": "positivo", "arrow": "‚ñ≤"}
        return {"className": "negativo", "arrow": "‚ñº"}
    except (ValueError, TypeError, InvalidOperation):
        return {"className": "", "arrow": ""}


def format_datetime(timestamp: Union[int, float, str]) -> str:
    """
    Formatea un timestamp o un string ISO a una fecha y hora local.

    Maneja tanto timestamps num√©ricos (segundos desde la √©poca) como strings
    de fecha en formato ISO 8601.

    Args:
        timestamp: El timestamp o string a formatear.

    Returns:
        La fecha y hora formateada. Ej: "21/06/2024 15:45:12".
    """
    if not timestamp:
        return "--:--"
    
    try:
        if isinstance(timestamp, (int, float)):
            dt_object = datetime.fromtimestamp(timestamp)
        elif isinstance(timestamp, str):
            dt_object = datetime.fromisoformat(timestamp)
        else:
            return "--:--"
            
        return dt_object.strftime("%d/%m/%Y %H:%M:%S")
    except (ValueError, TypeError):
        return "--:--"

==================================================
=== ARCHIVO: ./backend/utils/utilidades_numericas.py ===
==================================================

"""
M√≥dulo de Utilidades Num√©ricas.

Este m√≥dulo centraliza todas las operaciones relacionadas con la manipulaci√≥n
de n√∫meros en la aplicaci√≥n, especialmente para garantizar la consistencia
y precisi√≥n al trabajar con la librer√≠a `Decimal`.

Funciones:
- Conversi√≥n segura a `Decimal`.
- Cuantizaci√≥n a precisiones est√°ndar (cripto, USD).
- Formateo para presentaci√≥n en el frontend.
"""

from decimal import Decimal, InvalidOperation

from config import PRECISION_CRIPTOMONEDA, PRECISION_USD


def a_decimal(valor) -> Decimal:
    """
    Convierte de forma segura un valor a un objeto Decimal.

    Maneja diferentes tipos de entrada (int, float, str, None) y valores
    inv√°lidos, devolviendo siempre Decimal('0') en caso de error o entrada nula.

    Args:
        valor: El valor a convertir.

    Returns:
        Un objeto Decimal.
    """
    if valor is None:
        return Decimal("0")
    try:
        # Convertir a string primero es la forma m√°s segura de crear un Decimal,
        # especialmente desde un float, para evitar imprecisiones binarias.
        return Decimal(str(valor))
    except (InvalidOperation, TypeError, ValueError):
        return Decimal("0")

def cuantizar_cripto(valor: Decimal) -> Decimal:
    """
    Cuantiza un valor Decimal a la precisi√≥n est√°ndar para criptomonedas.

    Args:
        valor: El objeto Decimal a cuantizar.

    Returns:
        El valor Decimal cuantizado a 8 decimales.
    """
    return valor.quantize(PRECISION_CRIPTOMONEDA)

def cuantizar_usd(valor: Decimal) -> Decimal:
    """
    Cuantiza un valor Decimal a la precisi√≥n est√°ndar para USD.

    Args:
        valor: El objeto Decimal a cuantizar.

    Returns:
        El valor Decimal cuantizado a 2 o 4 decimales, seg√∫n config.
    """
    return valor.quantize(PRECISION_USD)


# --- Funciones de Formateo para Presentaci√≥n ---

def formato_cantidad_cripto(valor: Decimal) -> str:
    """
    Formatea una cantidad de criptomoneda como string con 8 decimales.

    Args:
        valor (Decimal): La cantidad a formatear.

    Returns:
        La cantidad formateada como string. Ej: "0.12345678".
    """
    return f"{cuantizar_cripto(valor):.8f}"

def formato_cantidad_usd(valor: Decimal, simbolo: str = "$") -> str:
    """
    Formatea un valor monetario en USD con 2 decimales y separadores de miles.

    Args:
        valor (Decimal): El valor a formatear.
        simbolo (str, optional): S√≠mbolo de la moneda. Por defecto es "$".

    Returns:
        El valor formateado. Ej: "$1,234.56".
    """
    # La cantidad de decimales en la f-string debe coincidir con la precisi√≥n en config.py
    # Decimal('0.0001'), usa .4f.
    decimales = abs(PRECISION_USD.as_tuple().exponent)
    return f"{simbolo}{cuantizar_usd(valor):,.{decimales}f}"

def formato_numero_grande(valor: Decimal, simbolo: str = "$") -> str:
    """
    Formatea n√∫meros grandes con abreviaturas (M, B, T).

    Args:
        valor (Decimal): El n√∫mero a formatear.
        simbolo (str, optional): S√≠mbolo a prefijar. Por defecto es "$".

    Returns:
        El n√∫mero formateado como string. Ej: "$1.25M", "$2.5B".
    """
    numero = a_decimal(valor)

    if numero >= 1_000_000_000_000:
        return f"{simbolo}{(numero / Decimal('1e12')).quantize(Decimal('0.01'))}T"
    if numero >= 1_000_000_000:
        return f"{simbolo}{(numero / Decimal('1e9')).quantize(Decimal('0.01'))}B"
    if numero >= 1_000_000:
        return f"{simbolo}{(numero / Decimal('1e6')).quantize(Decimal('0.01'))}M"
    return f"{simbolo}{numero:,.0f}"

def formato_porcentaje(valor: Decimal) -> str:
    """
    Formatea un n√∫mero como un porcentaje con dos decimales.

    Args:
        valor (Decimal): El n√∫mero a formatear.

    Returns:
        El n√∫mero como string de porcentaje. Ej: "25.45%".
    """
    return f"{a_decimal(valor):.2f}%"

==================================================
=== ARCHIVO: ./config.py ===
==================================================

# config.py
### MODIFICADO ###

import os
from decimal import getcontext, ROUND_HALF_DOWN, Decimal
from dotenv import load_dotenv

# Cargar variables de entorno desde el archivo .env
load_dotenv()

# Base del proyecto y carpeta de datos
PROYECTO_DIR = os.path.dirname(os.path.abspath(__file__))
BASE_DATA_DIR = os.path.join(PROYECTO_DIR, "datos")
os.makedirs(BASE_DATA_DIR, exist_ok=True)

# Rutas de archivos JSON
COTIZACIONES_PATH = os.path.join(BASE_DATA_DIR, "cotizaciones.json")
BILLETERA_PATH = os.path.join(BASE_DATA_DIR, "billetera.json")
HISTORIAL_PATH = os.path.join(BASE_DATA_DIR, "historial.json")
VELAS_PATH = os.path.join(BASE_DATA_DIR, "velas.json")
COMISIONES_PATH = os.path.join(BASE_DATA_DIR, "comisiones.json")
ORDENES_PENDIENTES_PATH = os.path.join(BASE_DATA_DIR, "ordenes_pendientes.json")

# Configuraci√≥n inicial de los USDT con los cuales inicializa la app
BALANCE_INICIAL_USDT = "10000"

# Comisi√≥n por trade
TASA_COMISION = Decimal("0.005")  # 0.5% de comisi√≥n

# Clave secreta para Flask
FLASK_SECRET_KEY = os.getenv("FLASK_SECRET_KEY", "clave_por_defecto_insegura")

# URLs de APIs
COINGECKO_URL = "https://api.coingecko.com/api/v3/coins/markets"
BINANCE_URL = "https://api.binance.com/api/v3/klines"

# Par√°metros de scraping
CANTIDAD_CRIPTOMONEDAS = 100
CANTIDAD_VELAS = 250

# --- CONFIGURACI√ìN NUM√âRICA GLOBAL --- ### NUEVO ###
# Precisi√≥n para los c√°lculos intermedios de la librer√≠a Decimal
getcontext().prec = 28
getcontext().rounding = ROUND_HALF_DOWN

# Precisi√≥n est√°ndar para el almacenamiento y la visualizaci√≥n
# de cantidades de criptomonedas (8 decimales)
PRECISION_CRIPTOMONEDA = Decimal("0.00000001")

# Precisi√≥n de decimales 4 para valores en USD
PRECISION_USD = Decimal("0.0001")

# Umbrales para la l√≥gica de "polvo" (saldos peque√±os)
UMBRAL_POLVO_USD = Decimal("0.01") # Valor en USD por debajo del cual se considera polvo
UMBRAL_CASI_CERO = Decimal("0.00000001") # Cantidad por debajo de la cual se considera cero para ciertas validaciones

==================================================
=== ARCHIVO: ./documentacion.md ===
==================================================

¬°Excelente! Ahora que has completado la refactorizaci√≥n, es el momento perfecto para dar un paso atr√°s y consolidar el conocimiento sobre la nueva arquitectura. Has transformado tu proyecto en un sistema mucho m√°s robusto y profesional.

Bas√°ndome en el c√≥digo finalizado y en la estructura de tu `documentacion.md`, he preparado una explicaci√≥n actualizada y detallada de la arquitectura y las responsabilidades de cada componente.

---

### **Diagrama de Arquitectura Actualizado: "BlocX - Simulador de Exchange"**

Este diagrama refleja la nueva estructura, destacando la especializaci√≥n dentro del paquete de servicios de trading.

```
+-----------------------------------------------------------------------------------------------------------------------+
|                                                  NAVEGADOR DEL USUARIO                                                |
|      - Renderiza HTML/CSS, ejecuta JS.                                                                                |
|      - Env√≠a acciones del usuario (formularios, clics) al Backend.                                                    |
|      - Muestra notificaciones de SweetAlert2 construidas desde datos JSON.                                            |
+------------------------------------------+--------------------------------------------------+-------------------------+
                                           |                                                  |                         ^
 (1) Petici√≥n inicial (GET /trading)       | (16) Muestra UI actualizada                      | (3) Sirve HTML inicial  |
                                           |      con datos de la API                         |                         |
                                           v                                                  |                         |
+------------------------------------------+--------------------------------------------------+-------------------------+
|                                                      FRONTEND (Cliente)                                               |
|                                            (Se ejecuta completamente en el navegador)                                   |
|-----------------------------------------------------------------------------------------------------------------------|
| HTML: /templates/                                                                                                     |
|  - _flashes.html: Componente JS-HTML que parsea JSON y renderiza notificaciones.                                       |
|                                                                                                                       |
| JS: /static/js/                                                                                                       |
|                                                                                                                       |
|  (4) Inicia l√≥gica (pages/tradingPage.js)  (14) Recibe JSON, actualiza DOM     (18) Muestra Toast/Popup                  |
|            +                                     |                                     ^                               |
|            |     +-----------------------------+ v                                     |                               |
|            +---> |   pages/*.js                | --(15) Llama a componentes--->+---------------------------------+    |
|                  |   - Orquesta la p√°gina.     |                               |    components/*.js              |    |
|                  |   - Llama a servicios.      |                               |    (uiUpdater, chartRenderer)   |    |
|                  +------------+----------------+                               +------------------^--------------+    |
|                               | (5, 17) Solicita datos a API                                      |                  |
|                               v                                                                                     |
|                  +-----------------------------+  (13) Devuelve JSON          +------------------------------------+  |
|                  |  services/apiService.js     | <--------------------------+ |  services/appState.js              |  |
|                  |  - Centraliza llamadas      |                              |  - Gestiona el estado global (JS)  |  |
|                  |    fetch() al backend.      |                              |                                    |  |
|                  +-----------------------------+                              +------------------------------------+  |
|                               | (6) Petici√≥n HTTP (POST /trading/operar, POST /api/orden/cancelar/...)                 |
+-------------------------------v-------------------------------------------------------------------------------------+
                                | (A) Recibe POST /trading/operar                                                       (2) Sirve HTML
                                | (B) Recibe POST /api/orden/cancelar/...                                               (v√≠a render_template)
                                | (C) Recibe GET /api/actualizar
+-------------------------------v-------------------------------------------------------------------------------------+
|                                                       BACKEND (Servidor)                                            |
|                                                 (Aplicaci√≥n Flask - Python)                                         |
|---------------------------------------------------------------------------------------------------------------------|
| __init__.py -> app.py                                                                                               |
| - Inicia la app Flask y registra las rutas.                                                                         |
|                                                                                                                     |
| +-----------------------------------------------------------------------------------------------------------------+ |
| |                                            RUTAS (Capa de Vistas)                                               | |
| | /rutas/*.py (trading_vista.py, billetera_vista.py, api_externa.py)                                              | |
| | - Definen los endpoints (URL).                                                                                  | |
| | - (A, B, C) Delegan la l√≥gica a la capa de Servicios.                                                           | |
| | - Devuelven JSON (para /api/...) o HTML (para rutas base).                                                      | |
| +--------------------------------------------------------+--+-----------------------------------------------------+ |
|                                                          |  |  (C.1) Llama a motor                                  |
|                                     (A.1) Llama a procesador |  (B.1) Llama a gestor                                |
|                                                          v  v                                                      |
| +--------------------------------------------------------+--+-----------------------------------------------------+ |
| |                                     SERVICIOS (Capa de L√≥gica de Negocio)                                       | |
| | /servicios/*.py (estado_billetera.py, api_cotizaciones.py)                                                      | |
| |                                                                                                                 | |
| | +-------------------------------------------------------------------------------------------------------------+ | |
| | |                                            /servicios/trading/                                              | | |
| | | - procesador.py: El "Recepcionista". Valida y CREA √≥rdenes.                                                 | | |
| | | - motor.py: El "Vigilante". VERIFICA condiciones de √≥rdenes pendientes.                                     | | |
| | | - gestor.py: El "Administrador". GESTIONA √≥rdenes existentes (ej. cancelar).                               | | |
| | | - ejecutor.py: El "Brazo Ejecutor". EJECUTA la transacci√≥n at√≥mica (comisi√≥n, saldos, historial).          | | |
| | +---------------------------------------------------------+---------------------------------------------------+ | |
| |                                                           | (D) Llama a ejecutor para completar la transacci√≥n    |
| +-----------------------------------------------------------v-----------------------------------------------------+ |
|                                                             | (E) Pide/guarda datos crudos                          |
|                                                             v                                                       |
| +-----------------------------------------------------------+-----------------------------------------------------+ |
| |                              ACCESO A DATOS (Capa de Persistencia)                                              | |
| | /acceso_datos/*.py (datos_billetera.py, datos_ordenes.py, etc.)                                                 | |
| | - Leen y escriben en los archivos .json.                                                                        | |
| | - Abstraen el manejo de archivos.                                                                               | |
| +---------------------+-------------------------------------+-----------------------------------------------------+ |
|                       |                                     |                                                       |
|             (F) Lee/Escribe                                 | (G) Lee/Escribe                                       |
|                       v                                     v                                                       |
| +---------------------+---------+  +------------------------+-------+  +--------------------------+  +----------------+
| | billetera.json, historial.json|  | ordenes_pendientes.json        |  | cotizaciones.json        |  | comisiones.json|
| +-------------------------------+  +--------------------------------+  +--------------------------+  +----------------+
+---------------------------------------------------------------------------------------------------------------------+

```

### **Glosario de Componentes y Responsabilidades Actualizado**

Aqu√≠ desglosamos qu√© hace cada parte del sistema en su estado actual y refactorizado.

#### **1. Backend (`/backend`)**

Es el cerebro del sistema. Su √∫nica responsabilidad es gestionar la l√≥gica de negocio y exponer los datos a trav√©s de una API que habla en JSON. **No sabe ni le importa c√≥mo se ve la p√°gina web.**

*   **Rutas (`/rutas`)**: Son los **"Controladores de Tr√°fico"**.
    *   **Responsabilidad**: Definen las URLs (endpoints) que el frontend puede llamar. Reciben las peticiones HTTP, validan los par√°metros m√°s b√°sicos y delegan inmediatamente el trabajo a la capa de Servicios.
    *   **Ejemplo**: `trading_vista.py` recibe el `POST` del formulario de trading, pero no sabe qu√© es una orden de mercado; simplemente llama a `procesar_operacion_trading()` en el servicio correspondiente. Luego, toma la respuesta (un diccionario o un error) y la formatea como JSON o la pasa al sistema de `flash`.

*   **Acceso a Datos (`/acceso_datos`)**: Son los **"Bibliotecarios"**.
    *   **Responsabilidad**: Son los √∫nicos que saben leer y escribir en los archivos `.json`. A√≠slan al resto de la aplicaci√≥n del "c√≥mo" se guardan los datos. Si ma√±ana decidieras cambiar de archivos JSON a una base de datos en memoria, solo tendr√≠as que modificar esta capa.
    *   **Ejemplo**: `datos_billetera.py` tiene las funciones `cargar_billetera()` y `guardar_billetera()`. Nadie m√°s en la aplicaci√≥n toca `billetera.json` directamente.

*   **Servicios (`/servicios`)**: Es el **"N√∫cleo del Negocio"**. Aqu√≠ reside toda la inteligencia de la aplicaci√≥n.
    *   **Responsabilidad**: Orquestar la l√≥gica de negocio, realizar c√°lculos complejos, interactuar con APIs externas y preparar los datos para ser consumidos.
    *   **Ejemplo**: `estado_billetera.py` toma los datos crudos de la billetera y el historial (pedidos a `acceso_datos`), los cruza con los precios actuales y calcula el valor del portafolio, las ganancias/p√©rdidas, etc.
    *   **Subpaquete `servicios/trading/` (La L√≥gica de Trading Refactorizada)**: Este es el coraz√≥n de tu sistema y ahora tiene responsabilidades muy bien definidas:
        *   **`procesador.py` - El "Recepcionista"**: Es el punto de entrada para cualquier *intenci√≥n de trading* que provenga de un usuario. Su trabajo es validar los datos de un formulario y **CREAR** una orden (ya sea para ejecuci√≥n inmediata o para ponerla en espera).
        *   **`motor.py` - El "Vigilante del Mercado"**: Es un proceso *automatizado*. Su √∫nica misi√≥n es **VERIFICAR** peri√≥dicamente si alguna de las √≥rdenes pendientes cumple las condiciones del mercado para ser ejecutada. No ejecuta nada por s√≠ mismo; si una orden se debe disparar, le pasa la posta al `ejecutor`.
        *   **`gestor.py` - El "Administrador de √ìrdenes"**: Se encarga de **GESTIONAR** las √≥rdenes que ya existen pero que no est√°n siendo ejecutadas. Su principal funci√≥n hoy es `cancelar_orden_pendiente`.
        *   **`ejecutor.py` - El "Brazo Ejecutor" o "Notario"**: Es la pieza m√°s cr√≠tica y centralizada. Contiene la funci√≥n `ejecutar_transaccion()`, que realiza una **transacci√≥n at√≥mica**. Su √∫nica responsabilidad es tomar los detalles de una operaci√≥n y **EJECUTARLA**: calcular la comisi√≥n, modificar los saldos, y registrarla en el historial. Es llamado tanto por el `procesador` (para √≥rdenes de mercado) como por el `motor` (para √≥rdenes pendientes).

#### **2. Frontend (`/frontend`)**

Es la cara visible de la aplicaci√≥n. Es un cliente completamente din√°mico que se ejecuta en el navegador.

*   **Templates (`/templates`)**: Son los **"Esqueletos HTML"**.
    *   **Responsabilidad**: Proveer la estructura HTML inicial de cada p√°gina. Son deliberadamente simples.
    *   **Ejemplo**: `trading.html` contiene los `divs` y `table` vac√≠os que actuar√°n como contenedores. `_flashes.html` es ahora un componente "inteligente" que ya no contiene HTML, sino un script que sabe c√≥mo construir el HTML de la notificaci√≥n a partir de los datos JSON que recibe.

*   **JS - Services (`/js/services`)**: Son los **"M√≥dulos de Soporte"** del frontend.
    *   **Responsabilidad**: Proporcionar funcionalidades reutilizables para el resto del c√≥digo JavaScript.
    *   **`apiService.js`**: El "Embajador". Centraliza todas las llamadas `fetch` a la API del backend.
    *   **`appState.js`**: El "Estado Global del Cliente". Guarda en memoria (del navegador) los datos que vienen de la API (como la lista de monedas o el estado de la billetera) para que otros componentes puedan acceder a ellos sin tener que pedirlos de nuevo.

*   **JS - Components (`/js/components`)**: Son los **"Especialistas de la UI"**.
    *   **Responsabilidad**: Cada m√≥dulo se encarga de una parte muy espec√≠fica de la interfaz de usuario.
    *   **Ejemplo**: `chartRenderer.js` solo sabe de gr√°ficos. `uiUpdater.js` solo sabe c√≥mo cambiar el texto de las etiquetas o el color de los botones.

*   **JS - Pages (`/js/pages`)**: Son los **"Directores de Orquesta"** de cada p√°gina.
    *   **Responsabilidad**: Es el punto de entrada para la l√≥gica de una p√°gina espec√≠fica. Cuando se carga `trading.html`, `tradingPage.js` se ejecuta y comienza a orquestar todo: llama a `apiService` para traer los datos, los guarda en `appState` y luego usa los `components` para llenar la p√°gina con esa informaci√≥n.

#### **3. Persistencia (`/datos/*.json`)**

Son la **"Base de Datos"** de tu proyecto.
*   **Responsabilidad**: Almacenar el estado de la aplicaci√≥n (la billetera, las √≥rdenes, el historial) de forma que los datos persistan incluso si el servidor se reinicia. Son la "√∫nica fuente de verdad" del sistema.
*   



¬°Excelente pregunta! Seguir el flujo de una operaci√≥n de principio a fin es la mejor manera de entender c√≥mo todas las piezas del sistema encajan. Aqu√≠ tienes el recorrido detallado, paso a paso, sin asumir nada, desde que abres el navegador hasta que la compra se concreta.

### **Escenario: Comprar $100 de BTC a Precio de Mercado**

---

#### **Fase 1: Carga Inicial de la P√°gina de Trading**

1.  **Paso 1: Abrir el Navegador**
    *   Escribes `http://127.0.0.1:5000/` en tu navegador y presionas Enter. Por defecto, Flask te redirigir√° (o la ruta `/` ya apunta) a la p√°gina de cotizaciones (`index.html`). Haces clic en el enlace "Trading" en la barra de navegaci√≥n. La URL cambia a `http://127.0.0.1:5000/trading`.

2.  **Paso 2: Petici√≥n HTTP al Backend (GET)**
    *   Tu navegador env√≠a una petici√≥n `GET` al servidor Flask, solicitando el recurso en la ruta `/trading`.

3.  **Paso 3: El Backend Responde (Capa de Rutas)**
    *   Flask recibe la petici√≥n. El archivo `backend/rutas/trading_vista.py` tiene una funci√≥n `mostrar_trading_page()` asociada a la ruta `/trading`.
    *   Esta funci√≥n ejecuta `render_template("trading.html")`. Flask toma este archivo de plantilla, lo procesa (incluyendo el `_flashes.html`, que en este punto no tiene mensajes) y lo devuelve al navegador como una respuesta HTML.

4.  **Paso 4: El Frontend Cobra Vida (HTML y JS)**
    *   El navegador recibe el archivo HTML. Es un "esqueleto": contiene la estructura, los `divs` para el gr√°fico, el formulario y las tablas, pero est√°n casi todos vac√≠os o con mensajes de "Cargando...".
    *   El navegador parsea el HTML y, al final, encuentra la l√≠nea `<script type="module" src=".../tradingPage.js"></script>`. Inmediatamente, descarga y ejecuta este archivo JavaScript.

5.  **Paso 5: Orquestaci√≥n del Frontend (`tradingPage.js`)**
    *   Se ejecuta la funci√≥n `initialize()` dentro de `tradingPage.js`.
    *   Esta funci√≥n es el "director de orquesta". Sabe que necesita muchos datos para llenar la p√°gina, as√≠ que usa `Promise.all` para hacer varias peticiones a la API del backend de forma concurrente, a trav√©s de las funciones en `apiService.js`:
        *   `fetchCotizaciones()` -> `GET /api/cotizaciones`
        *   `fetchEstadoBilletera()` -> `GET /api/billetera/estado-completo`
        *   `fetchHistorial()` -> `GET /api/historial`
        *   `fetchOrdenesAbiertas()` -> `GET /api/ordenes-abiertas`
        *   `fetchVelas('BTC', '1d')` -> `GET /api/velas/BTC/1d` (asumiendo BTC como default)

6.  **Paso 6: El Backend Sirve los Datos (Servicios y Acceso a Datos)**
    *   Para cada una de esas peticiones GET, el backend realiza un ciclo:
        *   La **Ruta** (ej. `api_externa.py`) recibe la petici√≥n.
        *   Llama al **Servicio** correspondiente (ej. `presentacion_datos.py` o `estado_billetera.py`).
        *   El **Servicio** pide los datos crudos a la capa de **Acceso a Datos** (ej. `datos_cotizaciones.py` lee `cotizaciones.json`).
        *   El **Servicio** procesa, calcula y formatea los datos.
        *   La **Ruta** toma los datos procesados y los devuelve como una respuesta JSON.

7.  **Paso 7: El Frontend Renderiza la P√°gina**
    *   De vuelta en `tradingPage.js`, las promesas de `Promise.all` se resuelven. El script ahora tiene todos los datos que necesita.
    *   Guarda estos datos en el estado global del cliente (`AppState.js`).
    *   Llama a los componentes "especialistas":
        *   `UIUpdater.renderHistorial()` para construir la tabla de historial.
        *   `initializeChart()` para dibujar el gr√°fico de velas.
        *   `actualizarFormularioUI()` para rellenar los selectores de criptomonedas y mostrar tu saldo inicial de USDT.
    *   **Resultado visual**: La p√°gina est√° completamente cargada. Ves el gr√°fico de BTC, el formulario de trading y tus saldos.

---

#### **Fase 2: Interacci√≥n del Usuario y Env√≠o del Formulario**

8.  **Paso 8: Configurar la Operaci√≥n**
    *   En el formulario de trading, seleccionas "BTC" (si no estaba ya por defecto).
    *   El modo "Comprar" est√° activado por defecto.
    *   El tipo de orden "Mercado" est√° activado por defecto.
    *   Seleccionas el modo de ingreso "Total (USDT)". El script `tradingPage.js` detecta este cambio (`radioModoIngreso.on('change', ...)` ) y, a trav√©s de `UIUpdater.js`, actualiza la etiqueta del campo de monto a "Total (USDT)".
    *   En el campo de monto, escribes `100`.

9.  **Paso 9: Confirmar la Compra**
    *   Haces clic en el bot√≥n "COMPRAR".
    *   Esto dispara el evento `submit` del formulario `<form id="formulario-trading" ...>`.

10. **Paso 10: Petici√≥n HTTP al Backend (POST)**
    *   El navegador empaqueta todos los datos del formulario (ticker: 'BTC', accion: 'comprar', tipo-orden: 'market', modo-ingreso: 'total', monto: '100', moneda-pago: 'USDT') y env√≠a una petici√≥n `POST` a la URL especificada en el `action` del formulario: `/trading/operar`.

---

#### **Fase 3: Procesamiento de la Operaci√≥n en el Backend**

11. **Paso 11: La Ruta Recibe la Petici√≥n**
    *   Flask recibe el `POST`. La funci√≥n `procesar_trading_form()` en `backend/rutas/trading_vista.py` se ejecuta.

12. **Paso 12: Delegaci√≥n al Servicio Procesador**
    *   La ruta no sabe c√≥mo procesar un trade. Delega inmediatamente todo el trabajo llamando a `procesar_operacion_trading(request.form)` en `backend/servicios/trading/procesador.py`.

13. **Paso 13: El Procesador Analiza la Orden**
    *   `procesar_operacion_trading` recibe el diccionario del formulario.
    *   Valida los datos: el monto es positivo, las monedas de origen (USDT) y destino (BTC) no son la misma.
    *   Detecta que `tipo_orden` es "market", por lo que llama a su funci√≥n auxiliar `_ejecutar_orden_mercado(...)`.

14. **Paso 14: Orquestaci√≥n de la Orden de Mercado**
    *   `_ejecutar_orden_mercado` comienza su trabajo:
        a.  Llama a `obtener_precio('USDT')` y `obtener_precio('BTC')` desde `datos_cotizaciones.py`. Supongamos que BTC est√° a $50,000.
        b.  Llama a su funci√≥n de c√°lculo pura: `_calcular_detalles_intercambio('comprar', 'total', 100, 1, 50000)`. Esta funci√≥n devuelve `{ "cantidad_origen_bruta": 100, "cantidad_destino_bruta": 0.002, ... }`.
        c.  Carga tu billetera actual usando `cargar_billetera()`.
        d.  Valida si tienes saldo suficiente con `_validar_saldo_disponible(billetera, 'USDT', 100)`. Como tienes $10,000 iniciales, la validaci√≥n es exitosa.

15. **Paso 15: La Ejecuci√≥n At√≥mica**
    *   Ahora, `_ejecutar_orden_mercado` tiene todo lo que necesita. Llama a la funci√≥n centralizada `ejecutar_transaccion()` del m√≥dulo `ejecutor.py`, pas√°ndole todos los detalles.
    *   Dentro de `ejecutar_transaccion()`:
        a.  **C√°lculo de Comisi√≥n**: `cantidad_comision = 100 (USDT) * 0.005 = 0.5 USDT`.
        b.  **C√°lculo Neto**: La cantidad neta de origen que se usar√° para el intercambio es `100 - 0.5 = 99.5 USDT`.
        c.  **C√°lculo Final**: La cantidad final de BTC que recibir√°s es `99.5 / 50000 = 0.00199 BTC`.
        d.  **Modificaci√≥n de Billetera (en memoria)**:
            *   Resta 100 del saldo `disponible` de USDT.
            *   Suma 0.00199 al saldo `disponible` de BTC.
        e.  **Registro de Comisi√≥n**: Llama a `registrar_comision()` en `datos_comisiones.py`, que abre `comisiones.json` y a√±ade la nueva l√≠nea.
        f.  **Registro de Historial**: Llama a `guardar_en_historial()` en `datos_historial.py`, que abre `historial.json` y a√±ade el registro de la compra.
        g.  Devuelve un diccionario con los detalles de la ejecuci√≥n a `_ejecutar_orden_mercado`.

16. **Paso 16: Finalizaci√≥n y Respuesta**
    *   `_ejecutar_orden_mercado` recibe la confirmaci√≥n de √©xito del ejecutor.
    *   Llama a `guardar_billetera(billetera)`, que abre `billetera.json` y **sobrescribe el archivo completo** con los nuevos saldos.
    *   Construye el diccionario de respuesta final para el frontend: `{"titulo": "Operaci√≥n de Mercado Exitosa", "tipo": "mercado", "detalles": {...}}`.
    *   Este diccionario se devuelve a `procesar_operacion_trading`.
    *   `procesar_operacion_trading` lo devuelve a la ruta `procesar_trading_form`.

---

#### **Fase 4: Redirecci√≥n y Notificaci√≥n al Usuario**

17. **Paso 17: El Sistema de "Flashes" de Flask**
    *   La ruta `procesar_trading_form` tiene la tupla `(True, diccionario_resultado)`.
    *   Como fue exitosa, convierte el diccionario a un string JSON usando `json.dumps()`.
    *   Llama a `flash(json_string, "success")`. Flask guarda este mensaje en una cookie de sesi√≥n temporal.
    *   Finalmente, ejecuta `return redirect(url_for('trading.mostrar_trading_page', ticker='BTC'))`.

18. **Paso 18: Nueva Petici√≥n y Renderizado**
    *   El navegador recibe la respuesta de redirecci√≥n (c√≥digo 302). Inmediatamente hace una **nueva petici√≥n `GET`** a `http://127.0.0.1:5000/trading?ticker=BTC`.
    *   El ciclo de carga de la p√°gina (Pasos 3 a 7) se repite. La p√°gina se carga de nuevo desde cero, pero esta vez, cuando `render_template` procesa `_flashes.html`, detecta que hay un mensaje en la sesi√≥n.

19. **Paso 19: Notificaci√≥n en el Frontend**
    *   El script dentro de `_flashes.html` se ejecuta.
    *   Parsea el string JSON del mensaje flash de vuelta a un objeto JavaScript.
    *   Llama a la funci√≥n `buildFlashMessageHTML()` para construir el HTML de la notificaci√≥n.
    *   Usa `Toast.fire()` de SweetAlert2 para mostrar una notificaci√≥n emergente en la esquina superior derecha con el resumen de la operaci√≥n: "Recibiste: 0.00199000 BTC", "Pagaste: 100.00000000 USDT", etc.

20. **Paso 20: Visualizaci√≥n del Estado Actualizado**
    *   Como la p√°gina se recarg√≥, las llamadas a la API en el `initialize()` de `tradingPage.js` traen los datos actualizados.
    *   La llamada a `fetchEstadoBilletera()` ahora devolver√° un estado de billetera que incluye BTC.
    *   La llamada a `fetchHistorial()` incluir√° la nueva transacci√≥n.
    *   El frontend renderiza las tablas con la informaci√≥n nueva. **Ya tienes oficialmente tus $100 (menos comisi√≥n) en BTC.**

¬°Y as√≠ concluye el ciclo completo de una operaci√≥n! Cada capa tiene una responsabilidad clara, y el flujo de datos entre el cliente y el servidor es predecible y robusto.

==================================================
=== ARCHIVO: ./frontend/static/css/styles_index.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #303030;
    color: #f0c000;
}

.logo-cripto {
    margin-right: 1.5rem;
    vertical-align: middle;
}

.nombre-cripto {
    padding-left: 0.75rem;
    font-weight: bold;
    font-size: 1.05rem;
}

.logo-cripto {
    margin-right: 10px;
    vertical-align: middle;
}

.ticker-cripto {
    color: #aaaaaa;
    font-size: 0.85rem;
    margin-left: 4px;
}

table thead th {
    font-size: 0.85rem;
    font-weight: 500;
    text-transform: uppercase;
}

td,
th {
    white-space: nowrap;
}

/* PRECIO */
table td:nth-child(3),
table th:nth-child(3) {
    min-width: 100px;
    font-weight: bold;
}
table td:nth-child(4),
table th:nth-child(4),
table td:nth-child(5),
table th:nth-child(5),
table td:nth-child(6),
table th:nth-child(6) {
    min-width: 80px; /* 1H, 24H, 7D */
}
table td:nth-child(8),
table th:nth-child(8),
table td:nth-child(9),
table th:nth-child(9) {
    min-width: 100px; /* VOLUME, SUPPLY */
}

/* Limita el ancho de la columna Name (columna 2) */
table td:nth-child(2),
table th:nth-child(2) {
    max-width: 220px; /* prob√° ajustar este valor */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.positivo {
    color: var(--color-verde);
    font-weight: 500;
}

.negativo {
    color: var(--color-rojo);
    font-weight: 500;
}

.flecha-verde,
.flecha-roja {
    font-size: 0.7em; /* m√°s peque√±o que el texto base */
    vertical-align: middle;
    margin-right: 4px;
}

.flecha-verde {
    color: var(--color-verde);
    margin-right: 4px;
}

.flecha-roja {
    color: var(--color-rojo);
    margin-right: 4px;
}


==================================================
=== ARCHIVO: ./frontend/static/css/styles_trading.css ===
==================================================

:root {
    --color-verde: rgb(31, 191, 113);
    --color-rojo: rgb(226, 33, 52);
    --color-azul-activo: #0d6efd; /* Azul de Bootstrap para botones activos */
    --color-fondo-base: #343a40; /* Un gris oscuro para fondos de input/select */
    --color-borde: #6c757d; /* Un gris m√°s claro para bordes */
    --color-texto: #f8f9fa; /* Texto casi blanco */
    --border-radius-suave: 0.375rem; /* El radio de borde por defecto de Bootstrap */
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #1e1e1e !important; /* Un fondo un poco m√°s oscuro que antes */
    color: #f0c000;
}

#chart {
    display: block;
    overflow: hidden;
    width: 100%;
    max-width: 100%;
    min-height: 500px;
}

/* --- ESTILOS UNIFICADOS PARA EL FORMULARIO --- */

/* Estilo base para todos los controles de formulario */
.form-control,
.form-select,
.select2-container--bootstrap-5 .select2-selection {
    background-color: var(--color-fondo-base) !important;
    color: var(--color-texto) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave) !important;
    box-shadow: none !important; /* Eliminar sombras por defecto */
}

/* Placeholder text color */
.form-control::placeholder {
    color: #999;
}

/* Estilo para los grupos de botones (Tipo de orden, Ingresar por, Timeframes) */
.btn-group .btn-outline-primary,
.btn-group .btn-outline-secondary {
    color: var(--color-texto);
    border-color: var(--color-borde);
}

/* Estilo para el bot√≥n ACTIVO en los grupos */
.btn-group .btn-check:checked + .btn-outline-primary,
.btn-group .btn.active {
    background-color: var(--color-azul-activo);
    border-color: var(--color-azul-activo);
    color: var(--color-texto);
}
.btn-group .timeframe-btn.active {
    background-color: var(--color-azul-activo) !important;
    border-color: var(--color-azul-activo) !important;
}

/* --- ESTILOS PERSONALIZADOS PARA SELECT2 --- */

/* Contenedor principal de Select2 */
.select2-container--bootstrap-5 .select2-selection {
    height: calc(1.5em + 0.75rem + 2px); /* Altura est√°ndar de Bootstrap */
    padding: 0.375rem 0.75rem;
    line-height: 1.5;
}

/* Flecha del dropdown de Select2 */
.select2-container--bootstrap-5 .select2-selection__arrow b {
    border-color: var(--color-texto) transparent transparent transparent !important;
}

/* Estilos para el Dropdown (la lista que se abre) */
.select2-dropdown {
    background-color: var(--color-fondo-base) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave) !important;
}

/* Campo de b√∫squeda dentro del dropdown */
.select2-search__field {
    background-color: #495057 !important;
    color: var(--color-texto) !important;
    border: 1px solid var(--color-borde) !important;
    border-radius: var(--border-radius-suave);
}

/* Opciones de la lista */
.select2-results__option {
    color: var(--color-texto) !important;
}

/* Opci√≥n seleccionada actualmente en la lista */
.select2-results__option--selected {
    background-color: #5a6268 !important;
}

/* Opci√≥n bajo el cursor del rat√≥n (hover) */
.select2-results__option--highlighted {
    background-color: var(--color-azul-activo) !important;
    color: var(--color-texto) !important;
}

/* --- L√ìGICA DE BOTONES DE COMPRA/VENTA (SIN CAMBIOS DE L√ìGICA, S√ìLO EST√âTICA) --- */
.boton-comprar.active {
    background-color: var(--color-verde) !important;
    border-color: var(--color-verde) !important;
}
.boton-vender.active {
    background-color: var(--color-rojo) !important;
    border-color: var(--color-rojo) !important;
}
.btn-outline-secondary {
    background-color: transparent;
    border-color: var(--color-borde);
}
.btn-outline-secondary:hover {
    background-color: var(--color-fondo-base);
}

/* --- OVERLAY DE ERROR (SIN CAMBIOS) --- */
.chart-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(30, 30, 30, 0.85);
    color: #f0c000;
    font-size: 1.2rem;
    font-weight: 500;
    text-align: center;
    padding: 20px;
    z-index: 10;
    border-radius: 8px;
    transition: opacity 0.3s ease-in-out;
}

.select2-container--bootstrap-5 .select2-selection--single .select2-selection__rendered,
.form-control::placeholder {
    color: var(--color-texto) !important;
}


.custom-toast-position {
    margin-top: 60px;
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/chartRenderer.js ===
==================================================

/**
 * @module chartRenderer
 * @description Gestiona la creaci√≥n, inicializaci√≥n y actualizaci√≥n del gr√°fico financiero
 * de velas utilizando la biblioteca Lightweight Charts‚Ñ¢.
 * Este m√≥dulo es responsable de todas las interacciones directas con la instancia del gr√°fico.
 */

// Variables globales para mantener las instancias del gr√°fico y sus series.
let chart;
let candleSeries;
let volumeSeries;

/**
 * @typedef {object} CandleData
 * @property {string} time - Marca de tiempo en formato 'YYYY-MM-DD'.
 * @property {number} open - Precio de apertura.
 * @property {number} high - Precio m√°ximo.
 * @property {number} low - Precio m√≠nimo.
 * @property {number} close - Precio de cierre.
 * @property {number} volume - Volumen de la operaci√≥n.
 */

/**
 * Crea e inicializa el gr√°fico de velas en la primera carga.
 * Configura la apariencia del gr√°fico, a√±ade las series de velas y volumen,
 * y establece los listeners de eventos para la interactividad.
 *
 * @param {CandleData[]} initialData - El conjunto de datos inicial de velas para mostrar.
 * @side-effects Manipula el DOM para crear el gr√°fico dentro del elemento '#chart'.
 *               Tambi√©n adjunta un ResizeObserver para manejar el redimensionamiento responsivo.
 */
export function initializeChart(initialData) {
    const chartContainer = document.getElementById('chart');
    if (!chartContainer) {
        console.warn("Elemento #chart no encontrado. No se puede renderizar el gr√°fico.");
        return;
    }
    if (!window.LightweightCharts) {
        console.error("La biblioteca LightweightCharts no est√° cargada.");
        return;
    }

    // Crea la instancia principal del gr√°fico con estilos personalizados.
    chart = window.LightweightCharts.createChart(chartContainer, {
        width: chartContainer.clientWidth,
        height: 500,
        layout: { textColor: '#ccc', background: { type: 'solid', color: '#1E1E1E' } },
        grid: { vertLines: { color: '#2B2B2B' }, horzLines: { color: '#2B2B2B' } },
        priceScale: { borderColor: '#485c7b' },
        timeScale: { borderColor: '#485c7b' },
    });

    // A√±ade la serie principal de velas para la acci√≥n del precio.
    candleSeries = chart.addCandlestickSeries({
        upColor: 'rgb(31, 191, 113)',
        downColor: 'rgb(226, 33, 52)',
        borderDownColor: 'rgb(226, 33, 52)',
        borderUpColor: 'rgb(31, 191, 113)',
        wickDownColor: '#838ca1',
        wickUpColor: '#838ca1',
    });

    // A√±ade una serie secundaria de histograma para el volumen de operaciones.
    volumeSeries = chart.addHistogramSeries({
        priceFormat: { type: 'volume' },
        priceScaleId: '', // Se adjunta a una escala de precios separada.
    });
    // Ajusta la escala de precios de la serie de volumen para darle m√°s espacio.
    volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });

    if (initialData && initialData.length > 0) {
        updateChartData(initialData);
    }

    // A√±ade un listener de eventos al checkbox para alternar la visibilidad del volumen.
    const volumeCheckbox = document.getElementById('toggleVolume');
    if (volumeCheckbox) {
        volumeCheckbox.addEventListener('change', (e) => {
            volumeSeries.applyOptions({ visible: e.target.checked });
        });
    }

    // Asegura que el gr√°fico se ajuste a su contenido y sea responsivo.
    chart.timeScale().fitContent();
    new ResizeObserver(() => chart.applyOptions({ width: chartContainer.clientWidth })).observe(chartContainer);
}

/**
 * Actualiza el gr√°fico con un nuevo conjunto de datos de velas.
 * Maneja tanto el caso en que hay datos disponibles como en el que no, mostrando
 * u ocultando un mensaje de error superpuesto seg√∫n corresponda.
 *
 * @param {CandleData[]} data - El nuevo array de datos de velas. Si el array est√° vac√≠o
 *        o es nulo, limpia el gr√°fico y muestra un mensaje de error.
 */
export function updateChartData(data) {
    if (!candleSeries || !volumeSeries) {
        console.warn("El gr√°fico no est√° inicializado. No se pueden actualizar los datos.");
        return;
    }

    const errorOverlay = document.getElementById('chart-error-overlay');

    if (data && data.length > 0) {
        // Oculta el mensaje de error si hay datos disponibles.
        errorOverlay.style.display = 'none';

        // Mapea los datos brutos al formato requerido por Lightweight Charts.
        const candleData = data.map(item => ({
            time: item.time,
            open: Number(item.open),
            high: Number(item.high),
            low: Number(item.low),
            close: Number(item.close)
        }));
        const volumeData = data.map(item => ({
            time: item.time,
            value: Number(item.volume),
            color: Number(item.close) > Number(item.open) ? 'rgba(31, 191, 113, 0.5)' : 'rgba(226, 33, 52, 0.5)'
        }));

        console.log(`üìä Actualizando gr√°fico con ${data.length} velas.`);
        candleSeries.setData(candleData);
        volumeSeries.setData(volumeData);
    } else {
        // Si no hay datos disponibles, limpia las series y muestra el overlay de error.
        console.log("üìä No hay datos de velas disponibles. Mostrando mensaje de error.");
        candleSeries.setData([]);
        volumeSeries.setData([]);
        errorOverlay.style.display = 'flex'; // Se usa 'flex' para que coincida con el centrado del CSS.
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/domElements.js ===
==================================================

/**
 * @module DOMElements
 * @description Centraliza las referencias a los elementos del DOM a los que se accede con frecuencia.
 * Este patr√≥n mejora el rendimiento al cachear los objetos jQuery, evitando consultas
 * redundantes al DOM y facilitando el mantenimiento del c√≥digo.
 */

/**
 * Un objeto que contiene referencias cacheadas de jQuery a los elementos del DOM
 * utilizados en la interfaz de trading.
 * @type {Object<string, JQuery>}
 */
export const DOMElements = {
    // Contenedor principal del formulario de trading
    form: $('#formulario-trading'),
    // Selector principal de criptomonedas (ej. BTC, ETH)
    selectorPrincipal: $('#cripto'),
    // Desplegable para seleccionar la moneda de pago (en una compra)
    selectorPagarCon: $('#moneda-pago'),
    // Desplegable para seleccionar la moneda a recibir (en una venta)
    selectorRecibirEn: $('#moneda-recibir'),
    // Bot√≥n de acci√≥n 'Comprar'
    botonComprar: $('.boton-comprar'),
    // Bot√≥n de acci√≥n 'Vender'
    botonVender: $('.boton-vender'),
    // Bot√≥n final 'Confirmar' para la transacci√≥n
    botonConfirmar: $('.boton-confirmar'),
    // Input oculto que almacena la acci√≥n actual ('comprar' o 'vender')
    inputAccion: $('#accion'),
    // Contenedor para el desplegable 'Pagar con'
    campoPagarCon: $('#campo-pagar-con'),
    // Contenedor para el desplegable 'Recibir en'
    campoRecibirEn: $('#campo-recibir-en'),
    // Span para mostrar el saldo disponible del usuario
    spanSaldoDisponible: $('#saldo-disponible'),
    // Botones de radio para cambiar entre modos de ingreso ('monto' vs 'total')
    radioModoIngreso: $('input[name="modo-ingreso"]'),
    // Etiqueta para el bot√≥n de radio 'Cantidad (Cripto)'
    labelModoMonto: $('#label-modo-monto'),
    // Etiqueta para el campo de entrada de monto
    labelMonto: $('label[for="monto"]'),
    // Campo de entrada principal para el monto
    inputMonto: $('#monto'),
    // Etiqueta para el bot√≥n de radio 'Cantidad (Cripto)'
    labelModoMonto: $('#label-modo-monto'),
    // Etiqueta para el bot√≥n de radio 'Total (USDT)'
    labelModoTotal: $('#label-modo-total'),
};


==================================================
=== ARCHIVO: ./frontend/static/js/components/formLogic.js ===
==================================================

// frontend/static/js/components/formLogic.js

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';
import { AppState } from '../services/appState.js';

export const FormLogic = {
    /**
     * Rellena un elemento <select> con una lista de opciones, SIN disparar eventos.
     */
    popularSelector(selector, lista, placeholderVacio = 'No hay opciones') {
        selector.empty();

        if (!lista || lista.length === 0) {
            selector.append(new Option(placeholderVacio, '')).prop('disabled', true);
            return;
        }

        selector.prop('disabled', false);
        lista.forEach(({ ticker, nombre }) => selector.append(new Option(`${nombre} (${ticker})`, ticker)));
    },

    /**
     * Orquesta la actualizaci√≥n de todos los selectores del formulario.
     */
    actualizarOpcionesDeSelectores() {
        const esCompra = UIState.esModoCompra();
        const tickerPrincipal = UIState.getTickerPrincipal();
        
        const allCryptos = AppState.getAllCryptos();
        const ownedCoins = AppState.getOwnedCoins();

        if (esCompra) {
            const opcionesPagarCon = ownedCoins.filter(c => c.ticker !== tickerPrincipal);
            FormLogic.popularSelector(DOMElements.selectorPagarCon, opcionesPagarCon, 'No tienes fondos');
            // Establecemos el valor por defecto para 'Pagar con' sin disparar el change todav√≠a
            DOMElements.selectorPagarCon.val('USDT');

        } else {
            const opcionesRecibirEn = allCryptos.filter(c => c.ticker !== tickerPrincipal);
            FormLogic.popularSelector(DOMElements.selectorRecibirEn, opcionesRecibirEn);
            // Establecemos el valor por defecto para 'Recibir en'
            DOMElements.selectorRecibirEn.val('USDT');
        }
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/tablaCotizacionesUI.js ===
==================================================

/**
 * @module tablaCotizacionesUI
 * @description Controla la renderizaci√≥n y actualizaci√≥n de la tabla de cotizaciones de criptomonedas.
 */

import { fetchCotizaciones } from '../services/apiService.js';
import { UIUpdater } from './uiUpdater.js';

const cuerpoTabla = document.getElementById('tabla-datos');

/**
 * @typedef {object} CotizacionPresentacion
 * @property {string} logo - URL del logo de la criptomoneda.
 * @property {string} nombre - Nombre de la criptomoneda.
 * @property {string} ticker - S√≠mbolo de la criptomoneda.
 * @property {string} precio_usd_formatted - Precio formateado en USD.
 * @property {string} '1h_formatted' - Variaci√≥n porcentual formateada (1h).
 * @property {string} '24h_formatted' - Variaci√≥n porcentual formateada (24h).
 * @property {string} '7d_formatted' - Variaci√≥n porcentual formateada (7d).
 * @property {object} perf_1h - Objeto con {className, arrow} para rendimiento 1h.
 * @property {object} perf_24h - Objeto con {className, arrow} para rendimiento 24h.
 * @property {object} perf_7d - Objeto con {className, arrow} para rendimiento 7d.
 * @property {string} market_cap_formatted - Capitalizaci√≥n de mercado formateada.
 * @property {string} volumen_24h_formatted - Volumen de 24h formateado.
 * @property {string} circulating_supply_formatted - Suministro circulante formateado.
 */

/**
 * Crea el HTML para una fila de la tabla de cotizaciones a partir de datos ya procesados.
 *
 * @private
 * @param {CotizacionPresentacion} cripto - El objeto de datos de la criptomoneda, ya formateado por el backend.
 * @param {number} index - El n√∫mero de fila (√≠ndice + 1).
 * @returns {string} Una cadena de texto con el HTML del `<tr>` para la criptomoneda.
 */
function createFilaCotizacionHTML(cripto, index) {
    return `
        <tr>
            <td class="text-start px-3">${index}</td>
            <td class="text-start px-3">
                <img src="${cripto.logo}" width="20" class="logo-cripto" alt="${cripto.ticker} logo">
                <span class="nombre-cripto">${cripto.nombre}</span>
                <span class="ticker-cripto">(${cripto.ticker})</span>
            </td>
            <td class="text-start px-3 fw-bold">${cripto.precio_usd_formatted}</td>
            
            <td class="text-end px-3">
                <span class="${cripto.perf_1h.className}">
                    <span class="flecha">${cripto.perf_1h.arrow}</span>
                    ${cripto['1h_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${cripto.perf_24h.className}">
                    <span class="flecha">${cripto.perf_24h.arrow}</span>
                    ${cripto['24h_formatted']}
                </span>
            </td>
            <td class="text-end px-3">
                <span class="${cripto.perf_7d.className}">
                    <span class="flecha">${cripto.perf_7d.arrow}</span>
                    ${cripto['7d_formatted']}
                </span>
            </td>
            
            <td class="text-end px-3">${cripto.market_cap_formatted}</td>
            <td class="text-end px-3">${cripto.volumen_24h_formatted}</td>
            <td class="text-end px-3">${cripto.circulating_supply_formatted}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de cotizaciones y renderiza la tabla en el DOM.
 * Si no hay cotizaciones, la tabla simplemente se mostrar√° vac√≠a.
 * @async
 * @side-effects Modifica el `innerHTML` del elemento '#tabla-datos'.
 *               Puede mostrar un mensaje de error si la carga de datos falla.
 */
export async function renderTabla() {
    if (!cuerpoTabla) return;
    try {
        const cotizaciones = (await fetchCotizaciones()) || [];
        cuerpoTabla.innerHTML = cotizaciones
            .map((cripto, index) => createFilaCotizacionHTML(cripto, index + 1))
            .join('');
    } catch (error) {
        console.error('‚ùå Error al renderizar la tabla de cotizaciones:', error);
        UIUpdater.mostrarMensajeError(
            'No se pudieron cargar las cotizaciones. La informaci√≥n puede estar desactualizada.'
        );
        cuerpoTabla.innerHTML =
            '<tr><td colspan="9" class="text-center text-danger py-4">Error al cargar las cotizaciones.</td></tr>';
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiState.js ===
==================================================

/**
 * @module uiState
 * @description Proporciona un objeto centralizado para consultar el estado actual de la interfaz de usuario.
 * Este m√≥dulo abstrae la l√≥gica de acceso a los valores de los elementos del DOM, facilitando
 * la obtenci√≥n de informaci√≥n sobre el estado de la UI sin interactuar directamente con `DOMElements`.
 */

import { DOMElements } from './domElements.js';

/**
 * @description Un objeto que agrupa funciones para obtener diferentes aspectos del estado de la UI.
 * Cada m√©todo consulta un elemento del DOM a trav√©s de `DOMElements` y devuelve su estado actual.
 * @exports UIState
 */
export const UIState = {
    /**
     * Comprueba si el modo de operaci√≥n actual es 'comprar'.
     * @returns {boolean} `true` si la acci√≥n seleccionada es 'comprar', de lo contrario `false`.
     */
    esModoCompra() {
        return DOMElements.inputAccion.val() === 'comprar';
    },

    /**
     * Obtiene el modo de ingreso seleccionado (ej. 'cantidad' o 'monto').
     * @returns {string} El valor del radio button seleccionado para el modo de ingreso.
     */
    getModoIngreso() {
        return DOMElements.radioModoIngreso.filter(':checked').val();
    },

    /**
     * Obtiene el ticker de la criptomoneda principal seleccionada.
     * @returns {string} El ticker de la criptomoneda en el selector principal.
     */
    getTickerPrincipal() {
        return DOMElements.selectorPrincipal.val();
    },

    /**
     * Obtiene el ticker de la moneda utilizada para pagar.
     * @returns {string} El ticker de la moneda en el selector 'pagar con'.
     */
    getTickerPago() {
        return DOMElements.selectorPagarCon.val();
    },

    /**
     * Obtiene el ticker de la moneda que se recibir√°.
     * @returns {string} El ticker de la moneda en el selector 'recibir en'.
     */
    getTickerRecibo() {
        return DOMElements.selectorRecibirEn.val();
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/components/uiUpdater.js ===
==================================================

/**
 * @module uiUpdater
 * @description Centraliza todas las funciones que actualizan din√°micamente la interfaz de usuario.
 * Este m√≥dulo es responsable de cambiar la apariencia y el contenido de los elementos del DOM
 * en respuesta a las acciones del usuario y los datos de la aplicaci√≥n.
 */

import { DOMElements } from './domElements.js';
import { UIState } from './uiState.js';
import { AppState } from '../services/appState.js';


export const UIUpdater = {
    actualizarBotones() {
        const esCompra = UIState.esModoCompra();
        DOMElements.botonConfirmar
            .text(esCompra ? 'COMPRAR' : 'VENDER')
            .toggleClass('btn-success', esCompra)
            .toggleClass('btn-danger', !esCompra);
        DOMElements.botonComprar
            .toggleClass('active btn-success', esCompra)
            .toggleClass('btn-outline-secondary', !esCompra);
        DOMElements.botonVender
            .toggleClass('active btn-danger', !esCompra)
            .toggleClass('btn-outline-secondary', esCompra);
    },

    actualizarVisibilidadCampos() {
        const esCompra = UIState.esModoCompra();
        DOMElements.campoPagarCon.toggle(esCompra);
        DOMElements.campoRecibirEn.toggle(!esCompra);
        DOMElements.selectorPagarCon.prop('disabled', !esCompra);
        DOMElements.selectorRecibirEn.prop('disabled', esCompra);
    },

    actualizarLabelMonto() {
        const esModoMonto = UIState.getModoIngreso() === 'monto';
        const esCompra = UIState.esModoCompra();
        let tickerRelevante = '';

        if (esCompra) {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerPago();
        } else {
            tickerRelevante = esModoMonto ? UIState.getTickerPrincipal() : UIState.getTickerRecibo();
        }

        const etiqueta = esModoMonto ? 'Cantidad' : 'Total';
        DOMElements.labelMonto.text(`${etiqueta} (${tickerRelevante || '...'})`);
    },

    actualizarLabelsModoIngreso() {
        const tickerPrincipal = UIState.getTickerPrincipal();
        let tickerSecundario;

        if (UIState.esModoCompra()) {
            // Si compramos, el "Total" se refiere a la moneda con la que pagamos.
            tickerSecundario = UIState.getTickerPago();
        } else {
            // Si vendemos, el "Total" se refiere a la moneda que recibimos.
            tickerSecundario = UIState.getTickerRecibo();
        }
        
        // El modo "Cantidad" siempre se refiere a la criptomoneda principal de la operaci√≥n.
        DOMElements.labelModoMonto.text(`Cantidad (${tickerPrincipal || 'Cripto'})`);
        
        // El modo "Total" se refiere a la otra moneda del par.
        DOMElements.labelModoTotal.text(`Total (${tickerSecundario || 'USDT'})`);
    },

    mostrarSaldo(ticker) {
        if (!ticker) {
            DOMElements.spanSaldoDisponible.text('--');
            return;
        }

        // Usamos AppState en lugar de 'window'
        const moneda = AppState.getOwnedCoinByTicker(ticker);
        // Usamos 'cantidad_formatted' para mostrar, que ya viene del backend y es m√°s preciso.
        // Adem√°s, nos aseguramos de que el saldo mostrado sea el DISPONIBLE.
        const saldoFormateado = moneda ? moneda.cantidad_formatted : '0.00000000';
        const tickerMostrado = moneda ? moneda.ticker : ticker;
        DOMElements.spanSaldoDisponible.text(`${saldoFormateado} ${tickerMostrado}`);
    },
    
    setInputMonto(valor) {
        DOMElements.inputMonto.val(valor);
    },

    renderHistorial(historialData) {
        const tablaHistorial = $('#tabla-historial');
        if (!tablaHistorial.length) return;

        if (historialData.length === 0) {
            tablaHistorial.html(
                '<tr><td colspan="5" class="text-center text-muted py-3">No hay transacciones en el historial.</td></tr>'
            );
            return;
        }

        const historialHTML = historialData
            .map((item) => {
                const claseTipo = item.tipo.toLowerCase() === 'compra' ? 'text-success' : 'text-danger';

                return `
                <tr>
                    <td class="text-start ps-3">${item.fecha_formatted}</td>
                    <td class="fw-bold">${item.par_formatted}</td>
                    <td class="${claseTipo}">${item.tipo_formatted}</td>
                    <td>${item.cantidad_formatted}</td>
                    <td>${item.valor_total_formatted}</td>
                </tr>
            `;
            })
            .join('');

        tablaHistorial.html(historialHTML);
    },

    mostrarMensajeError(mensaje, containerSelector = '#error-container') {
        const errorContainer = $(containerSelector);
        if (!errorContainer.length) {
            console.error(`Error container '${containerSelector}' not found.`);
            return;
        }
        const alertHTML = `
            <div class="alert alert-danger alert-dismissible fade show" role="alert">
                ${mensaje}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        `;
        errorContainer.html(alertHTML);
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/pages/billeteraPage.js ===
==================================================

/**
 * @module pages/billeteraPage
 * @description Orquesta la inicializaci√≥n y la l√≥gica principal de la p√°gina de la billetera.
 */

import { fetchEstadoBilletera, fetchComisiones } from '../services/apiService.js';
import { UIUpdater } from '../components/uiUpdater.js';

/**
 * @typedef {object} ActivoBilletera
 * @property {string} ticker - El s√≠mbolo de la criptomoneda.
 * @property {boolean} es_polvo - Indica si la cantidad es considerada "polvo".
 * @property {string} ganancia_perdida_cruda - El valor num√©rico de la ganancia o p√©rdida (como string).
 * @property {string} cantidad_formatted - La cantidad formateada.
 * @property {string} precio_actual_formatted - El precio actual formateado.
 * @property {string} valor_usdt_formatted - El valor total en USDT formateado.
 * @property {string} ganancia_perdida_formatted - La ganancia o p√©rdida formateada.
 * @property {string} porcentaje_ganancia_formatted - El porcentaje de G/P formateado.
 * @property {string} porcentaje_formatted - El % que representa en la billetera.
 */

/**
 * Crea una fila HTML (`<tr>`) para la tabla de la billetera.
 * @param {ActivoBilletera} cripto - El objeto que contiene los datos del activo.
 * @returns {string} Una cadena de texto con el HTML de la fila de la tabla.
 */
function createBilleteraRowHTML(cripto) {
    const colorGanancia = parseFloat(cripto.ganancia_perdida_cruda) >= 0 ? 'text-success' : 'text-danger';
    const claseFila = cripto.es_polvo ? 'fila-polvo' : '';
    const reservadoClase = parseFloat(cripto.cantidad_reservada) > 0 ? 'text-warning' : '';

    return `
        <tr class="${claseFila}">
            <td class="text-start ps-3">
                <img src="${cripto.logo}" width="24" class="me-3" style="vertical-align: middle;" alt="${cripto.ticker} logo">
                <span class="fw-bold fs-6">${cripto.nombre}</span>
                <span class="text-white-50 ms-2">(${cripto.ticker})</span>
            </td>
            <td class="text-end pe-3">${cripto.cantidad_total_formatted}</td>
            <td class="text-end pe-3">${cripto.cantidad_disponible_formatted}</td>
            <td class="text-end pe-3 ${reservadoClase}">${cripto.cantidad_reservada_formatted}</td>
            <td class="text-end pe-3">${cripto.precio_actual_formatted}</td>
            <td class="text-end pe-3 fw-bold">${cripto.valor_usdt_formatted}</td>
            <td class="text-end pe-3 ${colorGanancia}">${cripto.ganancia_perdida_formatted}</td>
            <td class="text-end pe-3 ${colorGanancia}">${cripto.porcentaje_ganancia_formatted}</td>
            <td class="text-end pe-3">${cripto.porcentaje_formatted}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de la billetera desde la API y los renderiza en la tabla.
 */
async function renderBilletera() {
    const cuerpoTabla = document.getElementById('tabla-billetera');
    if (!cuerpoTabla) {
        console.warn("El elemento #tabla-billetera no fue encontrado en el DOM.");
        return;
    }

    try {
        const datosBilletera = await fetchEstadoBilletera();
        if (!datosBilletera || datosBilletera.length === 0) {
            cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-muted py-4">Tu billetera est√° vac√≠a.</td></tr>';
        } else {
            cuerpoTabla.innerHTML = datosBilletera.map(createBilleteraRowHTML).join('');
        }
    } catch (error) {
        console.error('Error al renderizar la billetera:', error);
        UIUpdater.mostrarMensajeError('No se pudieron cargar los datos de la billetera.');
        cuerpoTabla.innerHTML = '<tr><td colspan="7" class="text-center text-danger py-4">Error al cargar los datos.</td></tr>';
    }
}

/**
 * Crea una fila HTML para la tabla de historial de comisiones.
 * @param {object} comision - El objeto de datos de la comisi√≥n.
 * @returns {string} Una cadena de texto con el HTML de la fila.
 */
function createComisionRowHTML(comision) {
    const fecha = new Date(comision.timestamp).toLocaleString('es-AR', {
        day: '2-digit', month: '2-digit', year: 'numeric',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
    });

    return `
        <tr>
            <td>${fecha}</td>
            <td>${comision.ticker}</td>
            <td>${parseFloat(comision.cantidad).toFixed(8)}</td>
            <td>$${parseFloat(comision.valor_usd).toFixed(2)}</td>
        </tr>
    `;
}

/**
 * Obtiene los datos de comisiones desde la API y los renderiza en la tabla.
 */
async function renderComisiones() {
    const cuerpoTabla = document.getElementById('tabla-comisiones');
    if (!cuerpoTabla) {
        console.warn("El elemento #tabla-comisiones no fue encontrado en el DOM.");
        return;
    }

    try {
        const datosComisiones = await fetchComisiones();
        if (!datosComisiones || datosComisiones.length === 0) {
            cuerpoTabla.innerHTML = '<tr><td colspan="4" class="text-center text-muted py-3">No se han cobrado comisiones.</td></tr>';
        } else {
            cuerpoTabla.innerHTML = datosComisiones.map(createComisionRowHTML).join('');
        }
    } catch (error) {
        console.error('Error al renderizar las comisiones:', error);
        cuerpoTabla.innerHTML = '<tr><td colspan="4" class="text-center text-danger py-4">Error al cargar las comisiones.</td></tr>';
    }
}

/**
 * ### NUEVO: Configura la l√≥gica para el switch de ocultar polvo.
 */
function setupEventListeners() {
    const switchOcultarPolvo = document.getElementById('ocultar-polvo-switch');
    if (switchOcultarPolvo) {
        switchOcultarPolvo.addEventListener('change', (event) => {
            const filasPolvo = document.querySelectorAll('.fila-polvo');
            const estaActivado = event.target.checked;
            
            filasPolvo.forEach(fila => {
                // Ocultamos la fila si el switch est√° activado, la mostramos si no.
                fila.style.display = estaActivado ? 'none' : 'table-row';
            });
        });
    }
}


/**
 * Listener que se ejecuta cuando el DOM est√° completamente cargado.
 */
document.addEventListener('DOMContentLoaded', () => {
    console.log("P√°gina de Billetera cargada. Obteniendo datos...");
    
    // Promise.all espera a que ambas funciones de renderizado terminen.
    Promise.all([
        renderBilletera(),
        renderComisiones()
    ]).then(() => {
        // Una vez que las tablas est√°n renderizadas, configuramos los event listeners.
        setupEventListeners();
    });
});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/indexPage.js ===
==================================================

/**
 * @module pages/indexPage
 * @description L√≥gica para la p√°gina principal de cotizaciones.
 * Se encarga de inicializar y gestionar la actualizaci√≥n peri√≥dica de la tabla de cotizaciones.
 */

import { triggerActualizacionDatos } from '../services/apiService.js';
import { renderTabla } from '../components/tablaCotizacionesUI.js';

/**
 * @const {number} UPDATE_INTERVAL_MS
 * @description Intervalo en milisegundos para la actualizaci√≥n autom√°tica de la tabla de cotizaciones.
 * @default 15000
 */
const UPDATE_INTERVAL_MS = 15000; // 15 segundos

/**
 * Orquesta el ciclo completo de actualizaci√≥n de datos y renderizado de la tabla.
 * Primero, solicita al backend que actualice sus datos desde la fuente externa.
 * Una vez completado, renderiza la tabla de cotizaciones con la informaci√≥n m√°s reciente.
 * @async
 * @function actualizarYRenderizar
 * @throws {Error} Si alguna de las operaciones (actualizaci√≥n o renderizado) falla.
 */
async function actualizarYRenderizar() {
    console.log("Iniciando ciclo de actualizaci√≥n de cotizaciones...");
    try {
        await triggerActualizacionDatos();
        await renderTabla();
        console.log("Tabla de cotizaciones actualizada exitosamente.");
    } catch (error) {
        console.error("Fall√≥ el ciclo de actualizaci√≥n de la tabla de cotizaciones:", error);
    }
}

/**
 * @description Listener que se ejecuta cuando el DOM est√° completamente cargado.
 * Verifica si la tabla de cotizaciones existe en la p√°gina actual y, si es as√≠,
 * inicia el ciclo de actualizaci√≥n inmediata y peri√≥dica.
 * @event DOMContentLoaded
 */
document.addEventListener('DOMContentLoaded', () => {
    // Asegurarse de que el script solo se ejecute en la p√°gina correcta.
    if (document.getElementById('tabla-datos')) {
        console.log("P√°gina de cotizaciones detectada. Iniciando actualizaciones.");
        
        // Ejecuta la actualizaci√≥n inmediatamente al cargar la p√°gina.
        actualizarYRenderizar();
        
        // Establece el intervalo para futuras actualizaciones autom√°ticas.
        setInterval(actualizarYRenderizar, UPDATE_INTERVAL_MS);
    }
});

==================================================
=== ARCHIVO: ./frontend/static/js/pages/tradingPage.js ===
==================================================

// frontend/static/js/pages/tradingPage.js

import { DOMElements } from '../components/domElements.js';
import { UIState } from '../components/uiState.js';
import { UIUpdater } from '../components/uiUpdater.js';
import { FormLogic } from '../components/formLogic.js';
import { initializeChart, updateChartData } from '../components/chartRenderer.js';
import {
    fetchCotizaciones,
    fetchEstadoBilletera,
    fetchHistorial,
    fetchVelas,
    fetchOrdenesAbiertas,
    cancelarOrden
} from '../services/apiService.js';
import { AppState } from '../services/appState.js';
import { saveTradingState, loadTradingState } from '../services/statePersistence.js';

function createOrdenAbiertaRowHTML(orden) {
    const fechaCreacion = new Date(orden.timestamp_creacion).toLocaleString('es-AR', { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' });
    const tipoOrdenClase = orden.accion === 'comprar' ? 'text-success' : 'text-danger';
    const cantidad = orden.cantidad_cripto_principal; 
    const tickerCantidad = orden.accion === 'vender' ? orden.moneda_origen : orden.moneda_destino;
    return `<tr><td class="text-start ps-3 small">${fechaCreacion}</td><td class="fw-bold">${orden.par}</td><td>${orden.tipo_orden.charAt(0).toUpperCase() + orden.tipo_orden.slice(1)}</td><td class="${tipoOrdenClase}">${orden.accion.charAt(0).toUpperCase() + orden.accion.slice(1)}</td><td>$${parseFloat(orden.precio_disparo).toFixed(4)}</td><td>${parseFloat(cantidad).toFixed(6)} ${tickerCantidad}</td><td><button class="btn btn-sm btn-outline-danger btn-cancelar-orden" data-id-orden="${orden.id_orden}">Cancelar</button></td></tr>`;
}

document.addEventListener('DOMContentLoaded', () => {
    let currentTicker;
    let currentInterval;
    let isChartLoading = false;

    function handleTipoOrdenChange() {
        const tipoOrden = $('input[name="tipo-orden"]:checked').val();
        const campoPrecioDisparo = $('#campo-precio-disparo');
        const inputPrecioDisparo = $('#precio_disparo');
        const labelPrecioDisparo = $('#label-precio-disparo');
    

        const campoPrecioLimite = $('#campo-precio-limite');
        const inputPrecioLimite = $('#precio_limite');
    

        campoPrecioDisparo.hide();
        campoPrecioLimite.hide();
        inputPrecioDisparo.prop('required', false);
        inputPrecioLimite.prop('required', false);
    
        if (tipoOrden === 'limit') {
            labelPrecioDisparo.text('Precio L√≠mite'); // Lo llamamos "Precio L√≠mite"
            campoPrecioDisparo.show();
            inputPrecioDisparo.prop('required', true);
    
        } else if (tipoOrden === 'stop-limit') { // Cambiado de 'stop-loss'
            labelPrecioDisparo.text('Precio Stop'); // Ahora este es el "Precio Stop"
            campoPrecioDisparo.show();
            campoPrecioLimite.show(); // Mostramos el segundo campo
            inputPrecioDisparo.prop('required', true);
            inputPrecioLimite.prop('required', true); // Ambos son requeridos
        }
        
        // Para 'market', no se hace nada, ambos campos permanecen ocultos.
        UIUpdater.actualizarLabelMonto();
    }

    // El resto del archivo no necesita cambios significativos
    function actualizarFormularioUI() {
        const esCompra = UIState.esModoCompra();
        const allCryptos = AppState.getAllCryptos();
        const ownedCoins = AppState.getOwnedCoins();
        DOMElements.selectorPrincipal.off('change');
        if (esCompra) {
            const listaParaComprar = allCryptos.filter((c) => c.ticker !== 'USDT');
            FormLogic.popularSelector(DOMElements.selectorPrincipal, listaParaComprar);
        } else {
            const ownedCoinsToSell = ownedCoins.filter(c => c.ticker !== 'USDT');
            FormLogic.popularSelector(DOMElements.selectorPrincipal, ownedCoinsToSell, 'No tienes monedas para vender');
        }
        DOMElements.selectorPrincipal.val(currentTicker);
        DOMElements.selectorPrincipal.on('change', handleSelectorPrincipalChange);
        FormLogic.actualizarOpcionesDeSelectores();
        const tickerParaBalance = esCompra ? UIState.getTickerPago() : UIState.getTickerPrincipal();
        UIUpdater.mostrarSaldo(tickerParaBalance);
        UIUpdater.actualizarLabelMonto();
        UIUpdater.actualizarLabelsModoIngreso();
    }

    function handleSelectorPrincipalChange() {
        const nuevoTicker = UIState.getTickerPrincipal();
        if (!nuevoTicker || nuevoTicker === currentTicker) return;
        currentTicker = nuevoTicker;
        actualizarFormularioUI();
        actualizarGrafico(currentTicker, currentInterval);
        saveTradingState(currentTicker, currentInterval);
    }

    function setTradeMode(mode) {
        DOMElements.inputAccion.val(mode);
        UIUpdater.actualizarBotones();
        UIUpdater.actualizarVisibilidadCampos();
        actualizarFormularioUI();
    }
    
    async function actualizarGrafico(ticker, interval) {
        if (!ticker || isChartLoading) { return; }
        isChartLoading = true;
        try {
            const nuevosDatosVelas = await fetchVelas(ticker, interval);
            updateChartData(nuevosDatosVelas);
        } catch (error) {
            console.error(`Error al actualizar el gr√°fico para ${ticker}/${interval}:`, error);
            updateChartData([]);
        } finally {
            isChartLoading = false;
        }
    }
    
    function validarInputNumerico(event, maxDecimales = 8) {
        const input = event.target;
        let value = input.value;
        value = value.replace(/[^0-9.]/g, '').replace(/(\..*)\./g, '$1');
        const parts = value.split('.');
        if (parts[1] && parts[1].length > maxDecimales) {
            value = parts[0] + '.' + parts[1].substring(0, maxDecimales);
        }
        if (input.value !== value) {
            input.value = value;
        }
    }
    
    function setupEventListeners() {
        DOMElements.botonComprar.on('click', () => setTradeMode('comprar'));
        DOMElements.botonVender.on('click', () => setTradeMode('vender'));
        DOMElements.selectorPrincipal.on('change', handleSelectorPrincipalChange);
        
        DOMElements.selectorPagarCon.on('change', () => {
            UIUpdater.mostrarSaldo(UIState.getTickerPago());
            UIUpdater.actualizarLabelMonto();
            UIUpdater.actualizarLabelsModoIngreso();
        });
        
        DOMElements.selectorRecibirEn.on('change', () => {
            UIUpdater.actualizarLabelMonto();
            UIUpdater.actualizarLabelsModoIngreso();
        });
        
        $('#timeframe-selector').on('click', '.timeframe-btn', function () {
            currentInterval = $(this).data('interval');
            $(this).addClass('active').siblings().removeClass('active');
            actualizarGrafico(currentTicker, currentInterval);
            saveTradingState(currentTicker, currentInterval);
        });

        $('input[name="tipo-orden"]').on('change', handleTipoOrdenChange);
        DOMElements.radioModoIngreso.on('change', UIUpdater.actualizarLabelMonto);
        
        DOMElements.inputMonto.on('input', (e) => validarInputNumerico(e, 8));
        $('#precio_disparo').on('input', (e) => validarInputNumerico(e, 8));

        $('#tabla-ordenes-abiertas').on('click', '.btn-cancelar-orden', function() {
            const orderId = $(this).data('id-orden');
            Swal.fire({
                title: '¬øEst√°s seguro?', text: "No podr√°s revertir esta acci√≥n.",
                icon: 'warning', showCancelButton: true, confirmButtonColor: '#d33',
                cancelButtonColor: '#3085d6', confirmButtonText: 'S√≠, ¬°cancelar orden!',
                cancelButtonText: 'No', background: '#212529', color: '#f8f9fa'
            }).then(async (result) => {
                if (result.isConfirmed) {
                    try {
                        const respuesta = await cancelarOrden(orderId);
                        Toast.fire({ icon: 'success', html: respuesta.mensaje });
                        $(this).closest('tr').fadeOut(400, function() { $(this).remove(); if ($('#tabla-ordenes-abiertas tr').length === 0) {
                            const tablaBody = $('#tabla-ordenes-abiertas');
                            tablaBody.html('<tr><td colspan="7" class="text-center text-muted py-3">No hay √≥rdenes abiertas.</td></tr>');
                        }});
                    } catch (error) {
                        Swal.fire({ icon: 'error', title: 'Error', text: 'No se pudo cancelar la orden.', background: '#212529', color: '#f8f9fa' });
                    }
                }
            });
        });
    }

    async function initialize() {
        console.log('Inicializando p√°gina de trading...');
        const urlParams = new URLSearchParams(window.location.search);
        const tickerDesdeUrl = urlParams.get('ticker');
        const savedState = loadTradingState();
        currentTicker = tickerDesdeUrl || savedState?.ticker || 'BTC';
        currentInterval = savedState?.interval || '1d';
        if (tickerDesdeUrl) saveTradingState(currentTicker, currentInterval);
        
        try {
            const [cotizaciones, estadoBilletera, historial, ordenesAbiertas] = await Promise.all([
                fetchCotizaciones(), fetchEstadoBilletera(), fetchHistorial(), fetchOrdenesAbiertas()
            ]);

            AppState.setAllCryptos(cotizaciones);
            AppState.setOwnedCoins(estadoBilletera);

            UIUpdater.renderHistorial(historial);
            const tablaOrdenesBody = $('#tabla-ordenes-abiertas');
            if (ordenesAbiertas.length === 0) {
                tablaOrdenesBody.html('<tr><td colspan="7" class="text-center text-muted py-3">No hay √≥rdenes abiertas.</td></tr>');
            } else {
                tablaOrdenesBody.html(ordenesAbiertas.map(createOrdenAbiertaRowHTML).join(''));
            }

            const datosVelas = await fetchVelas(currentTicker, currentInterval);
            initializeChart(datosVelas);
            
            [DOMElements.selectorPrincipal, DOMElements.selectorPagarCon, DOMElements.selectorRecibirEn].forEach((sel) => {
                sel.select2({ width: '100%', dropdownCssClass: 'text-dark', theme: 'bootstrap-5' });
            });

            setupEventListeners();
            setTradeMode('comprar');
            handleTipoOrdenChange();

            $('#timeframe-selector .timeframe-btn').removeClass('active').filter(`[data-interval="${currentInterval}"]`).addClass('active');

            console.log('P√°gina de trading inicializada correctamente.');
        } catch (error) {
            console.error('Error fatal durante la inicializaci√≥n:', error);
            Swal.fire({
                icon: 'error', title: 'Error de Conexi√≥n',
                text: 'No se pudieron cargar los datos esenciales. Por favor, recarga la p√°gina.',
                background: '#212529', color: '#f8f9fa'
            });
        }
    }

    initialize();
});

==================================================
=== ARCHIVO: ./frontend/static/js/services/apiService.js ===
==================================================

// frontend/static/js/services/apiService.js

/**
 * ### REFACTORIZADO ###
 * Realiza una solicitud `fetch` y maneja respuestas de √©xito y de error estructuradas.
 */
async function _fetchData(url, options = {}, errorMessage = 'Error en la solicitud a la API') {
    try {
        const response = await fetch(url, options);

        if (!response.ok) {
            // Si la respuesta no es OK, intentamos leer el cuerpo del error.
            const errorData = await response.json().catch(() => null); // Si el cuerpo no es JSON, devuelve null.
            const message = errorData?.mensaje || response.statusText; // Usa el mensaje del backend o el texto de estado HTTP.
            
            // Creamos un error que contiene los datos estructurados.
            const error = new Error(message);
            error.datos = errorData; // Adjuntamos todos los datos del error.
            error.status = response.status;
            throw error;
        }

        return await response.json();
    } catch (error) {
        console.error(`Error en la llamada a la API [${url}]:`, error);
        throw error; // Re-lanzamos el error para que el c√≥digo que llama pueda manejarlo.
    }
}

// El resto de las funciones (fetchCotizaciones, fetchEstadoBilletera, etc.) NO CAMBIAN.
// Siguen usando _fetchData, que ahora es m√°s potente.

export const fetchCotizaciones = () => 
    _fetchData('/api/cotizaciones', {}, 'No se pudieron cargar las cotizaciones');

export const fetchEstadoBilletera = () => 
    _fetchData('/api/billetera/estado-completo', {}, 'No se pudo cargar el estado de la billetera');

export const fetchHistorial = () => 
    _fetchData('/api/historial', {}, 'No se pudo cargar el historial de transacciones');

export const fetchVelas = (ticker, interval) => 
    _fetchData(`/api/velas/${ticker}/${interval}`, {}, `No se pudieron cargar los datos de velas para ${ticker} (${interval})`);

export const triggerActualizacionDatos = () => 
    _fetchData('/api/actualizar', {}, 'La solicitud para actualizar los datos fall√≥');

export const fetchComisiones = () => 
    _fetchData('/api/comisiones', {}, 'No se pudo cargar el historial de comisiones');

export const fetchOrdenesAbiertas = () =>
    _fetchData('/api/ordenes-abiertas', {}, 'No se pudo cargar la lista de √≥rdenes abiertas');

export const cancelarOrden = (idOrden) => 
    _fetchData(`/api/orden/cancelar/${idOrden}`, {
        method: 'POST'
    }, 'No se pudo cancelar la orden');

==================================================
=== ARCHIVO: ./frontend/static/js/services/appState.js ===
==================================================

/**
 * @module services/appState
 * @description Centraliza el estado de la aplicaci√≥n para evitar el uso de variables globales.
 * Proporciona m√©todos seguros para leer y escribir en el estado.
 */

const state = {
    allCryptos: [],
    ownedCoins: []
};

export const AppState = {
    /**
     * Establece la lista completa de cotizaciones.
     * @param {Array<object>} cryptos - La lista de criptomonedas.
     */
    setAllCryptos: (cryptos) => {
        state.allCryptos = cryptos || [];
    },

    /**
     * Establece la lista de monedas que el usuario posee.
     * @param {Array<object>} coins - La lista de monedas en la billetera.
     */
    setOwnedCoins: (coins) => {
        state.ownedCoins = coins || [];
    },

    /**
     * Obtiene la lista completa de cotizaciones.
     * @returns {Array<object>}
     */
    getAllCryptos: () => state.allCryptos,

    /**
     * Obtiene la lista de monedas que el usuario posee.
     * @returns {Array<object>}
     */
    getOwnedCoins: () => state.ownedCoins,

    /**
     * Busca una moneda espec√≠fica que el usuario posee por su ticker.
     * @param {string} ticker - El ticker de la moneda.
     * @returns {object | undefined} El objeto de la moneda o undefined si no se encuentra.
     */
    getOwnedCoinByTicker: (ticker) => {
        return state.ownedCoins.find(coin => coin.ticker === ticker);
    },

    /**
     * Busca el precio de una criptomoneda espec√≠fica por su ticker.
     * @param {string} ticker - El ticker de la moneda.
     * @returns {number | null} El precio de la moneda o null si no se encuentra.
     */
    getPriceByTicker: (ticker) => {
        const crypto = state.allCryptos.find(c => c.ticker === ticker);
        // La propiedad 'precio_usd' viene del backend como un string, lo convertimos a n√∫mero.
        return crypto ? parseFloat(crypto.precio_usd) : null;
    }
};

==================================================
=== ARCHIVO: ./frontend/static/js/services/statePersistence.js ===
==================================================

/**
 * @module services/statePersistence
 * @description Gestiona el guardado y la carga del estado de la aplicaci√≥n
 * en el Almacenamiento Local (LocalStorage) del navegador.
 */

// Usamos una clave constante para evitar errores de tipeo.
const TRADING_STATE_KEY = 'tradingViewState';

/**
 * Guarda el estado actual de la vista de trading (ticker e intervalo).
 * @param {string} ticker - El ticker de la criptomoneda actual.
 * @param {string} interval - El intervalo de tiempo actual.
 */
export function saveTradingState(ticker, interval) {
    if (!ticker || !interval) {
        console.warn("Intento de guardar estado de trading inv√°lido.");
        return;
    }
    const state = { ticker, interval };
    try {
        // Los objetos deben ser convertidos a string (JSON) para guardarse en LocalStorage.
        localStorage.setItem(TRADING_STATE_KEY, JSON.stringify(state));
    } catch (error) {
        console.error("Error al guardar el estado en LocalStorage:", error);
    }
}

/**
 * Carga el estado de la vista de trading desde LocalStorage.
 * @returns {{ticker: string, interval: string} | null} El estado guardado o null si no se encuentra nada.
 */
export function loadTradingState() {
    try {
        const savedStateJSON = localStorage.getItem(TRADING_STATE_KEY);
        if (savedStateJSON) {
            // Si encontramos datos, los convertimos de nuevo a un objeto JavaScript.
            return JSON.parse(savedStateJSON);
        }
        return null; // No hay estado guardado.
    } catch (error) {
        console.error("Error al cargar el estado desde LocalStorage:", error);
        return null;
    }
}

==================================================
=== ARCHIVO: ./frontend/static/js/utils/sweetalert-init.js ===
==================================================

/**
 * @file sweetalert-init.js
 * @description Inicializa y configura globalmente la librer√≠a SweetAlert2.
 * Define un objeto 'Toast' personalizado para notificaciones no intrusivas.
 */

// Se define 'Toast' en el √°mbito global para que sea accesible
// desde otros scripts, como los flashes de Flask en el HTML.
const Toast = Swal.mixin({
    toast: true,
    position: 'top-end',
    showConfirmButton: false,
    timer: 8000,
    customClass: {
        popup: 'custom-toast-position'
    },
    timerProgressBar: true,
    didOpen: (toast) => {
        toast.addEventListener('mouseenter', Swal.stopTimer);
        toast.addEventListener('mouseleave', Swal.resumeTimer);
    },
    background: '#343a40', // Fondo oscuro
    color: '#f8f9fa'       // Texto claro
});


==================================================
=== ARCHIVO: ./frontend/templates/_flashes.html ===
==================================================

<!-- frontend/templates/_flashes.html -->
<!-- ### REFACTORIZADO ### - Ahora es un componente inteligente que construye el HTML. -->

{% with messages = get_flashed_messages(with_categories=true) %}
{% if messages %}
<script>
    document.addEventListener('DOMContentLoaded', function () {
        /**
         * Construye el contenido HTML para la notificaci√≥n Toast a partir de los datos
         * estructurados que env√≠a el backend.
         * @param {object} data - El objeto de datos parseado desde el JSON.
         * @returns {string} El HTML para el cuerpo de la notificaci√≥n.
         */
        function buildFlashMessageHTML(data) {
            // Estilo com√∫n para el cuerpo del mensaje
            const baseStyle = 'text-align: left; font-size: 0.9rem;';
            const hr = "<hr style='margin: 4px 0; border-color: #555;'>";

            if (data.tipo === 'mercado') {
                const d = data.detalles;
                return `
                    <div style="${baseStyle}">
                        <span>Recibiste: <strong style='color: #1FB371;'>${d.recibiste.cantidad} ${d.recibiste.ticker}</strong></span><br>
                        <span>Pagaste: <strong style='color: #FFA500;'>${d.pagaste.cantidad} ${d.pagaste.ticker}</strong></span><br>
                        <span style='font-size: 0.8rem; color: #999;'>Comisi√≥n: ${d.comision.cantidad} ${d.comision.ticker}</span>
                    </div>
                `;
            } else if (data.tipo === 'limit' || data.tipo === 'stop-loss') {
                const d = data.detalles;
                return `
                    <div style="${baseStyle}">
                        <span>Acci√≥n: <strong>${d.accion}</strong></span><br>
                        <span>Precio Disparo: <strong>${d.precio_disparo}</strong></span><br>
                        <span style='font-size: 0.8rem; color: #999;'>Los fondos han sido reservados.</span>
                    </div>
                `;
            }
            return 'Detalles no disponibles.'; // Fallback
        }

        const flashedMessages = {{ messages|tojson|safe }};

        if (typeof Toast !== 'undefined') {
            flashedMessages.forEach(([category, message]) => {
                const iconType = category === 'danger' ? 'error' : 'success';
                let title, htmlContent;

                if (category === 'success') {
                    try {
                        // El mensaje de √©xito es un JSON, lo parseamos
                        const data = JSON.parse(message);
                        title = data.titulo || 'Operaci√≥n Procesada';
                        htmlContent = buildFlashMessageHTML(data);
                    } catch (e) {
                        // Si falla el parseo, lo mostramos como texto plano
                        console.error("Error al parsear el mensaje flash JSON:", e);
                        title = 'Operaci√≥n Exitosa';
                        htmlContent = message;
                    }
                } else {
                    // El mensaje de error es un string simple
                    title = 'Error en la operaci√≥n';
                    htmlContent = message;
                }
                
                Toast.fire({
                    icon: iconType,
                    title: title,
                    html: htmlContent
                });
            });
        } else {
            console.error("SweetAlert Toast no est√° definido.");
        }
    });
</script>
{% endif %}
{% endwith %}

==================================================
=== ARCHIVO: ./frontend/templates/billetera.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Billetera</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <!-- Los estilos pueden ser los mismos de trading o unos espec√≠ficos para billetera -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="bg-dark text-white">
    <!-- ========== BARRA DE NAVEGACI√ìN ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white active"
                            href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes de error (si se necesita) -->
    <div id="error-container" class="container-fluid mt-3"></div>

    <!-- ========== CONTENIDO PRINCIPAL ========== -->
    <main class="container my-4">
        <div class="text-center">
            <h2 class="text-warning mb-4">Mi Billetera</h2>
        </div>

        <!-- Switch para ocultar saldos peque√±os (polvo) -->
        <div class="d-flex justify-content-end mb-3">
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="ocultar-polvo-switch">
                <label class="form-check-label text-white-50" for="ocultar-polvo-switch">Ocultar saldos peque√±os</label>
            </div>
        </div>

        <!-- Tabla de Activos en la Billetera -->
        <table class="table table-dark table-striped align-middle"> <!-- Quitamos table-bordered -->
            <thead>
                <!-- A√±adimos clases de alineaci√≥n a las cabeceras -->
                <tr>
                    <th class="text-start ps-3">Activo</th>
                    <th class="text-end pe-3">Total</th>
                    <th class="text-end pe-3">Disponible</th>
                    <th class="text-end pe-3">En √ìrdenes</th>
                    <th class="text-end pe-3">Precio Actual</th>
                    <th class="text-end pe-3">Valor Total (USD)</th>
                    <th class="text-end pe-3">G/P (USD)</th>
                    <th class="text-end pe-3">G/P (%)</th>
                    <th class="text-end pe-3">% Billetera</th>
                </tr>
            </thead>
            <tbody id="tabla-billetera">
                <!-- El colspan sigue siendo 9, as√≠ que no cambia -->
                <tr>
                    <td colspan="9" class="text-center text-muted py-4">Cargando billetera...</td>
                </tr>
            </tbody>
        </table>

        <!-- Historial de Comisiones -->
        <div class="text-center mt-5">
            <h4 class="text-warning mb-4">Historial de Comisiones</h4>
        </div>

        <div class="table-responsive mt-4">
            <table class="table table-dark table-striped align-middle text-center">
                <thead class="table-secondary">
                    <tr class="table-dark">
                        <th>Fecha</th>
                        <th>Moneda (Fee)</th>
                        <th>Cantidad Cobrada</th>
                        <th>Valor (USD)</th>
                    </tr>
                </thead>
                <tbody id="tabla-comisiones">
                    <!-- El contenido ser√° renderizado aqu√≠ por billeteraPage.js -->
                    <tr>
                        <td colspan="4" class="text-center text-muted py-4">Cargando historial de comisiones...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </main>

    <!-- ========== SCRIPTS ========== -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/billeteraPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/index.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BlocX</title>
	<link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
	<link rel="stylesheet" href="{{ url_for('static', filename='css/styles_index.css') }}">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
</head>

<body class="bg-dark text-white">


	<nav class="navbar navbar-expand-lg bg-black shadow">
		<div class="container-fluid">
			<a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
				<img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
				<span>BlocX</span>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
				<span class="navbar-toggler-icon bg-light"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarNav">
				<ul class="navbar-nav ms-auto">
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Contenedor para mensajes de error -->
	<div id="error-container" class="container-fluid mt-3"></div>

	<!-- Contenedor principal -->
	<main class="container-fluid mt-4">
		<div class="row">
			<div class="col-12">
				<div class="p-2 shadow text-center">
					<h3 class="text-warning">Cotizaciones</h3>
					<table class="table table-dark table-striped mt-4">
						<thead>
							<tr>
								<th class="text-start px-3">#</th>
								<th class="text-start px-3">Nombre</th>
								<th class="text-start px-3">Precio</th>
								<th class="text-end px-3">1h</th>
								<th class="text-end px-3">24h</th>
								<th class="text-end px-3">7d</th>
								<th class="text-end px-3">Cap. Mercado</th>
								<th class="text-end px-3">Volumen</th>
								<th class="text-end px-3">Suministro</th>
							</tr>
						</thead>
						<tbody id="tabla-datos" class="align-middle">
							<!-- Aqu√≠ se insertar√°n las filas con JS -->
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</main>

	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
	<script type="module" src="{{ url_for('static', filename='js/pages/indexPage.js') }}"></script>

</body>

</html>

==================================================
=== ARCHIVO: ./frontend/templates/trading.html ===
==================================================

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlocX - Trading</title>
    <link rel="icon" href="{{ url_for('static', filename='img/logo_BlocX.png') }}" type="image/x-icon">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles_trading.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/select2-bootstrap-5-theme@1.3.0/dist/select2-bootstrap-5-theme.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
</head>

<body class="bg-dark text-white">

    <!-- ========== BARRA DE NAVEGACI√ìN ========== -->
    <nav class="navbar navbar-expand-lg bg-black shadow">
        <div class="container-fluid">
            <a class="navbar-brand text-warning d-flex align-items-center gap-2" href="{{ url_for('home.index') }}">
                <img src="{{ url_for('static', filename='img/logo_BlocX.png') }}" alt="Logo" width="40" height="40">
                <span>BlocX</span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon bg-light"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('home.index') }}">Cotizaciones</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('trading.mostrar_trading_page') }}">Trading</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link text-white" href="{{ url_for('billetera.mostrar_billetera') }}">Billetera</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Contenedor para mensajes flash de Flask (ahora en un archivo parcial) -->
    {% include '_flashes.html' %}

    <!-- ========== CONTENIDO PRINCIPAL ========== -->
    <div class="container mt-4">
        <div class="row">
            <div class="col-md-7">
                <h3 class="text-light">Gr√°fico velas</h3>

                <div class="btn-group btn-group-sm mb-2" role="group" id="timeframe-selector">
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="5m">5m</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn"
                        data-interval="15m">15m</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="1h">1h</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="4h">4h</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn active"
                        data-interval="1d">1D</button>
                    <button type="button" class="btn btn-outline-secondary timeframe-btn" data-interval="1w">1S</button>
                </div>

                <div class="form-check form-switch mb-2 d-inline-block ms-3">
                    <input class="form-check-input" type="checkbox" id="toggleVolume" checked>
                    <label class="form-check-label text-light" for="toggleVolume">Mostrar volumen</label>
                </div>

                <div class="py-3" style="position: relative;">
                    <div id="chart-error-overlay" class="chart-overlay" style="display: none;">
                        <span>No hay datos de gr√°fico disponibles para este par y temporalidad.</span>
                    </div>
                    <div id="chart"></div>
                </div>
            </div>

            <form class="col-md-5 p-3" id="formulario-trading" method="POST"
                action="{{ url_for('trading.procesar_trading_form') }}">
                <h2 class="text-warning">Trading</h2>
                <div class="row g-2 mb-3">
                    <div class="col-6">
                        <label for="cripto" class="form-label">Criptomoneda</label>
                        <select class="form-select" id="cripto" name="ticker" required></select>
                    </div>
                    <div class="col-6">
                        <div id="campo-pagar-con" style="display: none;">
                            <label for="moneda-pago" class="form-label">Pagar con</label>
                            <select class="form-select" id="moneda-pago" name="moneda-pago"></select>
                        </div>
                        <div id="campo-recibir-en" style="display: none;">
                            <label for="moneda-recibir" class="form-label">Recibir en</label>
                            <select class="form-select" id="moneda-recibir" name="moneda-recibir"></select>
                        </div>
                    </div>
                </div>
                <div class="btn-group mb-3 w-100" role="group" id="toggle-trade-type">
                    <input type="hidden" name="accion" id="accion" value="comprar">
                    <button type="button" class="btn w-50 btn-success active boton-comprar"
                        data-action="comprar">Comprar</button>
                    <button type="button" class="btn w-50 btn-outline-secondary boton-vender"
                        data-action="vender">Vender</button>
                </div>
                <div class="mb-3">
                    <label class="form-label d-block mb-2">Tipo de orden</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-mercado" value="market"
                            autocomplete="off" checked>
                        <label class="btn btn-outline-primary rounded-start-pill" for="tipo-mercado">Mercado</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-limite" value="limit"
                            autocomplete="off">
                        <label class="btn btn-outline-primary" for="tipo-limite">L√≠mite</label>
                        <input type="radio" class="btn-check" name="tipo-orden" id="tipo-stop-limit" value="stop-limit"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="tipo-stop-limit">Stop-Limit</label>
                    </div>
                </div>

                <!-- CAMPO NUEVO: Precio de Disparo -->
                <div class="mb-3" id="campo-precio-disparo" style="display: none;">
                    <label for="precio_disparo" class="form-label" id="label-precio-disparo">Precio L√≠mite</label>
                    <input type="text" class="form-control" id="precio_disparo" placeholder="0.00" name="precio_disparo"
                        inputmode="decimal">
                </div>

                <div class="mb-3" id="campo-precio-limite" style="display: none;">
                    <label for="precio_limite" class="form-label">Precio L√≠mite</label>
                    <input type="text" class="form-control" id="precio_limite" placeholder="0.00" name="precio_limite"
                        inputmode="decimal">
                </div>

                <div class="mb-3" id="campo-modo-ingreso">
                    <label class="form-label d-block mb-2">Ingresar por</label>
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-monto" value="monto"
                            autocomplete="off" checked>
                        <label class="btn btn-outline-primary rounded-start-pill" for="modo-monto"
                            id="label-modo-monto">Cantidad (Cripto)</label>
                        <input type="radio" class="btn-check" name="modo-ingreso" id="modo-total" value="total"
                            autocomplete="off">
                        <label class="btn btn-outline-primary rounded-end-pill" for="modo-total"
                            id="label-modo-total">Total (USDT)</label>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="monto" class="form-label" id="label-monto">Cantidad</label>
                    <input type="text" class="form-control" id="monto" name="monto" placeholder="0.00" required
                        inputmode="decimal">
                </div>
                <div class="mb-3">


                </div>
                <div class="mb-3 text-end text-secondary">
                    <small>Disponible: <span id="saldo-disponible">--</span></small>
                </div>
                <button type="submit" class="btn w-100 btn-success boton-confirmar"
                    id="boton-confirmar">CONFIRMAR</button>
            </form>
        </div>

        <!-- SECCI√ìN NUEVA: √ìrdenes Abiertas -->
        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">√ìrdenes Abiertas</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha Creaci√≥n</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Acci√≥n</th>
                                <th>Precio Disparo</th>
                                <th>Cantidad</th>
                                <th>Acciones</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-ordenes-abiertas">
                            <!-- El contenido ser√° renderizado por JS -->
                            <tr>
                                <td colspan="7" class="text-center text-muted py-3">Cargando √≥rdenes abiertas...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="row mt-5">
            <div class="col-12">
                <h4 class="text-warning">Historial de transacciones</h4>
                <div class="table-responsive">
                    <table class="table table-dark table-striped text-center align-middle">
                        <thead>
                            <tr>
                                <th class="text-start ps-3">Fecha</th>
                                <th>Par</th>
                                <th>Tipo</th>
                                <th>Cantidad</th>
                                <th>Valor Total</th>
                            </tr>
                        </thead>
                        <tbody id="tabla-historial">
                            <tr>
                                <td colspan="5" class="text-center text-muted py-3">Cargando historial...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== SECCI√ìN SCRIPTS ===== -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.all.min.js"></script>
    <script src="{{ url_for('static', filename='js/utils/sweetalert-init.js') }}"></script>
    <script type="module" src="{{ url_for('static', filename='js/pages/tradingPage.js') }}"></script>
</body>

</html>

==================================================
=== ARCHIVO: ./pytest.ini ===
==================================================

[pytest]
python_files = test_*.py
python_classes = Test*
python_functions = test_*
testpaths = tests


==================================================
=== ARCHIVO: ./README.md ===
==================================================

# Simulador Exchange - **BlokX**

Este proyecto educativo fue desarrollado en el marco de la materia "Algoritmos y Estructuras de Datos I" de UADE, bajo la supervisi√≥n de la profesora Julia Monasterio.  
Su objetivo es aplicar los conocimientos de la c√°tedra simulando el funcionamiento b√°sico de un exchange de criptomonedas.  
El sistema permite a los usuarios operar con saldo ficticio utilizando datos reales de cotizaci√≥n obtenidos de CoinGecko y Binance.

## üéØ Objetivos del proyecto

- Familiarizar a los usuarios con el entorno de un exchange de criptomonedas.
- Simular operaciones de compra y venta mediante distintos tipos de √≥rdenes: Market, Limit y Stop-Loss.
- Calcular y visualizar ganancias, p√©rdidas y balances del portafolio.
- Almacenar toda la informaci√≥n de manera local utilizando archivos `.json`.
- Comprender la interacci√≥n entre frontend y backend mediante una arquitectura moderna (HTML, CSS, Flask y Python).

## ‚öôÔ∏è Funcionalidades

### Panel general de cotizaciones
- Visualizaci√≥n del top de criptomonedas con:
  - Nombre, ticker, precio, market cap, volumen, supply.
  - Variaci√≥n en 1h, 24h y 7 d√≠as.
- Actualizaci√≥n autom√°tica de precios cada 15 segundos.

### Panel de trading
En este panel se ver√°n tres secciones diferentes que contemplan lo necesario para ejecutar las ordenes de compra/venta.

#### Gr√°fico de velas japonesas
- Grafico en el cual se va a poder visualizar los diferentes pares de criptos usando Lightweight Charts (Libreria de JavaScript), en diferentes time frames: 1m, 5m, 15m, 1h, 4hs, 1d y 1w.

#### √ìrdenes
- Compra y venta de activos con √≥rdenes:
  - Market
  - Limit
  - Stop-loss
- Comisi√≥n fija del 0.5% por transacci√≥n.
- Validaciones de saldo y tenencias disponibles.

#### Historial
- Registro de todas las operaciones realizadas.
- Incluye tipo de orden, precio, cantidad, fecha y fee aplicado.
  
### Billetera
- Visualizaci√≥n de tenencias actuales:
  - Cantidad, precio promedio, valor actual, ganancia/p√©rdida por activo.
- Balance total del portafolio en USDT.

## üß† C√≥mo funciona el sistema

El sistema est√° dise√±ado bajo una arquitectura desacoplada que separa claramente las responsabilidades del backend y del frontend:

- **Backend (Python/Flask)**: Act√∫a como una API pura de JSON. Sus responsabilidades son:
    - **`rutas/`**: Define los endpoints de la API (`/api/...`) que exponen los datos y la l√≥gica de negocio en formato JSON. Tambi√©n sirve el contenedor HTML inicial de cada p√°gina.
    - **`servicios/`**: Contiene toda la l√≥gica de negocio (c√°lculos de billetera, procesamiento de √≥rdenes, formato de datos) y prepara los datos para ser enviados como JSON.
    - **`acceso_datos/`**: Gestiona la lectura y escritura de los archivos `.json` que act√∫an como base de datos.
    - **`utils/`**: Proporciona funciones de utilidad, como formateadores de datos que se aplican en el backend.

- **Frontend (JavaScript)**: Es un cliente din√°mico que consume la API del backend.
    - **Aut√≥nomo**: Cada p√°gina carga su propio HTML y luego utiliza JavaScript para buscar todos los datos que necesita de los endpoints `/api/...`.
    - **Renderizado en el cliente**: Todo el renderizado y la manipulaci√≥n del DOM (actualizaci√≥n de tablas, saldos, gr√°ficos) se realiza en el navegador, creando una experiencia de usuario fluida y r√°pida sin recargas de p√°gina.
    - **Estructura modular en `js/`**:
        - **`pages/`**: Contiene la l√≥gica de inicializaci√≥n y orquestaci√≥n para cada p√°gina principal (ej. `tradingPage.js`).
        - **`components/`**: M√≥dulos encargados de actualizar partes espec√≠ficas de la interfaz (ej. `uiUpdater.js`, `tablaCotizacionesUI.js`).
        - **`services/`**: Gestiona la comunicaci√≥n con la API del backend.

### Flujo desacoplado

1.  El usuario navega a una URL (ej. `/trading`).
2.  Flask sirve un archivo HTML m√≠nimo (`trading.html`) que act√∫a como un esqueleto.
3.  El archivo JavaScript asociado a esa p√°gina (`tradingPage.js`) se ejecuta.
4.  El script de JS realiza llamadas a los endpoints de la API del backend (`/api/cotizaciones`, `/api/historial`, etc.) para obtener los datos en formato JSON.
5.  Una vez recibidos los datos, JavaScript actualiza din√°micamente el DOM para mostrar la informaci√≥n al usuario.

## üóÉÔ∏è Estructura del proyecto

```
simulador_exchange/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ app.py                      # Servidor Flask y punto de entrada
‚îÇ   ‚îú‚îÄ‚îÄ config.py                   # Configuraci√≥n del sistema y constantes globales
‚îÇ   ‚îú‚îÄ‚îÄ rutas/                      # Blueprints que definen las vistas y API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trading_vista.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ billetera_vista.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api_cotizaciones_vista.py
‚îÇ   ‚îú‚îÄ‚îÄ servicios/                  # L√≥gica de negocio de cada m√≥dulo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_cotizaciones.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ estado_billetera.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ velas_logica.py
‚îÇ   ‚îú‚îÄ‚îÄ acceso_datos/               # Acceso y manipulaci√≥n de archivos .json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ datos_billetera.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ datos_cotizaciones.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ datos_historial.py
‚îÇ   ‚îî‚îÄ‚îÄ utils/                      # Utilidades auxiliares
‚îÇ       ‚îî‚îÄ‚îÄ formatters.py
‚îÇ
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ templates/                  # Plantillas HTML (contenedores iniciales)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ billetera.html
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trading.html
‚îÇ   ‚îî‚îÄ‚îÄ static/                     # Archivos est√°ticos
‚îÇ       ‚îú‚îÄ‚îÄ css/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ styles_index.css
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ styles_trading.css
‚îÇ       ‚îú‚îÄ‚îÄ img/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ logo_BlocX.png
‚îÇ       ‚îî‚îÄ‚îÄ js/                     # L√≥gica del cliente
‚îÇ           ‚îú‚îÄ‚îÄ components/         # M√≥dulos para actualizar la UI
‚îÇ           ‚îú‚îÄ‚îÄ pages/              # Scripts de orquestaci√≥n por p√°gina
‚îÇ           ‚îî‚îÄ‚îÄ services/           # Servicios de comunicaci√≥n con la API
‚îÇ
‚îú‚îÄ‚îÄ datos/                          # Archivos de persistencia
‚îÇ   ‚îú‚îÄ‚îÄ billetera.json
‚îÇ   ‚îú‚îÄ‚îÄ datos_cotizaciones.json
‚îÇ   ‚îú‚îÄ‚îÄ datos_velas.json
‚îÇ   ‚îî‚îÄ‚îÄ historial_operaciones.json
‚îÇ
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ README.md
```

## üöÄ C√≥mo ejecutar el proyecto

### 1. Crear entorno virtual (recomendado)
```bash
python3 -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

### 2. Instalar dependencias
```bash
pip install -r requirements.txt
```

### 3. Iniciar la app
```bash
python3 app.py
```

Y luego acceder desde el navegador a:  
```
http://localhost:5000
```

## üì¶ Tecnolog√≠as utilizadas

- Python 3.13
- Flask
- HTML, CSS, JavaScript
- Lightweight Charts (TradingView)

## üìå Notas

- Todos los datos se almacenan localmente en formato JSON.
- No se requiere conexi√≥n a bases de datos externas.
- El sistema est√° pensado para ser did√°ctico y extensible.

---

**Grupo 12**  
Fausto Lovera ‚Äî Patricio Menta ‚Äî Andrei Veis


==================================================
=== ARCHIVO: ./requirements.txt ===
==================================================

Flask==3.1.0
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
requests==2.32.3
Werkzeug==3.1.3
python-dotenv==1.0.1



==================================================
=== ARCHIVO: ./tests/__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./tests/test_estado_billetera.py ===
==================================================

import pytest
from decimal import Decimal

# Importamos las funciones a probar
from backend.servicios.estado_billetera import _calcular_metricas_activo, estado_actual_completo

# --- Fixtures: Datos de prueba reutilizables ---

@pytest.fixture
def datos_compra_btc():
    """Fixture que proporciona datos de compra para Bitcoin."""
    return {
        "total_invertido": Decimal("45000"),
        "cantidad_comprada": Decimal("1.5")
    }

@pytest.fixture
def mock_billetera_data():
    """Fixture con datos simulados de la billetera."""
    return [
        {"ticker": "BTC", "cantidad": "1.5"},
        {"ticker": "ETH", "cantidad": "2.0"}
    ]

@pytest.fixture
def mock_historial_data():
    """Fixture con datos simulados del historial de transacciones."""
    return [
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "0.5"}, "valor_usd": "15000"},
        {"tipo": "compra", "destino": {"ticker": "ETH", "cantidad": "2.0"}, "valor_usd": "20000"}
    ]

@pytest.fixture
def mock_cotizaciones_data():
    """Fixture con datos simulados de cotizaciones."""
    return {
        "BTC": Decimal("40000"),
        "ETH": Decimal("1500")
    }


# --- Tests para las funciones ---

def test_calcular_metricas_activo(datos_compra_btc):
    """Prueba la funci√≥n de c√°lculo de m√©tricas para un activo."""
    # Arrange: Preparaci√≥n de datos
    ticker = "BTC"
    cantidad_actual = Decimal("1.5")
    precio_actual = Decimal("40000")
    
    # Act: Ejecuci√≥n de la funci√≥n
    resultado = _calcular_metricas_activo(ticker, cantidad_actual, precio_actual, datos_compra_btc)

    # Assert: Verificaci√≥n de resultados con `assert`
    assert resultado["ticker"] == "BTC"
    assert resultado["cantidad"] == cantidad_actual
    assert resultado["precio_actual"] == precio_actual
    assert resultado["valor_usdt"] == cantidad_actual * precio_actual
    assert resultado["precio_promedio_compra"] == Decimal("30000")
    assert resultado["costo_base_actual"] == cantidad_actual * Decimal("30000")
    assert resultado["ganancia_perdida"] == (cantidad_actual * precio_actual) - (cantidad_actual * Decimal("30000"))

def test_estado_actual_completo(monkeypatch, mock_billetera_data, mock_historial_data, mock_cotizaciones_data):
    """
    Prueba la funci√≥n orquestadora `estado_actual_completo` mockeando
    sus dependencias de acceso a datos.
    """
    # Arrange: Configuraci√≥n de los mocks usando monkeypatch
    monkeypatch.setattr('backend.acceso_datos.datos_billetera.cargar_billetera', lambda: mock_billetera_data)
    monkeypatch.setattr('backend.acceso_datos.datos_historial.cargar_historial', lambda: mock_historial_data)
    monkeypatch.setattr('backend.acceso_datos.datos_cotizaciones.cargar_datos_cotizaciones', lambda: mock_cotizaciones_data)

    # Act: Ejecuci√≥n de la funci√≥n
    resultado = estado_actual_completo()

    # Assert: Verificaci√≥n de resultados
    assert isinstance(resultado, dict)
    assert "BTC" in resultado
    assert "ETH" in resultado
    
    # Verificar c√°lculos para BTC
    btc = resultado["BTC"]
    assert btc["ticker"] == "BTC"
    assert btc["cantidad"] == Decimal("1.5")
    assert btc["precio_actual"] == Decimal("40000")
    
    # Verificar c√°lculos para ETH
    eth = resultado["ETH"]
    assert eth["ticker"] == "ETH"
    assert eth["cantidad"] == Decimal("2.0")
    assert eth["precio_actual"] == Decimal("1500")

==================================================
=== ARCHIVO: ./tests/test_trading_logica.py ===
==================================================

import pytest
from decimal import Decimal, getcontext
from typing import Tuple

# Aseguramos la precisi√≥n para los c√°lculos con Decimal, es una buena pr√°ctica
getcontext().prec = 28

# Importamos la funci√≥n que vamos a testear (con el guion bajo)
from backend.servicios.trading_logica import _calcular_detalles_swap


# --- Tests para Casos de √âxito ---

def test_compra_ingresando_monto_cripto():
    """
    Prueba una compra donde se especifica la cantidad de cripto a RECIBIR.
    Ejemplo: Quiero comprar exactamente 0.02 BTC.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='comprar',
        modo_ingreso='monto',  # El usuario ingresa la cantidad de cripto
        monto_form=Decimal('0.02'),
        precio_origen_usdt=Decimal('1'),      # Precio de USDT
        precio_destino_usdt=Decimal('50000')  # Precio de BTC
    )
    
    assert exito is True
    assert detalles == {
        'origen': Decimal('1000.0'),  # Costar√° 1000 USDT
        'destino': Decimal('0.02'),   # Para recibir 0.02 BTC
        'valor_usd': Decimal('1000.0')
    }

def test_compra_ingresando_total_fiat():
    """
    Prueba una compra donde se especifica la cantidad de fiat a GASTAR.
    Ejemplo: Quiero gastar exactamente 1000 USDT en BTC.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='comprar',
        modo_ingreso='total',  # El usuario ingresa la cantidad de fiat
        monto_form=Decimal('1000'),
        precio_origen_usdt=Decimal('1'),      # Precio de USDT
        precio_destino_usdt=Decimal('50000')  # Precio de BTC
    )
    
    assert exito is True
    assert detalles == {
        'origen': Decimal('1000'),    # Gastar√© 1000 USDT
        'destino': Decimal('0.02'),   # Y recibir√© 0.02 BTC
        'valor_usd': Decimal('1000')
    }

def test_venta_ingresando_monto_cripto():
    """
    Prueba una venta donde el usuario especifica la cantidad de cripto a VENDER.
    Ejemplo: Quiero vender exactamente 0.1 BTC.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='vender',
        modo_ingreso='monto',  # En ventas, siempre se ingresa la cantidad de cripto
        monto_form=Decimal('0.1'),
        precio_origen_usdt=Decimal('50000'),  # Precio de BTC
        precio_destino_usdt=Decimal('1')      # Precio de USDT
    )
    
    assert exito is True
    assert detalles == {
        'origen': Decimal('0.1'),     # Vender√© 0.1 BTC
        'destino': Decimal('5000'),   # Y recibir√© 5000 USDT
        'valor_usd': Decimal('5000')
    }

# --- Tests para Casos L√≠mite y Errores ---

def test_calculo_con_monto_cero():
    """
    Prueba que un monto de entrada cero resulte en un swap de valor cero.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='comprar',
        modo_ingreso='total',
        monto_form=Decimal('0'),
        precio_origen_usdt=Decimal('1'),
        precio_destino_usdt=Decimal('50000')
    )
    
    assert exito is True
    assert detalles == {
        'origen': Decimal('0'),
        'destino': Decimal('0'),
        'valor_usd': Decimal('0')
    }

def test_calculo_con_precio_destino_cero():
    """
    Prueba que si el precio de destino es cero, no se puede recibir nada.
    """
    exito, detalles = _calcular_detalles_swap(
        accion='comprar',
        modo_ingreso='total',
        monto_form=Decimal('1000'),
        precio_origen_usdt=Decimal('1'),
        precio_destino_usdt=Decimal('0')  # Precio de destino es 0
    )
    
    assert exito is True
    # Si el precio de destino es 0, el valor total no puede convertirse en nada.
    # La implementaci√≥n actual puede dar un ZeroDivisionError aqu√≠, esto es un buen test para descubrirlo.
    # Asumiendo que se maneja, el destino deber√≠a ser 0.
    # NOTA: Este test podr√≠a fallar con ZeroDivisionError si no hay un try-except en la funci√≥n.
    # Si la funci√≥n no lo maneja, el test deber√≠a ser para esperar ese error.
    # Por ahora, asumimos que tu funci√≥n es robusta. Si no, ¬°este test te lo dir√°!
    assert detalles['destino'] == Decimal('0')


def test_falla_al_vender_en_modo_total():
    """
    Prueba que la funci√≥n falle si se intenta vender en modo 'total'.
    """
    exito, resultado = _calcular_detalles_swap(
        accion='vender',
        modo_ingreso='total',
        monto_form=Decimal('100'),
        precio_origen_usdt=Decimal('50000'),
        precio_destino_usdt=Decimal('1')
    )
    
    assert exito is False
    assert isinstance(resultado, str)
    assert "Al vender, debe ingresar la cantidad" in resultado

def test_falla_con_accion_desconocida():
    """
    Prueba que la funci√≥n falle si la acci√≥n no es 'comprar' ni 'vender'.
    """
    exito, resultado = _calcular_detalles_swap(
        accion='intercambiar',
        modo_ingreso='monto',
        monto_form=Decimal('1'),
        precio_origen_usdt=Decimal('1'),
        precio_destino_usdt=Decimal('1')
    )
    
    assert exito is False
    assert "Acci√≥n de trading desconocida" in resultado

==================================================
=== ARCHIVO: ./tests/test_velas_logica.py ===
==================================================

import pytest
import json
import io  # Usaremos io.StringIO para simular archivos de texto de forma m√°s limpia
from decimal import Decimal
from backend.servicios.velas_logica import guardar_datos_cotizaciones, cargar_datos_cotizaciones

# --- Test para guardar_datos_cotizaciones ---

def test_guardar_datos_cotizaciones(monkeypatch):
    """
    Prueba que `guardar_datos_cotizaciones` intente crear el directorio
    y escribir los datos correctos en el archivo.
    """
    # 1. Datos de muestra que se pasar√°n a la funci√≥n
    datos_a_guardar = [
        {'ticker': 'BTC', 'nombre': 'Bitcoin', 'precio_usd': Decimal('50000')}
    ]
    
    # 2. Variables para capturar las llamadas a los mocks
    # Usaremos listas para poder modificarlas desde dentro de las funciones mock
    ruta_makedirs_llamada = []
    datos_escritos = []

    # 3. Mocks de las funciones del sistema de archivos
    def mock_makedirs(path, exist_ok=False):
        # Capturamos la ruta con la que se llam√≥ a makedirs
        ruta_makedirs_llamada.append(path)
        assert exist_ok is True

    def mock_open_para_escritura(file, mode):
        # Verificamos que se intente abrir el archivo en modo escritura ('w')
        assert 'w' in mode
        # Simulamos un objeto archivo que captura lo que se escribe
        class MockFileWriter:
            def write(self, data):
                datos_escritos.append(data)
            def __enter__(self):
                return self
            def __exit__(self, type, value, traceback):
                pass
        return MockFileWriter()

    # 4. Aplicamos los mocks
    monkeypatch.setattr('os.makedirs', mock_makedirs)
    # Usamos 'builtins.open' para mockear la funci√≥n open() global
    monkeypatch.setattr('builtins.open', mock_open_para_escritura)

    # 5. Ejecutamos la funci√≥n a probar
    guardar_datos_cotizaciones(datos_a_guardar)
    
    # 6. Verificamos los resultados
    # Comprobamos que se intent√≥ crear la carpeta 'datos'
    assert ruta_makedirs_llamada and 'datos' in str(ruta_makedirs_llamada[0])
    
    # Comprobamos que lo que se escribi√≥ en el archivo es el JSON correcto
    # Convertimos el string JSON escrito de vuelta a un objeto Python para compararlo
    assert len(datos_escritos) == 1
    datos_guardados = json.loads(datos_escritos[0])
    # Como JSON no tiene tipo Decimal, lo comparamos como string
    assert datos_guardados[0]['precio_usd'] == '50000'
    assert datos_guardados[0]['ticker'] == 'BTC'


# --- Tests para cargar_datos_cotizaciones ---

def test_cargar_datos_cotizaciones_cuando_archivo_existe(monkeypatch):
    """
    Prueba que `cargar_datos_cotizaciones` lea y procese correctamente
    un archivo JSON cuando este existe.
    """
    # 1. Datos que simularemos que est√°n en el archivo
    contenido_json_mock = json.dumps([
        {'ticker': 'BTC', 'nombre': 'Bitcoin', 'precio_usd': '50000.0'}
    ])
    
    # 2. Mocks
    # Simulamos que el archivo S√ç existe
    monkeypatch.setattr('os.path.exists', lambda path: True)
    
    # Simulamos la apertura del archivo, devolviendo nuestro contenido mock
    # io.StringIO es perfecto para simular un archivo de texto en memoria
    monkeypatch.setattr('builtins.open', lambda file, mode: io.StringIO(contenido_json_mock))
    
    # 3. Ejecutamos la funci√≥n
    resultado = cargar_datos_cotizaciones()
    
    # 4. Verificamos los resultados
    assert len(resultado) == 1
    assert resultado[0]['ticker'] == 'BTC'
    assert resultado[0]['nombre'] == 'Bitcoin'
    # La funci√≥n debe convertir el string del JSON a Decimal
    assert resultado[0]['precio_usd'] == Decimal('50000.0')

def test_cargar_datos_cotizaciones_cuando_archivo_no_existe(monkeypatch):
    """
    Prueba que `cargar_datos_cotizaciones` devuelva una lista vac√≠a
    si el archivo de datos no existe.
    """
    # 1. Mock: Simulamos que el archivo NO existe
    monkeypatch.setattr('os.path.exists', lambda path: False)
    
    # 2. Ejecutamos la funci√≥n
    resultado = cargar_datos_cotizaciones()
    
    # 3. Verificamos el resultado
    assert resultado == []

==================================================
=== FIN DEL REPORTE ===
==================================================
