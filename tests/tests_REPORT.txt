==================================================
=== REPORTE DE CÓDIGO CONSOLIDADO ===
Proyecto: tests
Ruta: /Users/andreiveis/UADE/2do cuatrimestre/05_Algoritmos y Estructura de datos I/Trabajo_Simulador_Exchange/tests
Generado el: Mon Jul  7 14:20:22 -03 2025
==================================================

--- ESTRUCTURA DEL DIRECTORIO ---
.
├── __init__.py
├── conftest.py
├── test_datos_cotizaciones.py
├── test_ejecutar_orden.py
├── test_estado_billetera.py
├── test_trading_gestor.py
├── test_trading_motor.py
├── test_trading_procesador.py
└── test_utilidades_numericas.py

1 directory, 9 files
---

==================================================
=== ARCHIVO: ./__init__.py ===
==================================================



==================================================
=== ARCHIVO: ./conftest.py ===
==================================================

"""Configuración Global de Pruebas y Fixtures Compartidas para Pytest.

Este archivo, `conftest.py`, es un mecanismo especial de `pytest` para definir
fixtures, hooks y plugins que estarán disponibles globalmente en toda la suite
de pruebas. Su propósito es centralizar la configuración y los datos de prueba,
promoviendo la reutilización de código y manteniendo los tests limpios y enfocados.

Las fixtures definidas aquí preparan un entorno de prueba controlado y aislado,
fundamental para garantizar que las pruebas sean deterministas y no tengan
efectos secundarios sobre el entorno real o entre ellas.
"""

import pytest
import os
import json
import config
from backend.acceso_datos.datos_cotizaciones import limpiar_cache_precios

@pytest.fixture
def test_environment(tmp_path, monkeypatch):
    """Fixture para crear un entorno de prueba completamente aislado.

    Esta fixture es la base para la mayoría de las pruebas. Realiza dos acciones clave
    para garantizar que cada test se ejecute en un 'sandbox' limpio:

    1.  **Sistema de Archivos Temporal (`tmp_path`)**: Crea un directorio temporal
        único para esta ejecución de prueba. Todos los archivos de datos
        (billetera, historial, etc.) se crean dentro de este directorio.
        `pytest` se encarga de eliminarlo automáticamente al finalizar la prueba.

    2.  **Redirección de Configuración (`monkeypatch`)**: Modifica en tiempo de
        ejecución las variables de ruta del módulo `config` (ej. `config.BILLETERA_PATH`)
        para que apunten a los archivos en `tmp_path`. Esto asegura que el código
        de la aplicación, al ser probado, opere sobre los datos de prueba y no
        sobre los datos reales.

    Yields:
        Dict[str, str]: Un diccionario con las rutas a los archivos de datos
                        temporales, por si alguna prueba necesita acceder a ellos
                        directamente.
    """
    # Crear un subdirectorio para los datos de prueba para mayor orden
    datos_dir = tmp_path / "datos_test"
    datos_dir.mkdir()

    # Rutas a los archivos temporales
    billetera_path = datos_dir / "billetera.json"
    historial_path = datos_dir / "historial.json"
    ordenes_path = datos_dir / "ordenes_pendientes.json"
    cotizaciones_path = datos_dir / "cotizaciones.json"
    comisiones_path = datos_dir / "comisiones.json"

    # Redirigir las constantes del módulo config usando monkeypatch
    monkeypatch.setattr(config, 'BILLETERA_PATH', str(billetera_path))
    monkeypatch.setattr(config, 'HISTORIAL_PATH', str(historial_path))
    monkeypatch.setattr(config, 'ORDENES_PENDIENTES_PATH', str(ordenes_path))
    monkeypatch.setattr(config, 'COTIZACIONES_PATH', str(cotizaciones_path))
    monkeypatch.setattr(config, 'COMISIONES_PATH', str(comisiones_path))

    # Se puede inicializar archivos si es necesario, por ejemplo:
    with open(billetera_path, 'w') as f:
        json.dump({}, f)
    with open(historial_path, 'w') as f:
        json.dump([], f)
    with open(ordenes_path, 'w') as f:
        json.dump([], f)
    with open(cotizaciones_path, 'w') as f:
        json.dump([], f)
    with open(comisiones_path, 'w') as f:
        json.dump({}, f)

    # El fixture puede devolver las rutas si algún test las necesita
    yield {
        "billetera": str(billetera_path),
        "historial": str(historial_path),
        "ordenes": str(ordenes_path),
        "cotizaciones": str(cotizaciones_path),
        "comisiones": str(comisiones_path)
    }

    # La limpieza es automática gracias a tmp_path


@pytest.fixture(autouse=True)
def limpiar_cache_cada_vez():
    """Fixture autoejecutable que limpia la caché de precios antes de cada test.

    Al usar `autouse=True`, esta fixture se invoca automáticamente para cada
    función de prueba, garantizando que el estado de la caché no se filtre
    entre tests. Esto es crucial para mantener el aislamiento y la
    fiabilidad de la suite de pruebas.

    Yields:
        None: No devuelve ningún valor, solo realiza la acción de limpieza.
    """
    limpiar_cache_precios()
    yield
    limpiar_cache_precios() # Limpiar también después, por si acaso


@pytest.fixture
def entorno_con_orden_pendiente(test_environment):
    """Fixture que prepara un escenario con una orden de venta pendiente.

    Esta fixture se basa en `test_environment` para obtener un entorno aislado
    y luego lo puebla con datos específicos para simular un escenario común:

    -   **Billetera**: Contiene 1.0 BTC disponible y 0.5 BTC reservados.
    -   **Órdenes Pendientes**: Existe una orden de venta por 0.5 BTC.

    Es ideal para probar funcionalidades como la cancelación de órdenes o la
    correcta visualización de saldos reservados.

    Args:
        test_environment: La fixture base que provee el entorno aislado.

    Returns:
        El mismo diccionario de rutas que `test_environment`.
    """
    billetera_data = {
        "BTC": {"saldos": {"disponible": "1.0", "reservado": "0.5"}}
    }
    ordenes_data = [
        {"id_orden": "btc_venta_1", "estado": "pendiente", "moneda_reservada": "BTC", "cantidad_reservada": "0.5", "par": "BTC/USDT"}
    ]
    
    with open(config.BILLETERA_PATH, 'w') as f:
        json.dump(billetera_data, f)
    with open(config.ORDENES_PENDIENTES_PATH, 'w') as f:
        json.dump(ordenes_data, f)
        
    return test_environment


@pytest.fixture
def billetera_con_fondos_suficientes(test_environment):
    """Prepara un entorno con una billetera que tiene fondos amplios.

    - USDT: 10000.0
    - BTC: 5.0
    """
    billetera_data = {
        "USDT": {"nombre": "Tether", "saldos": {"disponible": "10000.0", "reservado": "0.0"}},
        "BTC": {"nombre": "Bitcoin", "saldos": {"disponible": "5.0", "reservado": "0.0"}}
    }
    with open(config.BILLETERA_PATH, 'w') as f:
        json.dump(billetera_data, f)
    
    return test_environment

@pytest.fixture
def billetera_con_fondos_insuficientes(test_environment):
    """Prepara un entorno con una billetera con fondos limitados.

    - USDT: 500.0
    """
    billetera_data = {
        "USDT": {"nombre": "Tether", "saldos": {"disponible": "500.0", "reservado": "0.0"}}
    }
    with open(config.BILLETERA_PATH, 'w') as f:
        json.dump(billetera_data, f)
        
    return test_environment


==================================================
=== ARCHIVO: ./test_datos_cotizaciones.py ===
==================================================

"""Pruebas Unitarias para el Módulo de Acceso a Datos de Cotizaciones.

Este archivo contiene un conjunto de pruebas unitarias para el módulo
`backend.acceso_datos.datos_cotizaciones`. El objetivo es verificar la
correcta interacción con el sistema de archivos para la persistencia
de los datos de cotizaciones.

Las pruebas aseguran que:
- Los datos se guardan y cargan correctamente en formato JSON.
- El sistema maneja de forma robusta casos de error, como archivos no encontrados.
- La caché de precios en memoria se actualiza correctamente como un efecto
  secundario de la escritura de datos.

Todas las pruebas utilizan un entorno aislado (`test_environment` fixture) para
no interferir con los datos reales de la aplicación.
"""

import json
from decimal import Decimal

import pytest
import config
from pathlib import Path

from backend.acceso_datos.datos_cotizaciones import (
    cargar_datos_cotizaciones,
    guardar_datos_cotizaciones,
    obtener_precio,
    recargar_cache_precios
)

def test_guardar_y_cargar_datos_cotizaciones_debe_persistir_y_recuperar_datos_cuando_se_usa_ruta_valida(test_environment):
    recargar_cache_precios() # Limpiar cache al inicio
    """Verifica el ciclo completo de guardar y cargar datos de cotizaciones.

    Esta prueba asegura que la funcionalidad básica de persistencia funciona
    correctamente. El flujo de la prueba es el siguiente:

    1.  **Preparación**: Se define una lista de datos de cotizaciones de prueba.
    2.  **Ejecución (Guardado)**: Se llama a `guardar_datos_cotizaciones`. La fixture
        `test_environment` garantiza que esta operación escribe en un archivo
        temporal y aislado, no en el archivo real de la aplicación.
    3.  **Verificación (Guardado)**: Se comprueba que el archivo temporal fue creado
        y que su contenido en formato JSON es el esperado.
    4.  **Ejecución (Cargado)**: Se llama a `cargar_datos_cotizaciones`, que leerá
        del mismo archivo temporal.
    5.  **Verificación (Cargado)**: Se asegura que los datos cargados en memoria
        son idénticos a los que se escribieron.

    Args:
        test_environment: Fixture que provee un entorno de prueba aislado.
    """
    # 1. Preparación: Los datos se guardarán en la ruta gestionada por el fixture.
    datos_a_guardar = [
        {'ticker': 'BTC', 'nombre': 'Bitcoin', 'precio_usd': "50000.12345678"},
        {'ticker': 'ETH', 'nombre': 'Ethereum', 'precio_usd': "3000.87654321"}
    ]

    # 2. Ejecución (Guardar): la función usará la ruta parcheada por el fixture.
    guardar_datos_cotizaciones(datos_a_guardar)

    # 3. Verificación (Guardar): comprobamos que el archivo se escribió correctamente.
    ruta_temporal = Path(test_environment['cotizaciones'])
    assert ruta_temporal.exists()
    datos_leidos_raw = json.loads(ruta_temporal.read_text(encoding='utf-8'))
    
    assert len(datos_leidos_raw) == 2
    assert datos_leidos_raw[0]['precio_usd'] == "50000.12345678"

    # 4. Ejecución (Cargar): leemos desde la misma ruta temporal.
    datos_cargados = cargar_datos_cotizaciones()

    # 5. Verificación (Cargar): comprobamos que los datos se cargaron correctamente.
    assert datos_cargados == datos_leidos_raw

def test_cargar_datos_cotizaciones_debe_retornar_lista_vacia_cuando_archivo_no_existe(test_environment):
    recargar_cache_precios() # Limpiar cache

    # Nos aseguramos de que el archivo no exista en el entorno temporal
    ruta_temporal = Path(test_environment['cotizaciones'])
    if ruta_temporal.exists():
        ruta_temporal.unlink()
    """Verifica que la carga de datos es robusta ante un archivo inexistente.

    Esta prueba simula un escenario de error común: el archivo de cotizaciones
    aún no ha sido creado o ha sido eliminado. Se espera que la función
    `cargar_datos_cotizaciones` maneje esta situación de forma segura,
    devolviendo una lista vacía en lugar de lanzar una excepción.

    Se utiliza `monkeypatch` para forzar que la ruta de configuración apunte
    a una ubicación garantizada de no existir.

    Args:
        monkeypatch: Fixture de pytest para modificar objetos en tiempo de ejecución.
    """

    resultado = cargar_datos_cotizaciones()
    assert resultado == []

def test_guardar_datos_cotizaciones_debe_actualizar_cache_de_precios_cuando_se_guardan_nuevos_datos(test_environment):
    """Verifica que guardar cotizaciones actualiza la caché de precios en memoria.

    Esta es una prueba de integración clave entre la capa de persistencia y la
    caché de acceso rápido en memoria. Comprueba un efecto secundario crucial:
    después de llamar a `guardar_datos_cotizaciones`, la caché interna debe
    ser invalidada y recargada, de modo que `obtener_precio` refleje
    inmediatamente los nuevos valores.

    Flujo de la prueba:
    1.  Se asegura que la caché está inicialmente vacía.
    2.  Se guardan nuevos datos de cotización.
    3.  Se verifica que `obtener_precio` ahora devuelve el precio recién guardado,
        confirmando que la caché se actualizó.

    Args:
        test_environment: Fixture que provee un entorno de prueba aislado.
    """
    # 1. Preparación:
    # El fixture `test_environment` ya ha redirigido la ruta a un archivo temporal
    # y lo ha creado vacío. Forzamos una recarga para asegurar que el caché esté vacío.
    recargar_cache_precios()
    assert obtener_precio('TESTCOIN') is None

    # 2. Ejecución:
    # Guardamos datos de prueba. El fixture asegura que se usa el archivo temporal.
    datos_test = [{'ticker': 'TESTCOIN', 'nombre': 'Test Coin', 'precio_usd': "9999"}]
    guardar_datos_cotizaciones(datos_test)

    # 3. Verificación:
    # La función `guardar_datos_cotizaciones` debe haber recargado el caché global.
    # Ahora, `obtener_precio` debe devolver el nuevo valor.
    assert obtener_precio('TESTCOIN') == Decimal("9999")

==================================================
=== ARCHIVO: ./test_ejecutar_orden.py ===
==================================================

"""Pruebas Unitarias para el Módulo de Ejecución de Transacciones.

Este archivo se enfoca en probar la función `ejecutar_transaccion`, que es el
corazón de la lógica de trading de más bajo nivel. Esta función es responsable
de la operación atómica que modifica los saldos de la billetera y crea los
registros de historial y comisiones correspondientes.

Las pruebas aquí verifican:
- El cálculo correcto de las cantidades (neta, destino, comisión).
- La actualización precisa de los saldos de la billetera (disponible/reservado).
- La correcta creación y persistencia de los registros en los archivos de
  historial y comisiones.
- La consistencia de los datos devueltos por la función.
"""

import pytest
import json
from decimal import Decimal

from backend.servicios.trading.ejecutar_orden import ejecutar_transaccion
from backend.acceso_datos.datos_billetera import cargar_billetera, guardar_billetera
from config import TASA_COMISION

def test_ejecutar_transaccion_debe_completar_compra_y_actualizar_archivos_cuando_es_orden_de_mercado_valida(test_environment):
    """Verifica el flujo completo y exitoso de una orden de compra a mercado."""
    # ARRANGE: Poblar los archivos temporales creados por el fixture
    ruta_billetera = test_environment['billetera']
    ruta_cotizaciones = test_environment['cotizaciones']
    ruta_historial = test_environment['historial']
    ruta_comisiones = test_environment['comisiones']

    # 1. Poblar billetera.json inicial
    billetera_inicial = {
        "USDT": {"nombre": "Tether", "saldos": {"disponible": "10000.0", "reservado": "0.0"}},
        "BTC": {"nombre": "Bitcoin", "saldos": {"disponible": "1.0", "reservado": "0.5"}}
    }
    with open(ruta_billetera, 'w') as f:
        json.dump(billetera_inicial, f)

    # 2. Poblar cotizaciones.json con precios
    cotizaciones = [
        {"ticker": "USDT", "precio_usd": "1.0"},
        {"ticker": "BTC", "precio_usd": "50000.0"}
    ]
    with open(ruta_cotizaciones, 'w') as f:
        json.dump(cotizaciones, f)
        
    # ACT: Ejecutar la transacción
    cantidad_a_gastar_bruta = Decimal('1000')
    billetera_cargada = cargar_billetera(ruta_billetera)

    exito, detalles = ejecutar_transaccion(
        billetera=billetera_cargada,
        moneda_origen='USDT',
        cantidad_origen_bruta=cantidad_a_gastar_bruta,
        moneda_destino='BTC',
        tipo_operacion_historial='Compra Mercado',
        es_orden_pendiente=False,
        ruta_cotizaciones=ruta_cotizaciones
    )
    # Persistir los cambios en la billetera para que la aserción los pueda leer del archivo
    guardar_billetera(billetera_cargada, ruta_archivo=ruta_billetera)

    # ASSERT: Verificar el estado final
    assert exito is True

    # 1. Verificar detalles devueltos
    comision_esperada = cantidad_a_gastar_bruta * TASA_COMISION
    cantidad_neta_esperada = cantidad_a_gastar_bruta - comision_esperada
    cantidad_destino_esperada = cantidad_neta_esperada / Decimal('50000')
    assert detalles['cantidad_comision'] == comision_esperada
    assert detalles['cantidad_destino_final'] == cantidad_destino_esperada

    # 2. Verificar historial.json
    with open(ruta_historial, 'r') as f:
        historial = json.load(f)
    assert len(historial) == 1
    assert historial[0]['tipo'] == 'Compra Mercado'
    assert historial[0]['destino']['ticker'] == 'BTC'

    # 3. Verificar comisiones.json
    with open(ruta_comisiones, 'r') as f:
        comisiones = json.load(f)
    assert len(comisiones) == 1
    assert comisiones[0]['ticker'] == 'USDT'
    assert Decimal(comisiones[0]['cantidad']) == comision_esperada.quantize(Decimal("0.00000001"))

    # 4. Verificar billetera.json
    with open(ruta_billetera, 'r') as f:
        billetera_final = json.load(f)
    saldo_usdt_final = Decimal(billetera_final['USDT']['saldos']['disponible'])
    saldo_btc_final = Decimal(billetera_final['BTC']['saldos']['disponible'])
    assert saldo_usdt_final == Decimal('9000')
    assert saldo_btc_final == Decimal('1.0') + cantidad_destino_esperada

    # 4. Verificar el estado final de la billetera (leyendo el objeto modificado)
    assert billetera_cargada['USDT']['saldos']['disponible'] == Decimal('9000') # 10000 - 1000
    assert billetera_cargada['BTC']['saldos']['disponible'] == Decimal('1') + cantidad_destino_esperada
    assert billetera_cargada['BTC']['saldos']['reservado'] == Decimal('0.5') # No debe cambiar

def test_ejecutar_transaccion_debe_fallar_si_no_se_encuentra_precio(test_environment):
    """
    Verifica que la transacción falla de forma controlada si falta una cotización.
    """
    # ARRANGE
    billetera_cargada = { "USDT": {"saldos": {"disponible": Decimal("1000")}}}
    # El archivo de cotizaciones está intencionalmente vacío
    with open(test_environment['cotizaciones'], 'w') as f:
        json.dump([], f)

    # ACT
    exito, detalles = ejecutar_transaccion(
        billetera=billetera_cargada,
        moneda_origen='USDT',
        cantidad_origen_bruta=Decimal('100'),
        moneda_destino='BTC',
        tipo_operacion_historial='Compra Mercado',
        ruta_cotizaciones=test_environment['cotizaciones']
    )

    # ASSERT
    assert exito is False
    assert "error" in detalles
    assert "No se pudo obtener la cotización" in detalles["error"]

==================================================
=== ARCHIVO: ./test_estado_billetera.py ===
==================================================

"""Pruebas Unitarias para el Servicio de Estado de Billetera.

Este archivo contiene pruebas para el módulo `backend.servicios.estado_billetera`,
que es responsable de calcular y formatear los datos consolidados de la billetera
para su presentación en la interfaz de usuario.

Las pruebas se dividen en dos categorías principales:
1.  **Pruebas de Funciones Puras**: Verifican la lógica de negocio de las
    funciones de cálculo (`_preparar_datos_compra`, `_calcular_metricas_activo`)
    de forma aislada, sin depender de I/O. Estas pruebas son rápidas y cubren
    diversos casos de borde.
2.  **Pruebas de Integración con I/O**: Verifican las funciones principales
    (`estado_actual_completo`, `obtener_historial_formateado`) que orquestan
    la lectura de datos desde archivos. Utilizan la fixture `tmp_path` de pytest
    para interactuar con archivos reales en un entorno temporal y aislado.
"""

import pytest
import json
from decimal import Decimal

from backend.servicios.estado_billetera import (
    _calcular_metricas_activo,
    _preparar_datos_compra,
    estado_actual_completo,
    obtener_historial_formateado
)

# --- Fixtures: Datos de prueba reutilizables ---

@pytest.fixture
def datos_compra_btc():
    """Proporciona un diccionario de ejemplo con datos de compra para BTC.

    Este fixture simula el resultado agregado de la función `_preparar_datos_compra`
    para un activo específico. Es utilizado por las pruebas que calculan métricas
    para desacoplarlas de la lógica de preparación de datos.

    Returns:
        dict: Un diccionario con el total invertido y la cantidad comprada.
    """
    return {
        "total_invertido": Decimal("45000"),
        "cantidad_comprada": Decimal("1.5")
    }

# --- Tests para las funciones puras (sin cambios, no dependen de I/O) ---

def test_preparar_datos_compra_debe_procesar_solo_compras_y_agrupar_por_ticker_cuando_historial_es_mixto():
    """Verifica que se procese un historial mixto correctamente.

    Esta prueba asegura que la función:
    -   Filtra y procesa únicamente las transacciones de tipo 'compra'.
    -   Ignora las transacciones de 'venta' y otros tipos.
    -   Excluye el ticker 'USDT', ya que no se considera una inversión.
    -   Agrupa los resultados por ticker.
    """
    historial = [
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "venta", "destino": {"ticker": "BTC", "cantidad": "0.5"}, "valor_usd": "15000"},
        {"tipo": "compra", "destino": {"ticker": "ETH", "cantidad": "2.0"}, "valor_usd": "20000"},
        {"tipo": "compra", "destino": {"ticker": "USDT", "cantidad": "1000"}, "valor_usd": "1000"},
    ]
    resultado = _preparar_datos_compra(historial)
    assert set(resultado.keys()) == {"BTC", "ETH"}
    assert resultado["BTC"]["total_invertido"] == Decimal("30000")
    assert resultado["BTC"]["cantidad_comprada"] == Decimal("1.0")
    assert resultado["ETH"]["total_invertido"] == Decimal("20000")
    assert resultado["ETH"]["cantidad_comprada"] == Decimal("2.0")

def test_preparar_datos_compra_debe_retornar_diccionario_vacio_cuando_historial_esta_vacio():
    """Verifica el comportamiento con una lista de historial vacía.

    Prueba el caso de borde donde no hay transacciones. Se espera que la función
    devuelva un diccionario vacío sin errores.
    """
    resultado = _preparar_datos_compra([])
    assert resultado == {}

def test_preparar_datos_compra_debe_retornar_diccionario_vacio_cuando_historial_no_contiene_compras():
    """Verifica el comportamiento con un historial que no contiene compras.

    Prueba el caso donde existen transacciones, pero ninguna es de tipo 'compra'.
    Se espera que la función devuelva un diccionario vacío.
    """
    historial = [
        {"tipo": "venta", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "transferencia", "destino": {"ticker": "ETH", "cantidad": "2.0"}, "valor_usd": "20000"},
    ]
    resultado = _preparar_datos_compra(historial)
    assert resultado == {}

def test_preparar_datos_compra_debe_sumarizar_valores_cuando_hay_multiples_compras_del_mismo_activo():
    """Verifica que se agrupen múltiples compras del mismo activo.

    Esta prueba asegura que la función suma correctamente el `total_invertido`
    y la `cantidad_comprada` de varias transacciones de compra para un único
    ticker.
    """
    historial = [
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "0.5"}, "valor_usd": "15000"},
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "0.25"}, "valor_usd": "7000"},
    ]
    resultado = _preparar_datos_compra(historial)
    assert set(resultado.keys()) == {"BTC"}
    assert resultado["BTC"]["total_invertido"] == Decimal("52000")
    assert resultado["BTC"]["cantidad_comprada"] == Decimal("1.75")


def test_calcular_metricas_activo_debe_retornar_calculos_correctos_cuando_recibe_datos_validos(datos_compra_btc):
    """Verifica el cálculo de todas las métricas de rendimiento para un activo.

    Esta prueba utiliza datos de entrada fijos (cantidad actual, precio actual
    y datos de compra desde una fixture) para verificar que todos los cálculos
    derivados (valor total, precio promedio, costo base, ganancia/pérdida)
    son correctos.

    Args:
        datos_compra_btc: Fixture con datos de compra agregados para BTC.
    """
    ticker = "BTC"
    cantidad_actual = Decimal("1.5")
    precio_actual = Decimal("40000")
    
    resultado = _calcular_metricas_activo(ticker, cantidad_actual, precio_actual, datos_compra_btc)

    assert resultado["ticker"] == "BTC"
    assert resultado["cantidad"] == cantidad_actual
    assert resultado["precio_actual"] == precio_actual
    assert resultado["valor_usdt"] == cantidad_actual * precio_actual
    assert resultado["precio_promedio_compra"] == Decimal("30000")
    assert resultado["costo_base_actual"] == cantidad_actual * Decimal("30000")
    assert resultado["ganancia_perdida"] == (cantidad_actual * precio_actual) - (cantidad_actual * Decimal("30000"))

# --- Tests para las funciones con I/O (refactorizados) ---

def test_estado_actual_completo_debe_generar_reporte_consolidado_cuando_lee_archivos_de_datos(tmp_path):
    """Prueba de integración para `estado_actual_completo` con archivos reales.

    Este test verifica el flujo completo de la función, que orquesta la lectura
    de múltiples archivos JSON (billetera, historial, cotizaciones) para generar
    el estado consolidado de la billetera.

    El uso de `tmp_path` permite crear un entorno de prueba realista y aislado:
    1.  **Arrange**: Se escriben archivos `billetera.json`, `historial.json` y
        `cotizaciones.json` con datos de prueba en un directorio temporal.
    2.  **Act**: Se llama a `estado_actual_completo` apuntando a estas rutas temporales.
    3.  **Assert**: Se verifica que el resultado final sea correcto, incluyendo:
        - Que solo se incluyan activos con saldo.
        - Que los cálculos y el formato de los datos sean los esperados.

    Args:
        tmp_path: Fixture de pytest que proporciona una ruta a un directorio temporal.
    """
    # 1. Preparación: Crear archivos de datos temporales
    ruta_billetera = tmp_path / "billetera.json"
    ruta_historial = tmp_path / "historial.json"
    ruta_cotizaciones = tmp_path / "cotizaciones.json"

    billetera_data = {
        "BTC": {"saldos": {"disponible": "1.5", "reservado": "0"}},
        "ETH": {"saldos": {"disponible": "2.0", "reservado": "0"}},
        "DOGE": {"saldos": {"disponible": "0", "reservado": "0"}}
    }
    historial_data = [
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "1.0"}, "valor_usd": "30000"},
        {"tipo": "compra", "destino": {"ticker": "BTC", "cantidad": "0.5"}, "valor_usd": "15000"},
        {"tipo": "compra", "destino": {"ticker": "ETH", "cantidad": "2.0"}, "valor_usd": "20000"}
    ]
    cotizaciones_data = [
        {"ticker": "BTC", "nombre": "Bitcoin", "precio_usd": "40000", "logo": "logo_btc.png"},
        {"ticker": "ETH", "nombre": "Ethereum", "precio_usd": "1500", "logo": "logo_eth.png"}
    ]

    ruta_billetera.write_text(json.dumps(billetera_data), encoding='utf-8')
    ruta_historial.write_text(json.dumps(historial_data), encoding='utf-8')
    ruta_cotizaciones.write_text(json.dumps(cotizaciones_data), encoding='utf-8')

    # 2. Ejecución
    resultado_lista = estado_actual_completo(
        ruta_billetera=str(ruta_billetera),
        ruta_historial=str(ruta_historial),
        ruta_cotizaciones=str(ruta_cotizaciones)
    )

    # 3. Verificación
    assert isinstance(resultado_lista, list)
    assert len(resultado_lista) == 2
    assert resultado_lista[0]['ticker'] == 'BTC'
    assert resultado_lista[1]['ticker'] == 'ETH'
    assert not any(activo['ticker'] == 'DOGE' for activo in resultado_lista)

    btc = resultado_lista[0]
    eth = resultado_lista[1]

    assert btc["ticker"] == "BTC"
    assert btc["cantidad_total"] == "1.5"
    assert btc["valor_usdt_formatted"] == "$60,000"
    assert btc["logo"] == "logo_btc.png"
    assert btc["ganancia_perdida_formatted"] == "$15,000"

    assert eth["ticker"] == "ETH"
    assert eth["cantidad_total"] == "2.0"
    assert eth["valor_usdt_formatted"] == "$3,000"
    assert eth["logo"] == "logo_eth.png"
    assert eth["ganancia_perdida_formatted"] == "$-17,000"

def test_obtener_historial_formateado_debe_aplicar_formato_de_presentacion_cuando_lee_historial(tmp_path):
    """Prueba de integración para `obtener_historial_formateado`.

    Verifica que la función lee correctamente un archivo de historial y aplica
    el formato esperado a cada campo para su visualización en la interfaz.

    Flujo de la prueba:
    1.  **Arrange**: Se crea un archivo `historial.json` temporal con un registro.
    2.  **Act**: Se llama a `obtener_historial_formateado`.
    3.  **Assert**: Se comprueba que los campos clave (`tipo`, `par`, `fecha`, etc.)
        hayan sido transformados al formato de presentación correcto.

    Args:
        tmp_path: Fixture de pytest que proporciona una ruta a un directorio temporal.
    """
    ruta_historial = tmp_path / "historial_test.json"
    historial_data = [
        {
            "id": "123", "tipo": "compra", "timestamp": "2023-10-27T10:00:00Z",
            "origen": {"ticker": "USDT"},
            "destino": {"ticker": "BTC", "cantidad": "0.5"},
            "valor_usd": "25000"
        }
    ]
    ruta_historial.write_text(json.dumps(historial_data), encoding='utf-8')

    resultado = obtener_historial_formateado(ruta_historial=str(ruta_historial))

    assert len(resultado) == 1
    item = resultado[0]
    assert item["id"] == "123"
    assert item["tipo_formatted"] == "Compra"
    assert item["par_formatted"] == "BTC/USDT"
    assert "27/10/2023" in item["fecha_formatted"]
    assert item["cantidad_formatted"] == "0.5"
    assert item["valor_total_formatted"] == "$25,000"

==================================================
=== ARCHIVO: ./test_trading_gestor.py ===
==================================================

"""Pruebas Unitarias para el Módulo Gestor de Trading.

Este archivo contiene pruebas para la función `cancelar_orden_pendiente` del
módulo `backend.servicios.trading.gestor`. Esta función es crítica para la
interacción del usuario, ya que le permite revertir órdenes que aún no se han
ejecutado.

Las pruebas verifican los siguientes escenarios:
- La cancelación exitosa de una orden, asegurando la correcta liberación de
  fondos reservados en la billetera.
- Los casos de error, como intentar cancelar una orden inexistente o una orden
  que ya no está en estado 'pendiente'.

Se utilizan fixtures para crear un entorno de prueba aislado y consistente.
"""
import pytest
from decimal import Decimal
import json

# Importar la función a probar
from backend.servicios.trading.gestor import cancelar_orden_pendiente
# Importar funciones de acceso a datos para verificar
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes, guardar_ordenes_pendientes

def test_cancelar_orden_pendiente_debe_liberar_fondos_y_cambiar_estado_a_cancelada_cuando_orden_existe_y_esta_pendiente(entorno_con_orden_pendiente):
    """Verifica la cancelación exitosa de una orden y la liberación de fondos.

    Este es el "happy path" o caso de éxito. La prueba asegura que cuando un
    usuario cancela una orden pendiente, ocurren dos efectos críticos:
    1.  Los fondos que estaban 'reservados' para esa orden en la billetera son
        devueltos al saldo 'disponible'.
    2.  La orden cambia su estado a 'cancelada' para que no sea procesada por
        el motor de trading.

    La fixture `entorno_con_orden_pendiente` se encarga de crear el estado
    inicial necesario (billetera con fondos reservados y una orden pendiente).

    Args:
        entorno_con_orden_pendiente: Fixture que prepara un escenario de prueba
            con una orden de venta de BTC pendiente.
    """
    # Arrange: ¡Ya está hecho por el fixture!

    # Act
    resultado = cancelar_orden_pendiente("btc_venta_1")

    # Assert
    assert resultado["estado"] == "ok"


    billetera_final = cargar_billetera()
    ordenes_finales = cargar_ordenes_pendientes()

    # Fondos liberados
    assert billetera_final["BTC"]["saldos"]["reservado"] == Decimal("0")
    assert billetera_final["BTC"]["saldos"]["disponible"] == Decimal("1.5")

    # Estado de la orden cambiado
    orden_cancelada = next(o for o in ordenes_finales if o["id_orden"] == "btc_venta_1")
    assert orden_cancelada["estado"] == "cancelada"


def test_cancelar_orden_pendiente_debe_fallar_cuando_id_de_orden_no_existe(test_environment):
    """Verifica que el sistema maneja correctamente un ID de orden inválido.

    Esta prueba de robustez asegura que si se intenta cancelar una orden con un
    ID que no corresponde a ninguna orden pendiente, la función falla de forma
    controlada, devolviendo un estado de 'error' y un mensaje claro, sin
    alterar el estado del sistema.

    Args:
        test_environment: Fixture que provee un entorno de prueba limpio y aislado.
    """
    # Arrange: El fixture `test_environment` ya creó un archivo de órdenes vacío.

    # Act
    resultado = cancelar_orden_pendiente("id_invalido")

    # Assert
    assert resultado["estado"] == "error"
    assert "No se encontró una orden" in resultado["mensaje"]
    assert "id_invalido" in resultado["mensaje"]


def test_cancelar_orden_pendiente_debe_fallar_cuando_orden_no_esta_en_estado_pendiente(test_environment):
    """Verifica que una orden solo puede cancelarse si su estado es 'pendiente'.

    Esta prueba valida la lógica de la máquina de estados de una orden. Una vez
    que una orden ha sido 'ejecutada' o 'cancelada', no puede volver a ser
    cancelada. El test modifica el estado de una orden (preparada por el fixture)
    a 'ejecutada' y luego a 'cancelada', y verifica que en ambos casos la
    función `cancelar_orden_pendiente` rechace la operación con un error.

    Args:
        test_environment: Fixture que prepara el escenario base.
    """
    # Arrange: Crear un estado inicial con una orden ya 'ejecutada'
    ruta_billetera = test_environment['billetera']
    ruta_ordenes = test_environment['ordenes']

    billetera_inicial = {
        "USDT": {"nombre": "Tether", "saldos": {"disponible": "10000.0", "reservado": "0.0"}},
        "BTC": {"nombre": "Bitcoin", "saldos": {"disponible": "1.0", "reservado": "0.5"}}
    }
    with open(ruta_billetera, 'w') as f:
        json.dump(billetera_inicial, f)

    orden_ejecutada = {
        "id_orden": "btc_venta_1",
        "ticker": "BTC/USDT",
        "accion": "venta",
        "tipo_orden": "limit",
        "cantidad": "0.5",
        "precio": "60000",
        "estado": "ejecutada" # Estado clave para esta prueba
    }
    with open(ruta_ordenes, 'w') as f:
        json.dump([orden_ejecutada], f)

    # Act
    resultado = cancelar_orden_pendiente("btc_venta_1")

    # Assert
    assert resultado["estado"] == "error"
    assert "no puede ser cancelada" in resultado["mensaje"]
    assert "estado actual: 'ejecutada'" in resultado["mensaje"]
    
def test_cancelar_orden_con_error_de_consistencia_de_fondos(test_environment):
    """
    Verifica que la cancelación falla si los fondos a liberar en la orden
    no coinciden con los fondos reservados en la billetera.
    """
    # ARRANGE: Crear una inconsistencia de datos
    billetera_data = {
        "BTC": {"nombre": "Bitcoin", "saldos": {"disponible": "1.0", "reservado": "0.1"}} # Solo 0.1 reservado
    }
    orden_data = [{
        "id_orden": "btc_venta_inconsistente",
        "estado": "pendiente",
        "moneda_reservada": "BTC",
        "cantidad_reservada": "0.5" # ¡La orden cree que reservó 0.5!
    }]
    with open(test_environment['billetera'], 'w') as f:
        json.dump(billetera_data, f)
    with open(test_environment['ordenes'], 'w') as f:
        json.dump(orden_data, f)

    # ACT
    resultado = cancelar_orden_pendiente("btc_venta_inconsistente")

    # ASSERT
    assert resultado["estado"] == "error"
    assert "Error de consistencia" in resultado["mensaje"]

    # Verificar que el estado de la orden se marcó como erróneo
    ordenes_finales = cargar_ordenes_pendientes(ruta_archivo=test_environment['ordenes'])
    assert ordenes_finales[0]["estado"] == "error"

==================================================
=== ARCHIVO: ./test_trading_motor.py ===
==================================================

"""Pruebas Unitarias para el Motor de Trading.

Este archivo prueba el motor de trading (`backend.servicios.trading.motor`), que
es el componente responsable de verificar y ejecutar automáticamente las órdenes
pendientes (Limit, Stop-Limit) cuando las condiciones del mercado son favorables.

Las pruebas se dividen en dos partes:
1.  **Prueba de Lógica Pura**: Se utiliza una prueba parametrizada para validar
    la función `_verificar_condicion_orden`, que contiene las reglas de negocio
    esenciales para decidir si una orden debe dispararse.
2.  **Prueba de Integración**: Se prueba la función principal
    `verificar_y_ejecutar_ordenes_pendientes`, asegurando que el motor lee
    correctamente los datos de mercado, identifica órdenes ejecutables y
    orquesta la transacción, modificando los archivos de estado (órdenes,
    billetera, historial).
"""
import pytest
import json
from decimal import Decimal

# Funciones puras a probar
from backend.servicios.trading.motor import _verificar_condicion_orden
# Función principal de integración a probar
from backend.servicios.trading.motor import verificar_y_ejecutar_ordenes_pendientes

# Funciones de acceso a datos para verificar resultados
from backend.acceso_datos.datos_billetera import cargar_billetera
from backend.acceso_datos.datos_ordenes import cargar_ordenes_pendientes

# Módulo de configuración para redirigir rutas
import config

# --- Tests para la lógica pura de verificación (sin cambios) ---

@pytest.mark.parametrize("accion, tipo, precio_limite, precio_mercado, esperado", [
    ("compra", "limit", "40000", "39000", True),
    ("compra", "limit", "40000", "40001", False),
    ("venta", "limit", "60000", "61000", True),
    ("venta", "limit", "60000", "59999", False),
    ("compra", "stop-limit", "55000", "56000", True),
    ("compra", "stop-limit", "55000", "54999", False),
    ("venta", "stop-limit", "45000", "44000", True),
    ("venta", "stop-limit", "45000", "45001", False),
])
def test_verificar_condicion_orden_debe_evaluar_correctamente_condiciones_de_disparo_para_todos_los_tipos_de_orden(accion, tipo, precio_limite, precio_mercado, esperado):
    """Valida de forma exhaustiva las reglas de negocio para disparar órdenes.

    Esta prueba parametrizada es fundamental, ya que verifica el corazón lógico
    del motor de trading. Cubre todos los casos posibles para los tipos de
    órdenes soportados:

    -   **Compra Limit**: Se ejecuta si `precio_mercado <= precio_limite`.
    -   **Venta Limit**: Se ejecuta si `precio_mercado >= precio_limite`.
    -   **Compra Stop-Limit**: Se ejecuta si `precio_mercado >= precio_disparo`.
    -   **Venta Stop-Limit**: Se ejecuta si `precio_mercado <= precio_disparo`.

    El uso de `@pytest.mark.parametrize` hace que el test sea conciso, legible
    y fácil de extender con nuevos casos.

    Args:
        accion (str): 'compra' o 'venta'.
        tipo (str): 'limit' o 'stop-limit'.
        precio_limite (str): El precio límite o de disparo de la orden.
        precio_mercado (str): El precio actual del mercado a verificar.
        esperado (bool): El resultado esperado de la verificación.
    """
    orden = {"accion": accion, "tipo_orden": tipo, "precio_disparo": precio_limite}
    assert _verificar_condicion_orden(orden, Decimal(precio_mercado)) is esperado

# --- Tests para la función principal del motor (simplificados) ---

def crear_archivo_json(ruta, contenido):
    """Crea un archivo JSON en la ruta especificada con el contenido dado.

    Args:
        ruta (str): La ruta completa del archivo a crear.
        contenido (dict or list): El objeto de Python a serializar en JSON.
    """
    with open(ruta, 'w') as f:
        json.dump(contenido, f, indent=4)

def test_verificar_y_ejecutar_ordenes_pendientes_debe_ejecutar_orden_cuando_condicion_de_mercado_es_favorable(tmp_path):
    """Prueba de integración del motor de trading en un escenario de ejecución.

    Este test verifica el flujo completo del motor en un caso de éxito:
    una orden de compra límite cuyo precio de mercado es favorable.

    Flujo de la prueba:
    1.  **Arrange**: Se configura un entorno de archivos temporales (billetera,
        órdenes, cotizaciones, etc.) usando `tmp_path`. Se crea una orden de
        compra límite y se establece un precio de mercado que cumple la condición.
    2.  **Act**: Se invoca a `verificar_y_ejecutar_ordenes_pendientes()`.
    3.  **Assert**: Se verifica que la ejecución tuvo los efectos esperados:
        - El estado de la orden en `ordenes.json` cambia a 'ejecutada'.
        - Los fondos reservados en `billetera.json` se utilizan.
        - El nuevo activo (BTC) se añade a la billetera.

    Args:
        tmp_path: Fixture de pytest que proporciona un directorio temporal.
    """
    # Arrange: Preparar el entorno de archivos temporales
    datos_dir = tmp_path / "datos"
    datos_dir.mkdir()
    config.BILLETERA_PATH = str(datos_dir / "billetera.json")
    config.ORDENES_PENDIENTES_PATH = str(datos_dir / "ordenes.json")
    config.COTIZACIONES_PATH = str(datos_dir / "cotizaciones.json")
    config.HISTORIAL_PATH = str(datos_dir / "historial.json") # Necesario para ejecutar_transaccion
    config.COMISIONES_PATH = str(datos_dir / "comisiones.json") # Necesario para ejecutar_transaccion

    # Datos de prueba
    crear_archivo_json(config.BILLETERA_PATH, {
        "USDT": {"saldos": {"disponible": "0", "reservado": "4000"}}
    })
    crear_archivo_json(config.ORDENES_PENDIENTES_PATH, [{
        "id_orden": "1", "par": "BTC/USDT", "estado": "pendiente", "accion": "compra", 
        "tipo_orden": "limit", "precio_disparo": "40000", "moneda_reservada": "USDT",
        "cantidad_reservada": "4000", "moneda_destino": "BTC", "moneda_origen": "USDT",
        "cantidad_cripto_principal": "0.1"
    }])
    # Precio favorable para la compra límite
    crear_archivo_json(config.COTIZACIONES_PATH, [
        {"ticker": "BTC", "precio_usd": "39000"},
        {"ticker": "USDT", "precio_usd": "1"}
    ])

    # Act: Ejecutar el motor
    verificar_y_ejecutar_ordenes_pendientes()

    # Assert: Verificar el estado final de los archivos
    ordenes_finales = cargar_ordenes_pendientes(config.ORDENES_PENDIENTES_PATH)
    billetera_final = cargar_billetera(config.BILLETERA_PATH)

    assert ordenes_finales[0]["estado"] == "ejecutada"
    assert billetera_final["USDT"]["saldos"]["reservado"] == Decimal("0")
    assert "BTC" in billetera_final
    assert billetera_final["BTC"]["saldos"]["disponible"] > 0

def test_motor_no_ejecuta_orden_si_condicion_no_es_favorable(test_environment):
    """
    Verifica que el motor no modifica nada si el precio de mercado no es favorable
    para ninguna orden pendiente.
    """
    # ARRANGE
    billetera_inicial = {"USDT": {"saldos": {"disponible": "0", "reservado": "4000"}}}
    orden_pendiente = {
        "id_orden": "1", "par": "BTC/USDT", "estado": "pendiente", "accion": "compra",
        "tipo_orden": "limit", "precio_disparo": "40000", "moneda_reservada": "USDT",
        "cantidad_reservada": "4000", "moneda_destino": "BTC", "moneda_origen": "USDT",
        "cantidad": "0.1" # Nombre de clave corregido para consistencia
    }
    # Precio NO favorable para la compra límite (es más alto)
    cotizaciones = [{"ticker": "BTC", "precio_usd": "41000"}, {"ticker": "USDT", "precio_usd": "1"}]
    
    with open(test_environment['billetera'], 'w') as f: json.dump(billetera_inicial, f)
    with open(test_environment['ordenes'], 'w') as f: json.dump([orden_pendiente], f)
    with open(test_environment['cotizaciones'], 'w') as f: json.dump(cotizaciones, f)

    # ACT
    verificar_y_ejecutar_ordenes_pendientes()

    # ASSERT
    ordenes_final = cargar_ordenes_pendientes(test_environment['ordenes'])
    billetera_final = cargar_billetera(test_environment['billetera'])

    # Nada debe haber cambiado
    assert ordenes_final[0]["estado"] == "pendiente"
    assert billetera_final["USDT"]["saldos"]["reservado"] == Decimal("4000")

==================================================
=== ARCHIVO: ./test_trading_procesador.py ===
==================================================

"""Pruebas de Integración y Unitarias para el Procesador de Trading.

Este archivo se centra en probar `procesar_operacion_trading`, el punto de
entrada principal para las operaciones. Dado que la lógica de creación de
órdenes ahora está integrada, las pruebas se enfocan en verificar el
comportamiento de alto nivel y sus efectos secundarios, como la modificación
de archivos de estado (billetera, órdenes pendientes).

Las pruebas cubren:
- Flujos de error principales (datos de formulario inválidos).
- Flujo completo de creación de una orden límite, incluyendo:
  - La correcta reserva de fondos en la billetera.
  - La creación de la orden en el archivo de órdenes pendientes.
- Casos de fallo, como la falta de fondos, y la no alteración de los archivos.
"""

import pytest
from decimal import Decimal
import json

from backend.servicios.trading.procesador import _validar_saldo_disponible, procesar_operacion_trading
from config import BILLETERA_PATH, ORDENES_PENDIENTES_PATH

def test_validar_saldo_disponible_debe_retornar_exito_cuando_saldo_es_suficiente():
    """Verifica que la validación es exitosa si hay saldo disponible."""
    billetera_fake = {"BTC": {"saldos": {"disponible": Decimal("2.5")}}}
    exito, mensaje = _validar_saldo_disponible(billetera_fake, "BTC", Decimal("1.0"))
    assert exito is True

def test_validar_saldo_disponible_debe_fallar_cuando_saldo_es_insuficiente():
    """Verifica que la validación falla si el saldo es insuficiente."""
    billetera_fake = {"BTC": {"saldos": {"disponible": Decimal("2.5")}}}
    exito, mensaje = _validar_saldo_disponible(billetera_fake, "BTC", Decimal("3.0"))
    assert exito is False
    assert "Saldo insuficiente" in mensaje

def test_procesar_operacion_trading_debe_fallar_cuando_monto_es_negativo_o_cero(test_environment):
    """Verifica que la función principal rechaza montos negativos o inválidos."""
    formulario_malo = {"ticker": "BTC", "accion": "compra", "monto": "-100"}
    respuesta = procesar_operacion_trading(formulario_malo)
    assert respuesta["estado"] == "error"
    assert "monto debe ser un número positivo" in respuesta["mensaje"]

def test_procesar_operacion_trading_debe_fallar_cuando_monedas_son_identicas(test_environment):
    """Verifica que la operación falla si la moneda de origen y destino son la misma."""
    # Para una compra de USDT, la moneda de origen (por defecto) y destino son la misma.
    formulario_compra_malo = {
        "ticker": "USDT", 
        "accion": "compra", 
        "monto": "100",
    }
    respuesta_compra = procesar_operacion_trading(formulario_compra_malo)
    assert respuesta_compra["estado"] == "error"
    assert "La moneda de origen y destino no pueden ser la misma" in respuesta_compra["mensaje"]

# --- Tests de Integración para Órdenes Límite ---

def test_procesar_operacion_limit_exitosa_reserva_fondos_y_crea_orden(test_environment):
    """
    Test de integración: Verifica que una orden LÍMITE de compra válida:
    1. Devuelve una respuesta exitosa.
    2. Reserva los fondos correctamente en la billetera.
    3. Crea una nueva orden en el archivo de órdenes pendientes.
    """
    # ARRANGE
    # 1. Escribir una billetera inicial con fondos suficientes.
    billetera_inicial = {
        "USDT": {"nombre": "Tether", "saldos": {"disponible": "10000", "reservado": "0"}},
        "BTC": {"nombre": "Bitcoin", "saldos": {"disponible": "1", "reservado": "0"}}
    }
    try:
        with open(test_environment['billetera'], 'w') as f:
            json.dump(billetera_inicial, f, indent=4)
    except FileNotFoundError:
        pass

    # 2. Formulario para una orden de compra límite
    formulario = {
        "ticker": "BTC",
        "accion": "compra",
        "monto": "500",  # Comprar con 500 USDT
        "modo-ingreso": "total",
        "tipo-orden": "limit",
        "precio_disparo": "20000" # Precio límite
    }

    # ACT
    respuesta = procesar_operacion_trading(formulario)

    # ASSERT
    # 1. La respuesta debe ser exitosa.
    assert respuesta["estado"] == "ok"
    assert "Orden Límite creada" in respuesta["mensaje"]

    # 2. Verificar el estado final de la billetera.
    try:
        with open(test_environment['billetera'], 'r') as f:
            billetera_final = json.load(f)
    except FileNotFoundError:
        pass

    assert Decimal(billetera_final["USDT"]["saldos"]["disponible"]) == Decimal("9500")
    assert Decimal(billetera_final["USDT"]["saldos"]["reservado"]) == Decimal("500")

    # 3. Verificar que la orden fue creada en el archivo de pendientes.

    # Cargar las órdenes pendientes desde el archivo para poder verificarlas.
    try:
        with open(test_environment['ordenes'], 'r') as f:
            ordenes_pendientes = json.load(f)
    except FileNotFoundError:
        ordenes_pendientes = []

    assert len(ordenes_pendientes) == 1
    orden_creada = ordenes_pendientes[0]
    assert orden_creada["par"] == "BTC/USDT"
    assert orden_creada["accion"] == "compra"
    # La clave en la orden es 'tipo_orden', no 'tipo'
    assert orden_creada["tipo_orden"] == "limit"
    assert Decimal(orden_creada["precio_limite"]) == Decimal("20000")
    # Cantidad de BTC a comprar: 500 USDT / 20000 USD/BTC = 0.025 BTC
    assert Decimal(orden_creada["cantidad"]) == Decimal("0.025")

def test_procesar_operacion_limit_falla_por_fondos_insuficientes(test_environment):
    """
    Test de integración: Verifica que una orden LÍMITE falla si no hay
    fondos suficientes y que el estado de los archivos no cambia.
    """
    # ARRANGE
    # 1. Billetera con fondos insuficientes.
    billetera_inicial = {
    "USDT": {"nombre": "Tether", "saldos": {"disponible": "100", "reservado": "0"}},
    }
    try:
        with open(test_environment['billetera'], 'w') as f:
            json.dump(billetera_inicial, f, indent=4)
    except FileNotFoundError:
        pass
    
    # 2. Formulario que intenta gastar más de lo disponible.
    formulario = {
        "ticker": "BTC",
        "accion": "compra",
        "monto": "500",  # Intentar gastar 500 USDT
        "modo-ingreso": "total",
        "tipo-orden": "limit",
        "precio_disparo": "20000"
    }

    # ACT
    respuesta = procesar_operacion_trading(formulario)

    # ASSERT
    # 1. La respuesta debe ser de error.
    assert respuesta["estado"] == "error"
    assert "Saldo insuficiente" in respuesta["mensaje"]

    # 2. Verificar que las órdenes pendientes siguen vacías.
    try:
        with open(test_environment['ordenes'], 'r') as f:
            ordenes_pendientes = json.load(f)
    except FileNotFoundError:
        ordenes_pendientes = []
    assert len(ordenes_pendientes) == 0

    # 3. Verificar que la billetera no fue modificada.
    try:
        with open(test_environment['billetera'], 'r') as f:
            billetera_final = json.load(f)
    except FileNotFoundError:
        billetera_final = {}
    assert billetera_final == billetera_inicial
    
    
@pytest.mark.parametrize("formulario, mensaje_error_esperado", [
    # Compra Stop-Limit: El precio Stop debe ser MAYOR al de mercado
    ({
        "ticker": "BTC", "accion": "compra", "monto": "0.1", "modo-ingreso": "monto",
        "tipo-orden": "stop-limit", "precio_disparo": "49000", "precio_limite": "50000"
    }, "debe ser > al precio actual"),
    # Venta Stop-Limit: El precio Stop debe ser MENOR al de mercado
    ({
        "ticker": "BTC", "accion": "venta", "monto": "0.1", "modo-ingreso": "monto",
        "tipo-orden": "stop-limit", "precio_disparo": "51000", "precio_limite": "50000"
    }, "debe ser < al precio actual"),
    # Compra Stop-Limit: El precio Límite no puede ser MENOR al Stop
    ({
        "ticker": "BTC", "accion": "compra", "monto": "0.1", "modo-ingreso": "monto",
        "tipo-orden": "stop-limit", "precio_disparo": "51000", "precio_limite": "50000"
    }, "no puede ser < al Precio Stop"),
    # Venta Stop-Limit: El precio Límite no puede ser MAYOR al Stop
    ({
        "ticker": "BTC", "accion": "venta", "monto": "0.1", "modo-ingreso": "monto",
        "tipo-orden": "stop-limit", "precio_disparo": "49000", "precio_limite": "50000"
    }, "no puede ser > al Precio Stop"),
])
def test_procesar_operacion_stop_limit_falla_por_reglas_de_precio_invalidas(test_environment, formulario, mensaje_error_esperado):
    """Verifica las reglas de validación de precios para órdenes Stop-Limit."""
    # ARRANGE: Establecer un precio de mercado de referencia
    cotizaciones = [{"ticker": "BTC", "precio_usd": "50000"}]
    try:
        with open(test_environment['cotizaciones'], 'w') as f:
            json.dump(cotizaciones, f)
    except Exception as e:
        pass
    
    # ACT
    respuesta = procesar_operacion_trading(formulario)

    # ASSERT
    assert respuesta["estado"] == "error"
    assert mensaje_error_esperado in respuesta["mensaje"]

==================================================
=== ARCHIVO: ./test_utilidades_numericas.py ===
==================================================

"""Pruebas Unitarias para las Utilidades Numéricas.

Este archivo contiene pruebas para las funciones auxiliares del módulo
`utils.utilidades_numericas`. Estas funciones son cruciales para mantener la
precisión en los cálculos financieros y para formatear los números de una
manera consistente y legible para el usuario final.

Las pruebas cubren tres áreas principales:
1.  **Conversión Segura**: La función `a_decimal` se prueba para asegurar que
    convierte robustamente varios tipos de datos a `Decimal`, manejando
    errores de forma predecible.
2.  **Cuantización**: Se prueban `cuantizar_cripto` y `cuantizar_usd` para
    verificar que aplican la precisión decimal correcta para cada tipo de activo.
3.  **Formateo**: Se validan las funciones de formato (`formato_cantidad_*`)
    que preparan los números para ser mostrados en la interfaz de usuario.
"""

import pytest
from decimal import Decimal
from backend.utils.utilidades_numericas import a_decimal, cuantizar_cripto, cuantizar_usd

# --- Tests para a_decimal ---

def test_a_decimal_debe_convertir_string_numerico_a_decimal():
    """Verifica que un string numérico se convierte correctamente a Decimal."""
    assert a_decimal("123.45") == Decimal("123.45")

def test_a_decimal_debe_convertir_entero_a_decimal():
    """Verifica que un número entero se convierte correctamente a Decimal."""
    assert a_decimal(123) == Decimal("123")

def test_a_decimal_debe_convertir_flotante_a_decimal():
    """Verifica que un número de punto flotante se convierte correctamente a Decimal."""
    assert a_decimal(123.45) == Decimal("123.45")

def test_a_decimal_debe_convertir_none_a_decimal_cero():
    """Verifica que None se convierte de forma segura a Decimal('0')."""
    assert a_decimal(None) == Decimal("0")

def test_a_decimal_debe_convertir_string_no_numerico_a_decimal_cero():
    """Verifica que un string no numérico se convierte de forma segura a Decimal('0')."""
    assert a_decimal("hola") == Decimal("0")

# --- Tests para cuantizar_cripto ---

def test_cuantizar_cripto_debe_redondear_a_ocho_decimales():
    """Verifica que `cuantizar_cripto` redondea a 8 decimales, estándar para cripto."""
    valor = Decimal("0.123456789")
    assert cuantizar_cripto(valor) == Decimal("0.12345679")

# --- Tests para cuantizar_usd ---

def test_cuantizar_usd_debe_redondear_a_cuatro_decimales():
    """Verifica que `cuantizar_usd` redondea a 4 decimales, útil para precios."""
    valor = Decimal("123.45678")
    assert cuantizar_usd(valor) == Decimal("123.4568")

# --- Tests para formato_cantidad_cripto ---

def test_formato_cantidad_cripto_debe_aplicar_separador_de_miles_a_entero():
    """Verifica el formateo de un número entero con separadores de miles."""
    from backend.utils.utilidades_numericas import formato_cantidad_cripto
    assert formato_cantidad_cripto(Decimal('10000')) == "10,000"

def test_formato_cantidad_cripto_debe_aplicar_separador_de_miles_a_decimal():
    """Verifica el formateo de un número decimal con separadores de miles."""
    from backend.utils.utilidades_numericas import formato_cantidad_cripto
    assert formato_cantidad_cripto(Decimal('12345.67')) == "12,345.67"

def test_formato_cantidad_cripto_debe_eliminar_ceros_decimales_no_significativos():
    """Verifica que el formateo elimina los ceros decimales no significativos."""
    from backend.utils.utilidades_numericas import formato_cantidad_cripto
    assert formato_cantidad_cripto(Decimal('12.1200')) == "12.12"

# --- Tests para formato_cantidad_usd ---

def test_formato_cantidad_usd_debe_incluir_simbolo_dolar_y_separadores():
    """Verifica el formateo de un valor monetario en USD, incluyendo el símbolo '$'."""
    from backend.utils.utilidades_numericas import formato_cantidad_usd
    assert formato_cantidad_usd(Decimal('12345.67')) == "$12,345.67"

def test_formato_cantidad_usd_debe_eliminar_ceros_decimales_no_significativos():
    """Verifica la eliminación de ceros no significativos en el formato USD."""
    from backend.utils.utilidades_numericas import formato_cantidad_usd
    assert formato_cantidad_usd(Decimal('10.1000')) == "$10.1"

# --- Tests para formato_numero_grande ---

def test_formato_numero_grande_debe_abreviar_con_M_cuando_es_millon():
    """Verifica que un número grande (millones) se abrevia con la letra 'M'."""
    from backend.utils.utilidades_numericas import formato_numero_grande
    assert formato_numero_grande(Decimal('1500000')) == "$1.50M"

def test_formato_numero_grande_debe_abreviar_con_B_cuando_es_billon():
    """
    Prueba que un valor en miles de millones se formatea con 'B'.
    """
    from backend.utils.utilidades_numericas import formato_numero_grande
    assert formato_numero_grande(Decimal('2500000000')) == "$2.50B"

def test_formato_numero_grande_debe_usar_formato_estandar_cuando_es_menor_a_un_millon():
    """
    Prueba que un valor menor a un millón usa el formato de formato_cantidad_usd.
    """
    from backend.utils.utilidades_numericas import formato_numero_grande
    assert formato_numero_grande(Decimal('1234.56')) == "$1,234.56"


==================================================
=== FIN DEL REPORTE ===
==================================================
